# Аналіз алгоритму "Apply Overlap Fixes"

## Покроковий опис процесу

### FRONTEND (app.js) - Функція `applyOverlapFixes()`

#### КРОК 1: Ініціалізація (рядки 11158-11167)
- Блокується кнопка
- Встановлюється статус "Applying fixes..."

#### КРОК 2: Отримання primary segments (рядки 11170-11213)
- Отримується активний recording через `getActiveRecording()`
- З recording береться `textResult` через `getTextServiceResult(recording)`
- Якщо немає, використовується fallback до `testResults`
- **ПОТЕНЦІЙНИЙ БАГ #1**: Може брати segments з неправильного джерела

#### КРОК 3: Збір voice track segments (рядки 11215-11223)
- З `recording.overlapMetadata.voiceTracks` збираються segments через `collectVoiceTrackSegments()`
- Voice tracks містять повний текст з розділених аудіо фрагментів
- **ПОТЕНЦІЙНИЙ БАГ #2**: Якщо `overlapMetadata` або `voiceTracks` відсутні, voice tracks не додаються

#### КРОК 4: Маркування та об'єднання segments (рядки 11225-11238)
- Primary segments маркуються як `source: 'primary'`, `isPartial: true`
- Voice track segments мають `source: 'voice-track'`, `isFullText: true`
- Всі segments об'єднуються та сортуються за часом
- **ПОТЕНЦІЙНИЙ БАГ #3**: Може бути дублювання segments якщо primary і voice track мають однакові timestamps

#### КРОК 5: Підготовка даних для LLM (рядки 11240-11299)
- Додається pause detection
- Створюється `segmentsData` з усією метадатою
- Зберігається посилання на оригінальний segment в `_originalSegment`
- **ПОТЕНЦІЙНИЙ БАГ #4**: При великій кількості segments може бути проблема з пам'яттю

#### КРОК 6: Відправка запиту до API (рядки 11302-11312)
- POST запит до `/api/apply-overlap-fixes`
- Відправляється `segmentsData`, `mode: 'local'`, `recordingId`

---

### BACKEND (server.js) - Endpoint `/api/apply-overlap-fixes`

#### КРОК 7: Обробка запиту (рядки 8544-8581)
- Валідація segments array
- Вибір моделі (local LLM)
- **ПОТЕНЦІЙНИЙ БАГ #5**: Якщо segments порожній, повертається помилка

#### КРОК 8: Pause detection (рядки 8583-8628)
- Викликається `detectPauses()` для кожного segment
- Додаються маркери `[PAUSE]` та `[VOICE-TRACK]` / `[PRIMARY]`
- Створюється `transcriptWithPauses`
- **ПОТЕНЦІЙНИЙ БАГ #6**: `detectPauses()` може змінити структуру segments

#### КРОК 9: Обрізання транскрипту (рядки 8630-8649)
- Якщо транскрипт > 6000 символів, він обрізається
- Пріоритет віддається voice track segments
- **ПОТЕНЦІЙНИЙ БАГ #7**: При обрізанні може втратитися важлива інформація

#### КРОК 10: Створення prompt для LLM (рядки 8673-8703)
- Створюється спрощений prompt
- Додаються інструкції про voice tracks та pauses
- **ПОТЕНЦІЙНИЙ БАГ #8**: Prompt може бути занадто складним для local LLM

#### КРОК 11: Виклик LLM (рядки 8710-8766)
- Відправка запиту до local LLM
- Отримання відповіді
- **ПОТЕНЦІЙНИЙ БАГ #9**: LLM може повернути порожній масив або невалідний JSON

#### КРОК 12: Парсинг відповіді LLM (рядки 8768-8792)
- Парсинг JSON з відповіді
- Якщо парсинг не вдався, встановлюється `llmParseSuccess = false`
- **ПОТЕНЦІЙНИЙ БАГ #10**: Може не вдатися парсинг через невалідний JSON

#### КРОК 13: Programmatic Fallback (рядки 8779-8876)
- Якщо LLM повернув порожній масив, використовується fallback
- Об'єднуються voice track segments з primary segments
- Видаляються primary segments, які overlap з voice tracks
- **ПОТЕНЦІЙНИЙ БАГ #11**: Логіка overlap detection може бути неправильною
- **ПОТЕНЦІЙНИЙ БАГ #12**: Може не правильно зберігатися `source` поле

#### КРОК 14: Валідація та збереження метаданих (рядки 8911-8950)
- Перевірка збереження тексту
- Відновлення метаданих з оригінальних segments
- **ПОТЕНЦІЙНИЙ БАГ #13**: Може не правильно знаходити оригінальний segment для відновлення метаданих

#### КРОК 15: Відправка відповіді (рядки 8952-8962)
- Повертається JSON з `success: true` та `segments`

---

### FRONTEND (app.js) - Обробка відповіді

#### КРОК 16: Отримання відповіді (рядки 11319-11321)
- Парсинг JSON відповіді
- Перевірка `result.success` та `result.segments`

#### КРОК 17: Валідація втрати тексту (рядки 11322-11331)
- Порівняння довжини тексту до та після
- Попередження якщо > 10% втрати

#### КРОК 18: Відновлення метаданих (рядки 11333-11359)
- Для кожного corrected segment знаходиться оригінальний
- Відновлюються `originalText`, `translations`, `role`, `overlap`, `words`
- **ПОТЕНЦІЙНИЙ БАГ #14**: Пошук оригінального segment може бути неточним
- **ПОТЕНЦІЙНИЙ БАГ #15**: Може не правильно відновити метадані якщо segments змінилися

#### КРОК 19: Збереження в recording (рядки 11361-11373)
- Оновлюється `recording.results['overlap-corrected'].segments`
- Також оновлюється `textResult.segments` якщо він існує
- **ПОТЕНЦІЙНИЙ БАГ #16**: Може оновити неправильний об'єкт
- **ПОТЕНЦІЙНИЙ БАГ #17**: Якщо `overlap-corrected` не існує, segments не зберігаються

#### КРОК 20: Оновлення UI (рядки 11375-11379)
- Викликається `updateReplicasComparison()`
- Оновлюється статус
- **ПОТЕНЦІЙНИЙ БАГ #18**: `updateReplicasComparison()` може брати segments з неправильного джерела

---

### Функція `updateReplicasComparison()` (app.js, рядки 9765-9858)

#### КРОК 21: Отримання segments для відображення (рядки 9785-9808)
- Пріоритет: `pause-based-merge` > `overlap-corrected` > `text-service`
- **ПОТЕНЦІЙНИЙ БАГ #19**: Може брати segments з `pause-based-merge` замість оновленого `overlap-corrected`
- **ПОТЕНЦІЙНИЙ БАГ #20**: Якщо `overlap-corrected` оновлено, але `pause-based-merge` також існує, показується старий результат

---

## ВИЗНАЧЕНІ ПРОБЛЕМИ

### КРИТИЧНІ БАГИ:

1. **БАГ #17 + #19**: Найбільш ймовірна причина проблеми
   - Якщо `recording.results['overlap-corrected']` не існує, segments не зберігаються
   - Або якщо існує `pause-based-merge`, то `updateReplicasComparison()` показує його замість оновленого `overlap-corrected`
   - **Рішення**: Завжди створювати `overlap-corrected` якщо його немає, або оновлювати пріоритет відображення

2. **БАГ #11**: Логіка overlap detection у fallback
   - Може неправильно визначати overlap між primary та voice track segments
   - Може видаляти primary segments, які потрібні
   - **Рішення**: Покращити логіку overlap detection

3. **БАГ #14 + #15**: Відновлення метаданих
   - Пошук оригінального segment по index або timestamp може бути неточним
   - Може втратитися метадата якщо segments змінилися
   - **Рішення**: Використовувати `_originalSegment` з segmentsData

4. **БАГ #3**: Дублювання segments
   - Якщо primary і voice track мають однакові timestamps, може бути дублювання
   - **Рішення**: Додати дедуплікацію перед відправкою до LLM

### ДРУГОРЯДНІ БАГИ:

5. **БАГ #7**: Обрізання транскрипту може втратити важливу інформацію
6. **БАГ #8**: Prompt може бути занадто складним для local LLM
7. **БАГ #18**: `updateReplicasComparison()` може не оновитися правильно

---

## РЕКОМЕНДАЦІЇ ДЛЯ ВИПРАВЛЕННЯ

1. **Завжди створювати `overlap-corrected` якщо його немає** (рядок 11364)
2. **Оновити пріоритет у `updateReplicasComparison()`** щоб показувати останній оновлений результат
3. **Використовувати `_originalSegment` для відновлення метаданих** замість пошуку по timestamp
4. **Додати дедуплікацію segments** перед відправкою до LLM
5. **Покращити логіку overlap detection** у fallback

