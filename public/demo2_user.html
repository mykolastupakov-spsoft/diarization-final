<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Call Processing</title>
    <style>
        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            max-width: 960px;
            margin: 0 auto;
            padding: 24px 16px 48px;
            background-color: #0f172a;
            color: #e5e7eb;
        }
        h1 {
            font-size: 1.8rem;
            margin: 0 0 4px;
            color: #4ade80;
        }
        p.subtitle {
            margin: 0 0 20px;
            color: #9ca3af;
            font-size: 0.95rem;
        }
        .card {
            background: radial-gradient(circle at top left, rgba(74,222,128,0.15), transparent 60%),
                        radial-gradient(circle at bottom right, rgba(56,189,248,0.15), transparent 60%),
                        #020617;
            border-radius: 18px;
            padding: 20px 18px 18px;
            border: 1px solid rgba(148,163,184,0.35);
            box-shadow: 0 24px 60px rgba(15,23,42,0.9);
        }
        .upload-area {
            border-radius: 14px;
            border: 1px dashed rgba(148,163,184,0.7);
            padding: 18px 16px;
            background: rgba(15,23,42,0.85);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .upload-label {
            font-size: 0.95rem;
            color: #e5e7eb;
            font-weight: 500;
        }
        .file-input-wrapper {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        input[type="file"] {
            display: none;
        }
        .btn-primary {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 9px 16px;
            border-radius: 999px;
            border: none;
            background: linear-gradient(135deg, #22c55e, #16a34a);
            color: white;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 10px 25px rgba(34,197,94,0.35);
            transition: transform 0.08s ease-out, box-shadow 0.08s ease-out, filter 0.12s;
        }
        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 14px 30px rgba(34,197,94,0.4);
            filter: brightness(1.03);
        }
        .btn-primary:active {
            transform: translateY(0);
            box-shadow: 0 6px 16px rgba(34,197,94,0.35);
            filter: brightness(0.98);
        }
        .btn-primary:disabled {
            opacity: 0.6;
            cursor: default;
            box-shadow: none;
            transform: none;
        }
        .file-name {
            font-size: 0.9rem;
            color: #cbd5f5;
        }
        .hint {
            font-size: 0.8rem;
            color: #9ca3af;
        }
        .result-card {
            margin-top: 20px;
        }
        .result-title {
            font-size: 0.95rem;
            color: #e5e7eb;
            font-weight: 600;
            margin-bottom: 10px;
        }
        .result-output {
            background: rgba(2, 6, 23, 0.9);
            border: 1px solid rgba(148,163,184,0.35);
            border-radius: 12px;
            padding: 12px;
            color: #e5e7eb;
            overflow-x: auto;
        }
        .result-output table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
        }
        .result-output th,
        .result-output td {
            border-bottom: 1px solid rgba(148,163,184,0.2);
            padding: 6px 8px;
            text-align: left;
            vertical-align: top;
        }
        .result-output th {
            color: #bbf7d0;
            font-weight: 600;
        }
        .result-output tr:nth-child(even) td {
            background: rgba(15, 23, 42, 0.4);
        }
        .progress-card {
            margin-top: 20px;
        }
        .progress-bar {
            width: 100%;
            height: 10px;
            border-radius: 999px;
            background: rgba(15, 23, 42, 0.9);
            border: 1px solid rgba(148,163,184,0.35);
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #22c55e, #06b6d4);
            transition: width 0.2s ease-out;
        }
        .progress-meta {
            margin-top: 8px;
            font-size: 0.85rem;
            color: #cbd5f5;
            display: flex;
            justify-content: space-between;
            gap: 12px;
            flex-wrap: wrap;
        }
    </style>
</head>
<body>
    <main>
        <h1>Call Processing</h1>
        <p class="subtitle">Upload an audio file to continue.</p>
        <section class="card">
            <div class="upload-area">
                <div class="upload-label">Select a file</div>
                <div class="file-input-wrapper">
                    <input type="file" id="fileInput" name="file" accept="audio/*">
                    <label class="btn-primary" for="fileInput">Upload file</label>
                    <span class="file-name" id="fileName" aria-live="polite"></span>
                </div>
                <div class="hint">Supported: wav, mp3, m4a</div>
            </div>
        </section>
        <section class="card progress-card">
            <div class="result-title">Progress</div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="progress-meta">
                <div id="progressText">Progress: 0 / 0</div>
                <div id="progressLabel">Idle</div>
            </div>
        </section>
        <section class="card result-card">
            <div class="result-title">Final Result (Markdown Table)</div>
            <div class="result-output" id="markdownResult">Waiting for output...</div>
        </section>
    </main>
    <script>
        const fileInput = document.getElementById('fileInput');
        const fileName = document.getElementById('fileName');
        const markdownResult = document.getElementById('markdownResult');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        const progressLabel = document.getElementById('progressLabel');

        console.log('log version 1');

        const logLlmModel = (payload, label) => {
            const modelName = payload?.model || payload?.data?.model || '';
            console.log(`[Stage] ${label} model:`, modelName || 'unknown');
        };

        const renderMarkdownTable = (markdown) => {
            if (typeof markdown !== 'string') {
                return '<div>No data</div>';
            }
            const lines = markdown
                .split(/\r?\n/)
                .map((line) => line.trim())
                .filter((line) => line.length > 0);
            if (lines.length < 2) {
                return `<div>${markdown}</div>`;
            }
            const rows = lines
                .filter((line) => line.startsWith('|'))
                .map((line) => line.replace(/^\||\|$/g, '').split('|').map((cell) => cell.trim()));
            if (rows.length < 2) {
                return `<div>${markdown}</div>`;
            }
            const [header, separator, ...body] = rows;
            if (!separator.every((cell) => /^-+$/.test(cell))) {
                return `<div>${markdown}</div>`;
            }
            const escapeHtml = (value) => value
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
            const thead = `<thead><tr>${header.map((cell) => `<th>${escapeHtml(cell)}</th>`).join('')}</tr></thead>`;
            const tbody = `<tbody>${body.map((row) => `<tr>${row.map((cell) => `<td>${escapeHtml(cell)}</td>`).join('')}</tr>`).join('')}</tbody>`;
            return `<table>${thead}${tbody}</table>`;
        };

        const normalizeTranscript = (text) => (typeof text === 'string' ? text.trim() : '');
        const extractTranscript = (payload) => {
            if (!payload) {
                return '';
            }
            if (typeof payload === 'string') {
                return payload;
            }
            if (Array.isArray(payload)) {
                return payload[0]?.Transcript || '';
            }
            if (typeof payload === 'object') {
                return payload.Transcript || '';
            }
            return '';
        };

        fileInput.addEventListener('change', async () => {
            const selectedFile = fileInput.files && fileInput.files[0];
            fileName.textContent = selectedFile ? selectedFile.name : '';
            markdownResult.textContent = 'Processing...';

            let stepsDone = 0;
            let stepsTotal = 0;
            const renderProgress = (label) => {
                const percent = stepsTotal > 0 ? Math.min(100, Math.round((stepsDone / stepsTotal) * 100)) : 0;
                progressFill.style.width = `${percent}%`;
                progressText.textContent = `Progress: ${stepsDone} / ${stepsTotal}`;
                progressLabel.textContent = label || 'Idle';
            };
            const addSteps = (count) => {
                stepsTotal += count;
                renderProgress(progressLabel.textContent);
            };
            const completeStep = (label) => {
                stepsDone += 1;
                renderProgress(label);
            };
            renderProgress('Waiting for file');

            if (!selectedFile) {
                console.log('[Stage] No file selected');
                return;
            }

            try {
                try {
                    console.log('[Stage] Base64 encoding started');
                    addSteps(1);
                    const arrayBuffer = await selectedFile.arrayBuffer();
                    const bytes = new Uint8Array(arrayBuffer);
                    let binary = '';
                    const chunkSize = 0x8000;

                    for (let i = 0; i < bytes.length; i += chunkSize) {
                        binary += String.fromCharCode(...bytes.subarray(i, i + chunkSize));
                    }

                    const base64 = btoa(binary);
                    const wrappedBase64 = base64.replace(/.{1,76}/g, (match) => `${match}\n`).trim();

                    console.log('Base64 encoding status: success');
                    console.log('Audio filename:', selectedFile.name);
                    completeStep('Base64 encoded');

                    let jobId = '';

                    try {
                        console.log('[Stage] Diarize request started');
                        addSteps(1);
                        const diarizeResponse = await fetch('http://100.67.135.103:5005/api/diarize', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                file: wrappedBase64,
                                filename: selectedFile.name
                            })
                        });

                        console.log('[Stage] Diarize response received');
                        const diarizePayload = await diarizeResponse.json();

                        if (diarizePayload && diarizePayload.success === false) {
                            console.log(`Error: ${diarizePayload.error || 'Unknown error'}`);
                            return;
                        } else {
                            jobId = diarizePayload?.job_id || '';
                            console.log(jobId);
                            if (!jobId) {
                                return;
                            }
                        }
                        completeStep('Diarize request completed');
                    } catch (diarizeError) {
                        console.log(`Error: ${diarizeError?.message || 'Request failed'}`);
                        return;
                    }

                    const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
                    let diarizeResult = 'pending';
                    const maxPolls = 120;
                    let pollsUsed = 0;
                    addSteps(maxPolls);

                    for (let attempt = 0; attempt < maxPolls; attempt += 1) {
                        try {
                            console.log(`[Stage] Status poll attempt ${attempt + 1}/120`);
                            const statusResponse = await fetch(
                                `http://100.67.135.103:5005/api/diarize/${encodeURIComponent(jobId)}/status`
                            );
                            const statusPayload = await statusResponse.json();
                            const status = statusPayload?.status;

                            if (status === 'completed') {
                                diarizeResult = 'completed';
                                break;
                            }

                            if (status === 'failed') {
                                const errorMessage = statusPayload?.error || 'Unknown error';
                                diarizeResult = `failed|${errorMessage}`;
                                break;
                            }

                            if (status === 'processing') {
                                diarizeResult = 'processing';
                            } else {
                                diarizeResult = 'pending';
                            }
                        } catch (statusError) {
                            diarizeResult = `failed|${statusError?.message || 'Request failed'}`;
                            break;
                        }

                        pollsUsed = attempt + 1;
                        completeStep(`Status poll ${attempt + 1}/${maxPolls}`);
                        await sleep(10000);
                    }

                    console.log(`diarize result: ${diarizeResult}`);
                    if (pollsUsed < maxPolls) {
                        stepsTotal -= (maxPolls - pollsUsed);
                        renderProgress('Diarize status completed');
                    }

                    if (diarizeResult === 'completed') {
                        try {
                            console.log('[Stage] Formatted dialogue request started');
                            addSteps(1);
                            const formattedResponse = await fetch(
                                `http://100.67.135.103:5005/api/diarize/${encodeURIComponent(jobId)}/formatted`
                            );
                            console.log('[Stage] Formatted dialogue response received');
                            const formattedPayload = await formattedResponse.json();
                            const formattedDialogue = formattedPayload?.formatted_dialogue || '';
                            console.log('formatted_dialogue:', formattedDialogue);
                            const dialogueWithRoles = formattedDialogue
                                .split(/\r?\n/)
                                .map((line) => line.trim())
                                .filter((line) => line.length > 0);
                            console.log('dialogue with roles count:', dialogueWithRoles.length);
                            completeStep('Formatted dialogue received');

                            const promptTemplate = `You are an expert in analyzing call center dialogues.\n\n<system_context>\nYou are a Dialogue Filter & Quality Tagger.\nYour task is to extract valid speech from raw audio transcripts, tag the speaker role, and MARK low-quality segments.\n</system_context>\n\n<role_definitions>\nAGENT: Tech support (gives instructions, checks status).\nCLIENT: Customer (reports problem, confirms actions).\n</role_definitions>\n\n<system_context>\nYou are an Audio Mixing Intelligence.\nYou receive a RAW MIXED TIMELINE containing all transcription segments from two separated channels (Agent & Client).\nYour job is to DEDUPLICATE audio leakage (ghosts) and produce a clean, chronological JSON transcript.\n</system_context>\n\n<core_input_logic>\nYou are looking at a list \`mixed_timeline\`. It is sorted by time.\nIn moments of overlap, you will see multiple items with the same timestamp.\n\nPROBLEM: \"Audio Leakage\"\nSince channels were separated by AI, the Agent's channel often contains a faint echo of the Client, and vice-versa.\nThese echoes are often marked with \`[UNCLEAR]\` or contain identical text to the other speaker.\n</core_input_logic>\n\n<filtering_rules>\nFor any group of items occurring at the SAME TIME (Â±1 second):\n\n1. **Rule: The Mirror Test (Killing Ghosts)**\n   - IF Speaker A says \"X\" AND Speaker B says \"X\" (or \"[UNCLEAR] X\") at the same time:\n   - THEN keep the version that is CLEANER (no \`[UNCLEAR]\`) or fits the role better.\n   - DELETE the echo.\n\n2. **Rule: True Overlap (Preserving Arguments)**\n   - IF Speaker A says \"Please wait\" AND Speaker B says \"I will not!\" at the same time:\n   - AND both texts are distinct and meaningful:\n   - THEN KEEP BOTH. Do NOT merge them. Do NOT delete the second one.\n   - Output them as separate objects with the same timestamp.\n\n3. **Rule: Hallucination Check**\n   - IF a line is \`[UNCLEAR]\` AND contains aggressive/nonsense text (\"kill\", \"tube\", \"mbc\") AND has no matching real speech in the other channel:\n   - DELETE IT.\n\n4. **Rule: Clean up**\n   - If a line is kept but has \`[UNCLEAR]\`, remove the tag in the final output.\n</filtering_rules>\n\n<agent_characteristics>\n- Leads the call and gives instructions or advice (\"Try to reset your modem\", \"Power it off and on\").\n- Asks diagnostic questions (\"What speed does it show?\", \"Did you try restarting?\").\n- Guides the client step-by-step and confirms actions (\"Please check the cable\", \"Let me know when done\").\n- Uses professional tone, problem-solving language, and directive phrasing.\n</agent_characteristics>\n\n<client_characteristics>\n- Describes issues, complaints, or symptoms (\"My internet keeps dropping\").\n- Responds to agent requests and performs actions (\"One second\", \"I tried that\").\n- Asks for help or confirmation (\"What should I do?\", \"Is that correct?\").\n- Follows instructions; acknowledges results or lack of improvement.\n</client_characteristics>\n\n<agent_examples>\n1. \"Please restart your modem.\"\n2. \"What speed does it show now?\"\n3. \"Try to power off the modem and power it on again.\"\n4. \"Can you check the cable connection?\"\n5. \"Please open the admin panel and enter the IP address.\"\n6. \"I will guide you step by step.\"\n7. \"Did you try resetting your router?\"\n8. \"Let me know when you are done.\"\n9. \"Please confirm the lights are stable.\"\n10. \"Try that again and tell me the result.\"\n</agent_examples>\n\n<client_examples>\n1. \"My internet keeps dropping.\"\n2. \"It is still not working.\"\n3. \"One second, I am checking.\"\n4. \"I tried that, but it didn't help.\"\n5. \"I can't open the admin panel.\"\n6. \"What should I do?\"\n7. \"Okay, I restarted it.\"\n8. \"Yes, I see 200 now.\"\n9. \"I'm supposed to watch a movie without the problem.\"\n10. \"Is that correct?\"\n</client_examples>\n\n<hard_rules>\n- The phrase "Try also to..." is ALWAYS Agent.\n- Instructional or guiding sentences (advice, commands, setup steps, "try", "check", "enter", "connect", "configure", "you can") are Agent, even if phrased politely.\n</hard_rules>\n\nCONTEXT:\nYou are analyzing a dialogue from a call center. The dialogue below is provided as REFERENCE ONLY.\nIMPORTANT: This dialogue may contain transcription errors and missing phrases due to speaker overlaps.\nUse it only as context to understand the conversation flow, but focus on the SPECIFIC REPLICA you need to analyze.\n\nFULL DIALOGUE (for context only):\nformatted_dialogue\n\nSPECIFIC REPLICA TO ANALYZE:\nRepeat Item 2\n\nTASK:\n1. Parse the replica line in format: \"MM:SS Speaker X: [text]\"\n2. Extract the timestamp (MM:SS format)\n3. Extract the speaker label (Speaker 0 or Speaker 1)\n4. Extract the text content\n5. Analyze the text content in the context of the full dialogue to determine the role using the role definitions, filtering rules, characteristics, and examples above\n6. Replace 'Speaker 0' or 'Speaker 1' with 'Agent' or 'Client' based on your analysis\n7. Return ONLY the modified line in the same single-line format:\n   \n   Format: MM:SS [role]: [text]\n\nIMPORTANT:\n- Keep the exact same single-line format: \"MM:SS [role]: [text]\"\n- Use 'Agent' for call center employees\n- Use 'Client' for customers\n- Consider the full dialogue context, but analyze based on the specific replica's content\n- Account for possible transcription errors or overlaps - focus on the meaning and intent\n- Return ONLY the modified line, nothing else\n- Do NOT add empty lines or extra formatting\n`;

                            const updatedDialogueLines = [];
                            addSteps(dialogueWithRoles.length);

                            for (let index = 0; index < dialogueWithRoles.length; index += 1) {
                                const replicaLine = dialogueWithRoles[index];
                                const prompt = promptTemplate
                                    .replace('formatted_dialogue', formattedDialogue)
                                    .replace('Repeat Item 2', replicaLine);

                                try {
                                    console.log(`[Stage] LLM request started: ${index + 1}/${dialogueWithRoles.length}`);
                                    const llmResponse = await fetch('/api/llm/chat-completions-local', {
                                        method: 'POST',
                                        headers: {
                                            'Content-Type': 'application/json'
                                        },
                                        body: JSON.stringify({
                                            messages: [{ role: 'user', content: prompt }]
                                        })
                                    });
                                    console.log(`[Stage] LLM response received: ${index + 1}/${dialogueWithRoles.length}`);
                                    const llmPayload = await llmResponse.json();
                                    logLlmModel(llmPayload, 'Replica LLM');
                                    const llmOutput = llmPayload?.choices?.[0]?.message?.content || '';
                                    const llmResult = llmOutput.trim();
                                    updatedDialogueLines.push(llmResult);
                                    console.log(`[Stage] LLM result: ${index + 1}/${dialogueWithRoles.length}`, llmResult);
                                    console.log(`Processed ${index + 1} of ${dialogueWithRoles.length}`);
                                    completeStep(`Replica LLM ${index + 1}/${dialogueWithRoles.length}`);
                                } catch (llmError) {
                                    console.log(`[Stage] LLM error: ${index + 1}/${dialogueWithRoles.length}`, llmError);
                                    console.log(`Processed ${index + 1} of ${dialogueWithRoles.length}`);
                                    completeStep(`Replica LLM ${index + 1}/${dialogueWithRoles.length}`);
                                }
                            }

                            const updatedDialogue = updatedDialogueLines.join('\n');
                            console.log('initial dialogue 1:', updatedDialogue);

                            const escapePipes = (value) => value.replace(/\|/g, '\\|');
                            const markdownRows = updatedDialogue
                                .split(/\r?\n/)
                                .map((line) => line.trim())
                                .filter((line) => line.length > 0)
                                .map((line) => {
                                    const match = line.match(/^(\d{2}:\d{2})\s+([^:]+):\s*(.*)$/);
                                    if (!match) {
                                        return null;
                                    }
                                    const [, time, role, text] = match;
                                    return `| ${escapePipes(time)} | ${escapePipes(role.trim())} | ${escapePipes(text.trim())} |`;
                                })
                                .filter(Boolean);

                            const markdownTable = [
                                '| Time | Role | Text |',
                                '| --- | --- | --- |',
                                ...markdownRows
                            ].join('\n');

                            console.log('[Stage] Single-speaker split started');
                            addSteps(1);

                            try {
                                const splitFormData = new FormData();
                                splitFormData.append('audio', selectedFile);

                                const splitResponse = await fetch('http://localhost:5005/api/separate-audio', {
                                    method: 'POST',
                                    body: splitFormData
                                });

                                const splitPayload = await splitResponse.json();
                                const file1Url = splitPayload?.file1 || '';
                                const file2Url = splitPayload?.file2 || '';
                                console.log('file1:', file1Url);
                                console.log('file2:', file2Url);
                                completeStep('Audio split completed');

                                const sendForTranscription = async (fileUrl, label) => {
                                    if (!fileUrl) {
                                        console.log(`[Stage] ${label} upload skipped (missing URL)`);
                                        return '';
                                    }

                                    addSteps(1);
                                    console.log(`[Stage] ${label} upload started`);
                                    const fileResponse = await fetch(fileUrl);
                                    const fileBlob = await fileResponse.blob();
                                    const uploadFormData = new FormData();
                                    uploadFormData.append('audio', fileBlob, 'audio.wav');

                                    const uploadResponse = await fetch('http://localhost:5005/api/diarize-and-transcribe', {
                                        method: 'POST',
                                        body: uploadFormData
                                    });

                                    console.log(`[Stage] ${label} upload completed (status ${uploadResponse.status})`);
                                    const transcriptText = await uploadResponse.text();
                                    console.log(`${label}:`, transcriptText);
                                    completeStep(`${label} transcript ready`);
                                    return transcriptText;
                                };

                                try {
                                    const file1Transcript = await sendForTranscription(file1Url, 'File1Transcript');
                                    const file2Transcript = await sendForTranscription(file2Url, 'File2Transcript');

                                    console.log('[Stage] Final webhook request started');
                                    addSteps(1);
                                    const finalResponse = await fetch('http://localhost:5678/webhook/diarization-send', {
                                        method: 'POST',
                                        headers: {
                                            'Content-Type': 'application/json'
                                        },
                                        body: JSON.stringify({
                                            File1Transcript: file1Transcript,
                                            File2Transcript: file2Transcript,
                                            OriginalDialogue1: updatedDialogue
                                        })
                                    });
                                    console.log('[Stage] Final webhook response received');
                                    console.log('[Stage] Final webhook status:', finalResponse.status);
                                    const finalResponseText = await finalResponse.text();
                                    const responsePreview = finalResponseText && finalResponseText.trim().length > 0
                                        ? finalResponseText
                                        : '<empty>';
                                    console.log('Final webhook response:', responsePreview);
                                    let webhookMarkdown = '';

                                    try {
                                        const parsedResponse = JSON.parse(finalResponseText);
                                        const responseItem = Array.isArray(parsedResponse) ? parsedResponse[0] : parsedResponse;
                                        const responseText = responseItem?.text || '';
                                        webhookMarkdown = responseText.replace(/```markdown|```/g, '').trim();
                                    } catch (parseError) {
                                        const fencedMatch = finalResponseText.match(/```markdown([\s\S]*?)```/i);
                                        if (fencedMatch) {
                                            webhookMarkdown = fencedMatch[1].trim();
                                        } else {
                                            const tableMatch = finalResponseText.match(/(\|[^\n]*\|\n\|[-:\s|]+\|\n[\s\S]*)/);
                                            webhookMarkdown = tableMatch ? tableMatch[1].trim() : '';
                                        }
                                    }

                                    console.log('[Stage] Webhook markdown length:', webhookMarkdown.length);

                                    addSteps(1);
                                    if (webhookMarkdown) {
                                        markdownResult.innerHTML = renderMarkdownTable(webhookMarkdown);
                                    } else {
                                        markdownResult.innerHTML = '<div>No webhook table received.</div>';
                                    }
                                    completeStep('Markdown table rendered');
                                    completeStep('Final webhook response received');
                                } catch (transcriptError) {
                                    console.log(`Error: ${transcriptError?.message || 'Request failed'}`);
                                }
                            } catch (splitError) {
                                console.log(`Error: ${splitError?.message || 'Request failed'}`);
                            }
                        } catch (formattedError) {
                            console.log(`Error: ${formattedError?.message || 'Request failed'}`);
                        }
                    }
                } catch (encodeError) {
                    console.error('Base64 encoding status: failed', encodeError);
                }
            } catch (error) {
                console.error('[Webhook error]', error);
            }
        });
    </script>
</body>
</html>
