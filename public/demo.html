<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Diarization Demo</title>
  <link rel="stylesheet" href="/styles.css">
  <style>
    /* Tooltip Styles */
    .tooltip-trigger {
      position: relative;
      display: inline-block;
    }
    
    .tooltip-trigger .tooltip-content {
      position: absolute;
      left: 50%;
      bottom: 100%;
      transform: translateX(-50%);
      margin-bottom: 8px;
      padding: 12px 16px;
      background: #2c3e50;
      color: #fff;
      font-size: 12px;
      line-height: 1.5;
      white-space: pre-line;
      border-radius: 6px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      z-index: 99999;
      min-width: 280px;
      max-width: 400px;
      pointer-events: auto;
      font-weight: normal;
      text-align: left;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.2s ease-in-out, visibility 0.2s ease-in-out;
    }
    
    .tooltip-trigger .tooltip-content::after {
      content: '';
      position: absolute;
      left: 50%;
      top: 100%;
      transform: translateX(-50%);
      margin-top: -1px;
      border: 6px solid transparent;
      border-top-color: #2c3e50;
      pointer-events: none;
    }
    
    .tooltip-trigger:hover .tooltip-content,
    .tooltip-trigger .tooltip-content:hover {
      opacity: 1;
      visibility: visible;
    }
    
    /* Alternative positioning for elements near top */
    .tooltip-trigger.tooltip-bottom .tooltip-content {
      bottom: auto;
      top: 100%;
      margin-bottom: 0;
      margin-top: 8px;
    }
    
    .tooltip-trigger.tooltip-bottom .tooltip-content::after {
      top: auto;
      bottom: 100%;
      border-top-color: transparent;
      border-bottom-color: #2c3e50;
      margin-top: 0;
      margin-bottom: -1px;
    }
    
    /* Right side positioning */
    .tooltip-trigger.tooltip-right .tooltip-content {
      left: auto;
      right: 0;
      transform: none;
    }
    
    .tooltip-trigger.tooltip-right .tooltip-content::after {
      left: auto;
      right: 20px;
      transform: none;
    }
    /* Animation for LLM-generated config */
    @keyframes fadeInScale {
      from {
        opacity: 0;
        transform: scale(0.95);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Audio Diarization Demo</h1>
    
    <form id="diarizationForm" class="demo-form">
      <div class="form-group">
        <label for="audioFile">Audio File:</label>
        <div style="display: flex; align-items: center; gap: 12px; width: 100%;">
          <input type="file" id="audioFile" name="audio" accept="audio/*" required style="flex: 1; min-width: 0;">
          <button type="button" class="btn btn-primary" onclick="loadLastFile()" style="padding: 8px 16px; font-size: 14px; border-radius: 6px; background: #16a085; color: white; border: none; cursor: pointer; font-weight: 600; white-space: nowrap; flex-shrink: 0;">
            üìÇ Open Last File
          </button>
          <button type="button" class="btn btn-primary debug" onclick="showSeparationDebugModal()" style="padding: 8px 16px; font-size: 14px; border-radius: 6px; background: #3498db; color: white; border: none; cursor: pointer; font-weight: 600; white-space: nowrap; flex-shrink: 0; position: relative;">
            üîÄ Debug Separation Logic
          </button>
        </div>
      </div>
      
      <div class="form-group">
        <label for="language">Language:</label>
        <select id="language" name="language" required>
          <option value="ar">Arabic</option>
          <option value="en" selected>English</option>
        </select>
      </div>
      
      <div class="form-group">
        <button type="submit" id="submitBtn" class="submit-btn">
          <span class="btn-text">Process Audio</span>
          <span class="spinner" id="spinner" style="display: none;"></span>
        </button>
      </div>
      
      <div id="errorMessage" class="error-label" style="display: none;"></div>
    </form>
    
    <!-- Progress Section -->
    <div id="progressSection" class="progress-section" style="display: none;">
      <h2>Processing Progress</h2>
      <div id="progressSteps" class="progress-steps"></div>
    </div>
    
    <!-- Results Section -->
    <div id="resultsContainer" class="results-container" style="display: none;">
      <h2>Results</h2>
      <div class="legend" style="display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 15px; margin-bottom: 20px;">
        <label for="loadDialogueInput" class="btn btn-primary" style="padding: 8px 16px; font-size: 14px; border-radius: 6px; background: #9b59b6; color: white; border: none; cursor: pointer; font-weight: 600; margin: 0;">
          üìÅ Load Dialogue
          <input type="file" id="loadDialogueInput" accept=".txt,.md,.json" style="display: none;" onchange="loadDialogueFile(event)">
        </label>
        <div class="debug-zone debug" style="display: flex; align-items: center; gap: 10px; padding: 8px 16px; background: #f8f9fa; border-radius: 6px; border: 1px solid #e0e0e0;">
          <span class="debug" style="font-weight: 600; color: #2c3e50; margin-right: 5px;">Debug Zone:</span>
          <button id="generatorBtn" class="btn btn-primary" style="padding: 8px 16px; font-size: 14px; border-radius: 6px; background: #e67e22; color: white; border: none; cursor: pointer; font-weight: 600;" onclick="showGeneratorModal()">
            ‚ö° Open Generator
          </button>
          <div class="debug" style="position: relative; display: inline-block;">
            <button id="debugBtn" class="btn btn-primary debug" style="padding: 8px 16px; font-size: 14px; border-radius: 6px; background: #3498db; color: white; border: none; cursor: pointer; font-weight: 600; position: relative;" onclick="toggleDebugMenu(event)">
          üêõ Debug
              <span style="margin-left: 5px;">‚ñº</span>
        </button>
            <div id="debugMenu" class="debug" style="display: none; position: absolute; top: 100%; left: 0; margin-top: 5px; background: white; border: 1px solid #e0e0e0; border-radius: 6px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); z-index: 1000; min-width: 180px;">
              <button class="debug-menu-item debug" style="display: block; width: 100%; padding: 10px 16px; text-align: left; background: none; border: none; cursor: pointer; font-size: 14px; color: #2c3e50; border-bottom: 1px solid #f0f0f0; transition: background-color 0.2s;" onmouseover="this.style.backgroundColor='#f8f9fa'" onmouseout="this.style.backgroundColor='transparent'" onclick="showSpeechmaticsRecognitionModal(); closeDebugMenu();">
                üé§ Speechmatics Recognition
              </button>
              <button class="debug-menu-item debug" style="display: block; width: 100%; padding: 10px 16px; text-align: left; background: none; border: none; cursor: pointer; font-size: 14px; color: #2c3e50; border-bottom: 1px solid #f0f0f0; transition: background-color 0.2s;" onmouseover="this.style.backgroundColor='#f8f9fa'" onmouseout="this.style.backgroundColor='transparent'" onclick="showDebugModal(); closeDebugMenu();">
                üß† Analyze Dialogue
              </button>
              <button class="debug-menu-item debug" style="display: block; width: 100%; padding: 10px 16px; text-align: left; background: none; border: none; cursor: pointer; font-size: 14px; color: #2c3e50; border-bottom: 1px solid #f0f0f0; transition: background-color 0.2s;" onmouseover="this.style.backgroundColor='#f8f9fa'" onmouseout="this.style.backgroundColor='transparent'" onclick="showMultimodalDiarizationModal(); closeDebugMenu();">
                üéôÔ∏è Analyze Multimodal Diarization
              </button>
              <button class="debug-menu-item debug" style="display: block; width: 100%; padding: 10px 16px; text-align: left; background: none; border: none; cursor: pointer; font-size: 14px; color: #2c3e50; border-bottom: 1px solid #f0f0f0; transition: background-color 0.2s;" onmouseover="this.style.backgroundColor='#f8f9fa'" onmouseout="this.style.backgroundColor='transparent'" onclick="showSeparationDebugModal(); closeDebugMenu();">
                üîÄ Debug Separation Logic
              </button>
              <div style="border-top: 1px solid #e0e0e0; margin-top: 4px; padding-top: 4px;">
                <div style="padding: 8px 16px; font-size: 12px; font-weight: 600; color: #7f8c8d; text-transform: uppercase; letter-spacing: 0.5px;">Global Variables</div>
                <button class="debug-menu-item debug" style="display: block; width: 100%; padding: 10px 16px; text-align: left; background: none; border: none; cursor: pointer; font-size: 14px; color: #2c3e50; border-bottom: 1px solid #f0f0f0; transition: background-color 0.2s;" onmouseover="this.style.backgroundColor='#f8f9fa'" onmouseout="this.style.backgroundColor='transparent'" onclick="showGlobalVariablesModal(); closeDebugMenu();">
                  üìä Current Table
                </button>
              </div>
              <button id="clearCacheBtn" class="debug-menu-item debug" style="display: block; width: 100%; padding: 10px 16px; text-align: left; background: none; border: none; cursor: pointer; font-size: 14px; color: #2c3e50; border-bottom: 1px solid #f0f0f0; transition: background-color 0.2s;" onmouseover="this.style.backgroundColor='#f8f9fa'" onmouseout="this.style.backgroundColor='transparent'" onclick="clearLLMCache(); closeDebugMenu();">
          üóëÔ∏è Clear Cache
        </button>
              <button class="debug-menu-item debug" style="display: block; width: 100%; padding: 10px 16px; text-align: left; background: none; border: none; cursor: pointer; font-size: 14px; color: #2c3e50; transition: background-color 0.2s;" onmouseover="this.style.backgroundColor='#f8f9fa'" onmouseout="this.style.backgroundColor='transparent'" onclick="saveLLMCache(); closeDebugMenu();">
          üíæ Save Cache
        </button>
            </div>
          </div>
        </div>
      </div>
      <!-- Results Table -->
      <div id="resultsInfo" class="results-info"></div>
    </div>
  </div>
  
  <!-- Generator Modal -->
  <div id="generatorModal" class="debug-modal" style="display: none;" onclick="if(event.target === this) closeGeneratorModal()">
    <div class="debug-modal-content" onclick="event.stopPropagation()" style="max-width: 800px;">
      <div class="debug-modal-header">
        <h2>‚ö° Generator</h2>
        <button aria-label="Close" class="debug-modal-close" onclick="closeGeneratorModal()">‚úï</button>
      </div>
      <div class="debug-modal-body" style="padding: 0; overflow: auto; max-height: 80vh;">
        <div id="generatorContent" style="width: 100%; min-height: 600px;">
          <!-- Generator content will be loaded here -->
        </div>
      </div>
    </div>
  </div>
  
  <!-- Debug Modal -->
  <div id="debugModal" class="debug-modal debug" style="display: none;" onclick="if(event.target === this) closeDebugModal()">
    <div class="debug-modal-content debug" onclick="event.stopPropagation()" style="max-width: 800px;">
      <div class="debug-modal-header debug">
        <h2 class="debug">üß† Analyze Dialogue</h2>
        <button class="debug-modal-close debug" onclick="closeDebugModal()">&times;</button>
      </div>
      <div class="debug-modal-body debug">
        <div style="margin-bottom: 15px;">
          <label for="groundTruthTextarea" style="display: block; margin-bottom: 5px; font-weight: 600; color: #333;">Input:</label>
          <textarea id="groundTruthTextarea" class="debug" style="width: 100%; height: 400px; font-family: monospace; font-size: 12px; padding: 10px; border: 1px solid #ddd; border-radius: 4px; resize: vertical;"></textarea>
        </div>
      </div>
      <div class="debug-modal-footer debug">
        <label for="loadGroundTruthInput" class="btn btn-primary debug" style="padding: 8px 16px; font-size: 14px; border-radius: 6px; background: #9b59b6; color: white; border: none; cursor: pointer; font-weight: 600; margin-right: 10px;">
          üìÅ Load Ground Truth
          <input type="file" id="loadGroundTruthInput" accept=".txt,.md,.json" style="display: none;" onchange="loadGroundTruthFile(event)">
        </label>
        <button class="btn btn-primary debug" id="runBtn" onclick="runDebugActionNew()" style="padding: 8px 16px; font-size: 14px; border-radius: 6px; background: #f39c12; color: white; border: none; cursor: pointer; font-weight: 600; margin-right: 10px;">
          ‚ñ∂Ô∏è Run
        </button>
        <button class="btn btn-primary debug" id="applyBtn" onclick="applyOriginalReplicas()" style="padding: 8px 16px; font-size: 14px; border-radius: 6px; background: #27ae60; color: white; border: none; cursor: pointer; font-weight: 600; margin-right: 10px;">
          ‚úÖ Apply
        </button>
        <button class="btn btn-primary debug" id="markWithColorBtn" onclick="markWithColor()" style="padding: 8px 16px; font-size: 14px; border-radius: 6px; background: #3498db; color: white; border: none; cursor: pointer; font-weight: 600; margin-right: 10px;">
          üé® Mark with a color
        </button>
        <button class="btn btn-primary debug" id="copyLogsBtn" onclick="copyLogsToClipboard()" style="padding: 8px 16px; font-size: 14px; border-radius: 6px; background: #16a085; color: white; border: none; cursor: pointer; font-weight: 600; margin-right: 10px;">
          üìã Copy Logs
        </button>
        <button class="btn btn-secondary debug" onclick="closeDebugModal()" style="padding: 8px 16px; font-size: 14px; border-radius: 6px; background: #95a5a6; color: white; border: none; cursor: pointer; font-weight: 600;">
          Close
        </button>
      </div>
    </div>
  </div>
  
  <!-- Speechmatics Recognition Modal -->
  <div id="speechmaticsModal" class="debug-modal debug" style="display: none;" onclick="if(event.target === this) closeSpeechmaticsModal()">
    <div class="debug-modal-content debug" onclick="event.stopPropagation()" style="max-width: 800px;">
      <div class="debug-modal-header debug">
        <h2 class="debug">üé§ Speechmatics Recognition</h2>
        <button class="debug-modal-close debug" onclick="closeSpeechmaticsModal()">&times;</button>
      </div>
      <div class="debug-modal-body debug">
        <div style="margin-bottom: 15px;">
          <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #333;">Audio File:</label>
          <input type="file" id="speechmaticsAudioFile" accept="audio/*" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
          <div id="speechmaticsFileInfo" style="margin-top: 5px; font-size: 12px; color: #666; font-style: italic;">
            No file selected
          </div>
        </div>
        <div style="margin-bottom: 15px;">
          <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #333;">Status:</label>
          <div id="speechmaticsStatus" style="padding: 10px; background: #f8f9fa; border-radius: 4px; font-family: monospace; font-size: 12px;">
            Please select an audio file
          </div>
        </div>
        <div style="margin-bottom: 15px;">
          <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #333;">Result:</label>
          <textarea id="speechmaticsResult" class="debug" readonly style="width: 100%; height: 400px; font-family: monospace; font-size: 12px; padding: 10px; border: 1px solid #ddd; border-radius: 4px; resize: vertical;"></textarea>
        </div>
      </div>
      <div class="debug-modal-footer debug">
        <button class="btn btn-primary debug" id="runSpeechmaticsBtn" onclick="runSpeechmaticsRecognition()" style="padding: 8px 16px; font-size: 14px; border-radius: 6px; background: #3498db; color: white; border: none; cursor: pointer; font-weight: 600;">
          ‚ñ∂Ô∏è Run Speechmatics Recognition
        </button>
        <button class="btn btn-primary debug" onclick="closeSpeechmaticsModal()" style="padding: 8px 16px; font-size: 14px; border-radius: 6px; background: #95a5a6; color: white; border: none; cursor: pointer; font-weight: 600; margin-left: 10px;">
          Close
        </button>
      </div>
    </div>
  </div>
  
  <!-- Multimodal Diarization Modal -->
  <div id="multimodalModal" class="debug-modal debug" style="display: none;" onclick="if(event.target === this) closeMultimodalModal()">
    <div class="debug-modal-content debug" onclick="event.stopPropagation()" style="max-width: 800px;">
      <div class="debug-modal-header debug">
        <h2 class="debug">üéôÔ∏è Multimodal Diarization</h2>
        <button class="debug-modal-close debug" onclick="closeMultimodalModal()">&times;</button>
      </div>
      <div class="debug-modal-body debug">
        <div style="margin-bottom: 15px;">
          <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #333;">Audio File:</label>
          <input type="file" id="multimodalAudioFile" accept="audio/*" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
          <div id="multimodalFileInfo" style="margin-top: 5px; font-size: 12px; color: #666; font-style: italic;">
            No file selected
          </div>
        </div>
        <div style="margin-bottom: 15px;">
          <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #333;">Status:</label>
          <div id="multimodalStatus" style="padding: 10px; background: #f8f9fa; border-radius: 4px; font-family: monospace; font-size: 12px;">
            Please select an audio file
          </div>
        </div>
            <div style="margin-bottom: 15px;">
              <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #333;">Result:</label>
              <textarea id="multimodalResult" class="debug" readonly style="width: 100%; height: 400px; font-family: monospace; font-size: 12px; padding: 10px; border: 1px solid #ddd; border-radius: 4px; resize: vertical;"></textarea>
            </div>
            <div style="margin-bottom: 15px;">
              <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #333;">Merged Dialogue:</label>
              <textarea id="multimodalDialogue" class="debug" readonly style="width: 100%; height: 300px; font-family: monospace; font-size: 12px; padding: 10px; border: 1px solid #ddd; border-radius: 4px; resize: vertical;"></textarea>
            </div>
      </div>
      <div class="debug-modal-footer debug">
        <button class="btn btn-primary debug" id="runMultimodalBtn" onclick="runMultimodalDiarization()" style="padding: 8px 16px; font-size: 14px; border-radius: 6px; background: #9b59b6; color: white; border: none; cursor: pointer; font-weight: 600;">
          ‚ñ∂Ô∏è Run Multimodal Analysis
        </button>
        <button class="btn btn-primary debug" onclick="applyMultimodalResults()" style="padding: 8px 16px; font-size: 14px; border-radius: 6px; background: #2ecc71; color: white; border: none; cursor: pointer; font-weight: 600; margin-left: 10px;">
          ‚úÖ Apply
        </button>
        <button class="btn btn-primary debug" onclick="copyMultimodalResult()" style="padding: 8px 16px; font-size: 14px; border-radius: 6px; background: #27ae60; color: white; border: none; cursor: pointer; font-weight: 600; margin-left: 10px;">
          üìã Copy Result
        </button>
        <button class="btn btn-secondary debug" onclick="closeMultimodalModal()" style="padding: 8px 16px; font-size: 14px; border-radius: 6px; background: #95a5a6; color: white; border: none; cursor: pointer; font-weight: 600; margin-left: 10px;">
          Close
        </button>
      </div>
    </div>
  </div>
  
  <!-- Audio File Upload Modal for Multimodal Processing -->
  <div id="audioUploadModal" class="debug-modal debug" style="display: none;" onclick="if(event.target === this) closeAudioUploadModal()">
    <div class="debug-modal-content debug" onclick="event.stopPropagation()" style="max-width: 600px;">
      <div class="debug-modal-header debug">
        <h2 class="debug">üìÅ Upload Audio File</h2>
        <button class="debug-modal-close debug" onclick="closeAudioUploadModal()">&times;</button>
      </div>
      <div class="debug-modal-body debug">
        <div style="margin-bottom: 15px;">
          <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #333;">Audio File:</label>
          <input type="file" id="audioUploadFileInput" accept="audio/*" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
          <div id="audioUploadFileInfo" style="margin-top: 5px; font-size: 12px; color: #666; font-style: italic;">
            No file selected
          </div>
        </div>
        <div style="margin-bottom: 15px;">
          <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #333;">Status:</label>
          <div id="audioUploadStatus" style="padding: 10px; background: #f8f9fa; border-radius: 4px; font-family: monospace; font-size: 12px;">
            Please select an audio file
          </div>
        </div>
      </div>
      <div class="debug-modal-footer debug">
        <button class="btn btn-primary debug" id="saveAudioFileBtn" onclick="saveAudioFileForMultimodal()" style="padding: 8px 16px; font-size: 14px; border-radius: 6px; background: #3498db; color: white; border: none; cursor: pointer; font-weight: 600;">
          üíæ Save & Continue
        </button>
        <button class="btn btn-secondary debug" onclick="closeAudioUploadModal()" style="padding: 8px 16px; font-size: 14px; border-radius: 6px; background: #95a5a6; color: white; border: none; cursor: pointer; font-weight: 600; margin-left: 10px;">
          Cancel
        </button>
      </div>
    </div>
  </div>
  
  <!-- Separation Debug Modal -->
  <div id="separationDebugModal" class="debug-modal debug" style="display: none;" onclick="if(event.target === this) closeSeparationDebugModal()">
    <div class="debug-modal-content debug" onclick="event.stopPropagation()" style="max-width: 1200px; max-height: 90vh; overflow-y: auto;">
      <div class="debug-modal-header debug">
        <h2 class="debug">üîÄ Debug Separation Logic</h2>
        <button class="debug-modal-close debug" onclick="closeSeparationDebugModal()">&times;</button>
      </div>
      <div class="debug-modal-body debug" style="padding: 20px;">
        <!-- File Upload Section -->
        <div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 6px; border: 1px solid #e0e0e0;">
          <label style="display: block; margin-bottom: 10px; font-weight: 600; color: #333; font-size: 16px;">üìÅ –ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –∞—É–¥—ñ–æ —Ñ–∞–π–ª:</label>
          <input type="file" id="separationDebugAudioFile" accept="audio/*" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; margin-bottom: 10px;">
          <div id="separationDebugFileInfo" style="font-size: 12px; color: #666; font-style: italic;">
            –§–∞–π–ª –Ω–µ –≤–∏–±—Ä–∞–Ω–æ
          </div>
        </div>
        
        <!-- Settings Section -->
        <div style="margin-bottom: 20px; padding: 15px; background: #fff3cd; border-radius: 6px; border: 2px solid #ffc107;">
          <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px;">
            <label style="font-weight: 600; color: #333; font-size: 16px;">‚öôÔ∏è –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è —Ä–æ–∑–¥—ñ–ª–µ–Ω–Ω—è:</label>
            <div style="display: flex; align-items: center; gap: 10px;">
              <label style="display: flex; align-items: center; gap: 5px; font-size: 13px; font-weight: 600; color: #333; cursor: pointer;">
                <input type="checkbox" id="useCustomSettings" onchange="toggleCustomSettings()" style="width: 18px; height: 18px; cursor: pointer;">
                <span>–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ –∫–∞—Å—Ç–æ–º–Ω—ñ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è</span>
              </label>
              <button type="button" onclick="toggleSeparationSettings()" style="padding: 4px 12px; font-size: 12px; border-radius: 4px; background: #ffc107; color: #333; border: 1px solid #ff9800; cursor: pointer; font-weight: 600;">
                <span id="separationSettingsToggle">‚ñº</span> –†–æ–∑–≥–æ—Ä–Ω—É—Ç–∏
              </button>
            </div>
          </div>
          <div id="customSettingsStatus" style="font-size: 12px; font-weight: 600; margin-bottom: 10px; padding: 8px; background: #f8f9fa; border-radius: 4px; text-align: center;">
            üîí –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—é—Ç—å—Å—è –æ–ø—Ç–∏–º–∞–ª—å–Ω—ñ –∑–∞—Ö–∞—Ä–¥–∫–æ–¥–∂–µ–Ω—ñ –∑–Ω–∞—á–µ–Ω–Ω—è
          </div>
          <div id="separationSettingsPanel" style="display: none;">
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin-bottom: 15px;">
              <!-- Chunk Size -->
              <div style="position: relative;">
                <label for="separationChunkSeconds" style="display: flex; align-items: center; gap: 5px; margin-bottom: 5px; font-weight: 600; color: #333; font-size: 14px;">
                  üì¶ –†–æ–∑–º—ñ—Ä —Å–µ–≥–º–µ–Ω—Ç–∞ (—Å–µ–∫—É–Ω–¥–∏):
                  <span class="tooltip-trigger tooltip-bottom" style="cursor: help; color: #3498db; font-size: 16px; line-height: 1; position: relative;">
                    ‚ÑπÔ∏è
                    <span class="tooltip-content">–†–æ–∑–º—ñ—Ä —Å–µ–≥–º–µ–Ω—Ç–∞ –≤–∏–∑–Ω–∞—á–∞—î, –Ω–∞ —Å–∫—ñ–ª—å–∫–∏ —á–∞—Å—Ç–∏–Ω —Ä–æ–∑–±–∏–≤–∞—î—Ç—å—Å—è –∞—É–¥—ñ–æ –¥–ª—è –æ–±—Ä–æ–±–∫–∏.

–ù–∞ —â–æ –≤–ø–ª–∏–≤–∞—î:
‚Ä¢ –ú–µ–Ω—à–∏–π —Ä–æ–∑–º—ñ—Ä (5-15 —Å–µ–∫): –∫—Ä–∞—â–∞ —è–∫—ñ—Å—Ç—å –¥–ª—è –∫–æ—Ä–æ—Ç–∫–∏—Ö —Å–µ–≥–º–µ–Ω—Ç—ñ–≤, –º–µ–Ω—à–µ –∑–º—ñ—à—É–≤–∞–Ω–Ω—è —Å–ø—ñ–∫–µ—Ä—ñ–≤, –∞–ª–µ –ø–æ–≤—ñ–ª—å–Ω—ñ—à–∞ –æ–±—Ä–æ–±–∫–∞
‚Ä¢ –°–µ—Ä–µ–¥–Ω—ñ–π —Ä–æ–∑–º—ñ—Ä (20-30 —Å–µ–∫): –æ–ø—Ç–∏–º–∞–ª—å–Ω–∏–π –±–∞–ª–∞–Ω—Å –º—ñ–∂ —è–∫—ñ—Å—Ç—é —Ç–∞ —à–≤–∏–¥–∫—ñ—Å—Ç—é (—Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–æ)
‚Ä¢ –í–µ–ª–∏–∫–∏–π —Ä–æ–∑–º—ñ—Ä (40+ —Å–µ–∫): —à–≤–∏–¥—à–∞ –æ–±—Ä–æ–±–∫–∞, –∞–ª–µ –º–æ–∂–µ –±—É—Ç–∏ –≥—ñ—Ä—à–∞ —è–∫—ñ—Å—Ç—å —á–µ—Ä–µ–∑ –∑–º—ñ—à—É–≤–∞–Ω–Ω—è —Å–ø—ñ–∫–µ—Ä—ñ–≤ –Ω–∞ –¥–æ–≤–≥–∏—Ö —Å–µ–≥–º–µ–Ω—Ç–∞—Ö

–†–µ–∑—É–ª—å—Ç–∞—Ç –∑–º—ñ–Ω–∏:
‚Ä¢ –ó–º–µ–Ω—à–µ–Ω–Ω—è ‚Üí –∫—Ä–∞—â–∞ —è–∫—ñ—Å—Ç—å —Ä–æ–∑–¥—ñ–ª–µ–Ω–Ω—è, –º–µ–Ω—à–µ –∑–∞–ª–∏—à–∫—ñ–≤ —ñ–Ω—à–æ–≥–æ —Å–ø—ñ–∫–µ—Ä–∞, –∞–ª–µ –ø–æ–≤—ñ–ª—å–Ω—ñ—à–µ
‚Ä¢ –ó–±—ñ–ª—å—à–µ–Ω–Ω—è ‚Üí —à–≤–∏–¥—à–∞ –æ–±—Ä–æ–±–∫–∞, –∞–ª–µ –º–æ–∂–ª–∏–≤–µ –∑–º—ñ—à—É–≤–∞–Ω–Ω—è —Å–ø—ñ–∫–µ—Ä—ñ–≤ –Ω–∞ –¥–æ–≤–≥–∏—Ö —Å–µ–≥–º–µ–Ω—Ç–∞—Ö</span>
                  </span>
                </label>
                <input type="number" id="separationChunkSeconds" min="5" max="120" step="1" value="10" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                <div style="font-size: 11px; color: #28a745; margin-top: 3px; font-weight: 600;">‚úÖ –†–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–æ: 10 —Å–µ–∫ (–æ–ø—Ç–∏–º–∞–ª—å–Ω–æ –¥–ª—è –±–µ–∑–ø–µ—á–Ω–æ—ó –æ–±—Ä–æ–±–∫–∏ –∑ sliding window, overlap 2 —Å–µ–∫)</div>
              </div>
              
              <!-- Sample Rate -->
              <div style="position: relative;">
                <label for="separationSampleRate" style="display: flex; align-items: center; gap: 5px; margin-bottom: 5px; font-weight: 600; color: #333; font-size: 14px;">
                  üîä Sample Rate (Hz):
                  <span class="tooltip-trigger tooltip-bottom" style="cursor: help; color: #3498db; font-size: 16px; line-height: 1; position: relative;">
                    ‚ÑπÔ∏è
                    <span class="tooltip-content">Sample Rate –≤–∏–∑–Ω–∞—á–∞—î –∫—ñ–ª—å–∫—ñ—Å—Ç—å –∑—Ä–∞–∑–∫—ñ–≤ –∞—É–¥—ñ–æ –∑–∞ —Å–µ–∫—É–Ω–¥—É.

–ù–∞ —â–æ –≤–ø–ª–∏–≤–∞—î:
‚Ä¢ 8000 Hz: –º—ñ–Ω—ñ–º–∞–ª—å–Ω–∞ —è–∫—ñ—Å—Ç—å, —à–≤–∏–¥–∫–∞ –æ–±—Ä–æ–±–∫–∞, –ø—ñ–¥—Ö–æ–¥–∏—Ç—å –¥–ª—è —Ç–µ–ª–µ—Ñ–æ–Ω–Ω–∏—Ö —Ä–æ–∑–º–æ–≤ (–Ω–µ —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–æ –¥–ª—è –Ω–æ–≤–æ—ó –º–æ–¥–µ–ª—ñ)
‚Ä¢ 16000 Hz: ‚úÖ –†–ï–ö–û–ú–ï–ù–î–û–í–ê–ù–û - –º–æ–¥–µ–ª—å –Ω–∞–≤—á–∞–ª–∞—Å—è –Ω–∞ 16kHz, –æ–ø—Ç–∏–º–∞–ª—å–Ω–∞ —è–∫—ñ—Å—Ç—å –¥–ª—è —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü—ñ—ó Whisper
‚Ä¢ 22050-44100 Hz: –≤–∏—Å–æ–∫–∞ —è–∫—ñ—Å—Ç—å, –∫—Ä–∞—â–µ —Ä–æ–∑–ø—ñ–∑–Ω–∞–≤–∞–Ω–Ω—è –¥–µ—Ç–∞–ª–µ–π, –∞–ª–µ –ø–æ–≤—ñ–ª—å–Ω—ñ—à–∞ –æ–±—Ä–æ–±–∫–∞
‚Ä¢ 48000 Hz: –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞ —è–∫—ñ—Å—Ç—å, –Ω–∞–π–∫—Ä–∞—â–µ –¥–ª—è –º—É–∑–∏–∫–∏ —Ç–∞ –≤–∏—Å–æ–∫–æ—è–∫—ñ—Å–Ω–∏—Ö –∑–∞–ø–∏—Å—ñ–≤

–†–µ–∑—É–ª—å—Ç–∞—Ç –∑–º—ñ–Ω–∏:
‚Ä¢ –ó–±—ñ–ª—å—à–µ–Ω–Ω—è ‚Üí –∫—Ä–∞—â–∞ —è–∫—ñ—Å—Ç—å –∑–≤—É–∫—É, –º–µ–Ω—à–µ –≤—Ç—Ä–∞—Ç –ø—Ä–∏ –æ–±—Ä–æ–±—Ü—ñ, –∫—Ä–∞—â–µ —Ä–æ–∑–ø—ñ–∑–Ω–∞–≤–∞–Ω–Ω—è —Å–ø—ñ–∫–µ—Ä—ñ–≤, –∞–ª–µ –ø–æ–≤—ñ–ª—å–Ω—ñ—à–∞ –æ–±—Ä–æ–±–∫–∞ —Ç–∞ –±—ñ–ª—å—à–µ –ø–∞–º º—è—Ç—ñ
‚Ä¢ –ó–º–µ–Ω—à–µ–Ω–Ω—è ‚Üí —à–≤–∏–¥—à–∞ –æ–±—Ä–æ–±–∫–∞, –º–µ–Ω—à–µ –ø–∞–º º—è—Ç—ñ, –∞–ª–µ –º–æ–∂–ª–∏–≤—ñ –≤—Ç—Ä–∞—Ç–∏ —è–∫–æ—Å—Ç—ñ —Ç–∞ –≥—ñ—Ä—à–µ —Ä–æ–∑–ø—ñ–∑–Ω–∞–≤–∞–Ω–Ω—è –¥–µ—Ç–∞–ª–µ–π

‚ö†Ô∏è –í–ê–ñ–õ–ò–í–û: –ú–æ–¥–µ–ª—å sepformer-whamr16k –Ω–∞–≤—á–∞–ª–∞—Å—è –Ω–∞ 16kHz. –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è —ñ–Ω—à–∏—Ö –∑–Ω–∞—á–µ–Ω—å –º–æ–∂–µ –ø–æ–≥—ñ—Ä—à–∏—Ç–∏ —è–∫—ñ—Å—Ç—å —Ä–æ–∑–¥—ñ–ª–µ–Ω–Ω—è.</span>
                  </span>
                </label>
                <select id="separationSampleRate" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                  <option value="8000">8000 Hz</option>
                  <option value="16000" selected>16000 Hz (—Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–æ - –º–æ–¥–µ–ª—å –Ω–∞–≤—á–∞–ª–∞—Å—è –Ω–∞ 16kHz)</option>
                  <option value="22050">22050 Hz</option>
                  <option value="44100">44100 Hz</option>
                  <option value="48000">48000 Hz (‚ö†Ô∏è –º–æ–∂–µ –ø–æ–≥—ñ—Ä—à–∏—Ç–∏ —è–∫—ñ—Å—Ç—å)</option>
                </select>
                <div style="font-size: 11px; color: #28a745; margin-top: 3px; font-weight: 600;">‚úÖ –ú–æ–¥–µ–ª—å –Ω–∞–≤—á–∞–ª–∞—Å—è –Ω–∞ 16kHz - –æ–ø—Ç–∏–º–∞–ª—å–Ω–∞ —è–∫—ñ—Å—Ç—å –¥–ª—è —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü—ñ—ó Whisper</div>
              </div>
              
              <!-- Audio Normalization Settings -->
              <div style="margin-top: 10px; padding: 12px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 6px; border: 2px solid #667eea; box-shadow: 0 2px 8px rgba(102, 126, 234, 0.2);">
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 10px;">
                  <span style="font-size: 18px;">üîä</span>
                  <strong style="color: white; font-size: 14px;">–ù–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—è –≥—É—á–Ω–æ—Å—Ç—ñ</strong>
                </div>
                <div style="font-size: 12px; color: rgba(255, 255, 255, 0.95); line-height: 1.5; margin-bottom: 12px;">
                  –ê—É–¥—ñ–æ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –≤–∏—Ä—ñ–≤–Ω—é—î—Ç—å—Å—è –ø–µ—Ä–µ–¥ –æ–±—Ä–æ–±–∫–æ—é –¥–ª—è —É–Ω–∏–∫–Ω–µ–Ω–Ω—è –ø–ª—É—Ç–∞–Ω–∏–Ω–∏ —Å–ø—ñ–∫–µ—Ä—ñ–≤ —á–µ—Ä–µ–∑ –ø–µ—Ä–µ–ø–∞–¥–∏ –≥—É—á–Ω–æ—Å—Ç—ñ.
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                  <!-- Normalization Method -->
                  <div style="position: relative;">
                    <label for="separationNormalizationMethod" style="display: flex; align-items: center; gap: 5px; margin-bottom: 5px; font-weight: 600; color: white; font-size: 13px;">
                      –ú–µ—Ç–æ–¥:
                      <span class="tooltip-trigger tooltip-bottom" style="cursor: help; color: rgba(255, 255, 255, 0.9); font-size: 14px; line-height: 1; position: relative;">
                        ‚ÑπÔ∏è
                        <span class="tooltip-content">–ú–µ—Ç–æ–¥ –Ω–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—ó –≥—É—á–Ω–æ—Å—Ç—ñ:

‚Ä¢ Peak: –≤–∏—Ä—ñ–≤–Ω—é—î –¥–æ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–Ω—è (—Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–æ –¥–ª—è –±—ñ–ª—å—à–æ—Å—Ç—ñ –≤–∏–ø–∞–¥–∫—ñ–≤)
‚Ä¢ RMS: –≤–∏—Ä—ñ–≤–Ω—é—î —Å–µ—Ä–µ–¥–Ω—å–æ–∫–≤–∞–¥—Ä–∞—Ç–∏—á–Ω–µ –∑–Ω–∞—á–µ–Ω–Ω—è (–∫—Ä–∞—â–µ –¥–ª—è –∑–∞–ø–∏—Å—ñ–≤ –∑ —Ä—ñ–∑–Ω–æ—é –¥–∏–Ω–∞–º—ñ–∫–æ—é)

–í–ø–ª–∏–≤–∞—î –Ω–∞ –≤–∏—Ä—ñ–≤–Ω—é–≤–∞–Ω–Ω—è –≥—É—á–Ω–æ—Å—Ç—ñ —Ç–∞ —É–Ω–∏–∫–Ω–µ–Ω–Ω—è –ø–ª—É—Ç–∞–Ω–∏–Ω–∏ —Å–ø—ñ–∫–µ—Ä—ñ–≤ —á–µ—Ä–µ–∑ –ø–µ—Ä–µ–ø–∞–¥–∏ –≥—É—á–Ω–æ—Å—Ç—ñ.</span>
                      </span>
                    </label>
                    <select id="separationNormalizationMethod" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                      <option value="peak" selected>Peak</option>
                      <option value="rms">RMS</option>
                    </select>
                  </div>
                  
                  <!-- Normalization Level -->
                  <div style="position: relative;">
                    <label for="separationNormalizationLevel" style="display: flex; align-items: center; gap: 5px; margin-bottom: 5px; font-weight: 600; color: white; font-size: 13px;">
                      –†—ñ–≤–µ–Ω—å:
                      <span class="tooltip-trigger tooltip-bottom" style="cursor: help; color: rgba(255, 255, 255, 0.9); font-size: 14px; line-height: 1; position: relative;">
                        ‚ÑπÔ∏è
                        <span class="tooltip-content">–†—ñ–≤–µ–Ω—å –Ω–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—ó (0.5-0.95):

‚Ä¢ –ú–µ–Ω—à–µ (0.5-0.7): –º–µ–Ω—à –∞–≥—Ä–µ—Å–∏–≤–Ω–∞ –Ω–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—è, –∑–±–µ—Ä—ñ–≥–∞—î –±—ñ–ª—å—à–µ –¥–∏–Ω–∞–º—ñ–∫–∏
‚Ä¢ –û–ø—Ç–∏–º–∞–ª—å–Ω–µ (0.75-0.85): –±–∞–ª–∞–Ω—Å –º—ñ–∂ –≤–∏—Ä—ñ–≤–Ω—é–≤–∞–Ω–Ω—è–º —Ç–∞ —è–∫—ñ—Å—Ç—é (—Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–æ 0.80)
‚Ä¢ –ë—ñ–ª—å—à–µ (0.9-0.95): –¥—É–∂–µ –∞–≥—Ä–µ—Å–∏–≤–Ω–∞ –Ω–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—è, –º–∞–∫—Å–∏–º–∞–ª—å–Ω–µ –≤–∏—Ä—ñ–≤–Ω—é–≤–∞–Ω–Ω—è

–í–ø–ª–∏–≤–∞—î –Ω–∞ –≤–∏—Ä—ñ–≤–Ω—é–≤–∞–Ω–Ω—è –≥—É—á–Ω–æ—Å—Ç—ñ –ø—Ä–æ—Ç—è–≥–æ–º –∑–∞–ø–∏—Å—É —Ç–∞ —É–Ω–∏–∫–Ω–µ–Ω–Ω—è –ø–µ—Ä–µ–ø–∞–¥—ñ–≤ –≥—É—á–Ω–æ—Å—Ç—ñ.</span>
                      </span>
                    </label>
                    <input type="number" id="separationNormalizationLevel" min="0.5" max="0.95" step="0.05" value="0.80" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                  </div>
                </div>
                <div id="normalizationStatusDisplay" style="font-size: 11px; color: rgba(255, 255, 255, 0.9); margin-top: 8px; font-weight: 600; padding: 6px; background: rgba(255, 255, 255, 0.1); border-radius: 4px;">
                  –ê–∫—Ç–∏–≤–Ω–∞: <span id="normalizationMethodDisplay">Peak</span> normalization (<span id="normalizationLevelDisplay">80</span>%)
                </div>
              </div>
              
              <!-- Device -->
              <div style="position: relative;">
                <label for="separationDevice" style="display: flex; align-items: center; gap: 5px; margin-bottom: 5px; font-weight: 600; color: #333; font-size: 14px;">
                  üíª –ü—Ä–∏—Å—Ç—Ä—ñ–π –æ–±—Ä–æ–±–∫–∏:
                  <span class="tooltip-trigger tooltip-bottom" style="cursor: help; color: #3498db; font-size: 16px; line-height: 1; position: relative;">
                    ‚ÑπÔ∏è
                    <span class="tooltip-content">–ü—Ä–∏—Å—Ç—Ä—ñ–π –æ–±—Ä–æ–±–∫–∏ –≤–∏–∑–Ω–∞—á–∞—î, –¥–µ –≤–∏–∫–æ–Ω—É—î—Ç—å—Å—è –æ–±—á–∏—Å–ª–µ–Ω–Ω—è –º–æ–¥–µ–ª—ñ.

–ù–∞ —â–æ –≤–ø–ª–∏–≤–∞—î:
‚Ä¢ CPU: —É–Ω—ñ–≤–µ—Ä—Å–∞–ª—å–Ω–∏–π, –ø—Ä–∞—Ü—é—î –Ω–∞ –±—É–¥—å-—è–∫–æ–º—É –∫–æ–º–ø º—é—Ç–µ—Ä—ñ, –∞–ª–µ –ø–æ–≤—ñ–ª—å–Ω—ñ—à–∏–π
‚Ä¢ CUDA (NVIDIA GPU): –∑–Ω–∞—á–Ω–æ —à–≤–∏–¥—à–∞ –æ–±—Ä–æ–±–∫–∞ –Ω–∞ NVIDIA –≥—Ä–∞—Ñ—ñ—á–Ω–∏—Ö –∫–∞—Ä—Ç–∞—Ö, –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î GPU –ø–∞–º º—è—Ç—å
‚Ä¢ MPS (Apple Silicon): –æ–ø—Ç–∏–º—ñ–∑–æ–≤–∞–Ω–æ –¥–ª—è Mac –∑ Apple Silicon (M1/M2/M3), —à–≤–∏–¥—à–∞ –æ–±—Ä–æ–±–∫–∞ –Ω–∞ —Ü–∏—Ö –ø—Ä–∏—Å—Ç—Ä–æ—è—Ö
‚Ä¢ –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–∏–π –≤–∏–±—ñ—Ä: —Å–∏—Å—Ç–µ–º–∞ —Å–∞–º–∞ –≤–∏–±–∏—Ä–∞—î –Ω–∞–π–∫—Ä–∞—â–∏–π –¥–æ—Å—Ç—É–ø–Ω–∏–π –ø—Ä–∏—Å—Ç—Ä—ñ–π

–†–µ–∑—É–ª—å—Ç–∞—Ç –∑–º—ñ–Ω–∏:
‚Ä¢ GPU (CUDA/MPS) ‚Üí –∑–Ω–∞—á–Ω–æ —à–≤–∏–¥—à–∞ –æ–±—Ä–æ–±–∫–∞ (–≤ 5-10 —Ä–∞–∑—ñ–≤), –º–æ–∂–ª–∏–≤—ñ—Å—Ç—å –æ–±—Ä–æ–±–ª—è—Ç–∏ –±—ñ–ª—å—à—ñ —Ñ–∞–π–ª–∏, –∞–ª–µ –ø–æ—Ç—Ä–µ–±—É—î –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–æ–≥–æ –æ–±–ª–∞–¥–Ω–∞–Ω–Ω—è
‚Ä¢ CPU ‚Üí –ø–æ–≤—ñ–ª—å–Ω—ñ—à–∞ –æ–±—Ä–æ–±–∫–∞, –∞–ª–µ –ø—Ä–∞—Ü—é—î –Ω–∞ –±—É–¥—å-—è–∫–æ–º—É –∫–æ–º–ø º—é—Ç–µ—Ä—ñ, —Å—Ç–∞–±—ñ–ª—å–Ω—ñ—à–∞ —Ä–æ–±–æ—Ç–∞</span>
                  </span>
                </label>
                <select id="separationDevice" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                  <option value="auto" selected>–ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–∏–π –≤–∏–±—ñ—Ä</option>
                  <option value="cpu">CPU</option>
                  <option value="cuda">CUDA (NVIDIA GPU)</option>
                  <option value="mps">MPS (Apple Silicon)</option>
                </select>
                <div style="font-size: 11px; color: #666; margin-top: 3px;">GPU –ø—Ä–∏—Å–∫–æ—Ä—é—î –æ–±—Ä–æ–±–∫—É</div>
              </div>
              
              <!-- Number of Speakers -->
              <div style="position: relative;">
                <label for="separationNumSpeakers" style="display: flex; align-items: center; gap: 5px; margin-bottom: 5px; font-weight: 600; color: #333; font-size: 14px;">
                  üë• –û—á—ñ–∫—É–≤–∞–Ω–∞ –∫—ñ–ª—å–∫—ñ—Å—Ç—å —Å–ø—ñ–∫–µ—Ä—ñ–≤:
                  <span class="tooltip-trigger tooltip-bottom" style="cursor: help; color: #3498db; font-size: 16px; line-height: 1; position: relative;">
                    ‚ÑπÔ∏è
                    <span class="tooltip-content">–û—á—ñ–∫—É–≤–∞–Ω–∞ –∫—ñ–ª—å–∫—ñ—Å—Ç—å —Å–ø—ñ–∫–µ—Ä—ñ–≤ –≤–∫–∞–∑—É—î, —Å–∫—ñ–ª—å–∫–∏ —Ä—ñ–∑–Ω–∏—Ö –≥–æ–ª–æ—Å—ñ–≤ –æ—á—ñ–∫—É—î—Ç—å—Å—è –≤ –∞—É–¥—ñ–æ.

–ù–∞ —â–æ –≤–ø–ª–∏–≤–∞—î:
‚Ä¢ –ú–æ–¥–µ–ª—å SpeechBrain SepFormer WHAMR16k –Ω–∞–≤—á–µ–Ω–∞ –Ω–∞ 2 —Å–ø—ñ–∫–µ—Ä–∞—Ö, —Ç–æ–º—É –æ–ø—Ç–∏–º–∞–ª—å–Ω–µ –∑–Ω–∞—á–µ–Ω–Ω—è = 2
‚Ä¢ –Ø–∫—â–æ –≤ –∞—É–¥—ñ–æ –±—ñ–ª—å—à–µ —Å–ø—ñ–∫–µ—Ä—ñ–≤, –º–æ–¥–µ–ª—å –≤—Å–µ –æ–¥–Ω–æ —Ä–æ–∑–¥—ñ–ª–∏—Ç—å –Ω–∞ 2 —Ç—Ä–µ–∫–∏, –æ–± º—î–¥–Ω–∞–≤—à–∏ –¥–µ—è–∫–∏—Ö —Å–ø—ñ–∫–µ—Ä—ñ–≤
‚Ä¢ –Ø–∫—â–æ –≤ –∞—É–¥—ñ–æ –º–µ–Ω—à–µ —Å–ø—ñ–∫–µ—Ä—ñ–≤, –æ–¥–∏–Ω –∑ —Ç—Ä–µ–∫—ñ–≤ –º–æ–∂–µ –±—É—Ç–∏ –ø–æ—Ä–æ–∂–Ω—ñ–º –∞–±–æ –º—ñ—Å—Ç–∏—Ç–∏ —Ñ–æ–Ω–æ–≤—ñ —à—É–º–∏

–†–µ–∑—É–ª—å—Ç–∞—Ç –∑–º—ñ–Ω–∏:
‚Ä¢ –ó–Ω–∞—á–µ–Ω–Ω—è 2 (—Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–æ): –æ–ø—Ç–∏–º–∞–ª—å–Ω–∞ —è–∫—ñ—Å—Ç—å –¥–ª—è –¥—ñ–∞–ª–æ–≥—ñ–≤ –∑ –¥–≤–æ–º–∞ —Å–ø—ñ–∫–µ—Ä–∞–º–∏, –º—ñ–Ω—ñ–º–∞–ª—å–Ω–µ –∑–º—ñ—à—É–≤–∞–Ω–Ω—è
‚Ä¢ –Ü–Ω—à—ñ –∑–Ω–∞—á–µ–Ω–Ω—è: –º–æ–¥–µ–ª—å –≤—Å–µ –æ–¥–Ω–æ –ø—Ä–∞—Ü—é—î –∑ 2 –≤–∏—Ö–æ–¥–∞–º–∏, —Ç–æ–º—É –∑–º—ñ–Ω–∞ –Ω–µ –≤–ø–ª–∏–≤–∞—î –Ω–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç (–º–æ–¥–µ–ª—å —Ñ—ñ–∫—Å–æ–≤–∞–Ω–∞ –Ω–∞ 2 —Å–ø—ñ–∫–µ—Ä–∏)</span>
                  </span>
                </label>
                <input type="number" id="separationNumSpeakers" min="2" max="10" step="1" value="2" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                <div style="font-size: 11px; color: #666; margin-top: 3px;">–ú–æ–¥–µ–ª—å –ø—ñ–¥—Ç—Ä–∏–º—É—î 2 —Å–ø—ñ–∫–µ—Ä–∏</div>
              </div>
            </div>
            
            <!-- Quality Settings (Critical for separation quality) -->
            <div style="margin-top: 15px; padding-top: 15px; border-top: 2px solid #e74c3c;">
              <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
                <label style="font-weight: 700; color: #e74c3c; font-size: 15px;">üéØ –ö–†–ò–¢–ò–ß–ù–Ü –ü–ê–†–ê–ú–ï–¢–†–ò –Ø–ö–û–°–¢–Ü –†–û–ó–î–Ü–õ–ï–ù–ù–Ø:</label>
                <button type="button" onclick="toggleQualitySettings()" style="padding: 4px 12px; font-size: 12px; border-radius: 4px; background: #e74c3c; color: white; border: 1px solid #c0392b; cursor: pointer; font-weight: 600;">
                  <span id="qualitySettingsToggle">‚ñº</span> –†–æ–∑–≥–æ—Ä–Ω—É—Ç–∏
                </button>
              </div>
              <div id="qualitySettingsPanel" style="display: none;">
                <div style="padding: 10px; background: #fee; border-radius: 4px; margin-bottom: 15px; border-left: 4px solid #e74c3c;">
                  <strong style="color: #e74c3c;">‚ö†Ô∏è –£–≤–∞–≥–∞:</strong> –¶—ñ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ –±–µ–∑–ø–æ—Å–µ—Ä–µ–¥–Ω—å–æ –≤–ø–ª–∏–≤–∞—é—Ç—å –Ω–∞ —è–∫—ñ—Å—Ç—å —Ä–æ–∑–¥—ñ–ª–µ–Ω–Ω—è –≥–æ–ª–æ—Å—ñ–≤ —Ç–∞ –Ω–∞—è–≤–Ω—ñ—Å—Ç—å –∑–∞–ª–∏—à–∫—ñ–≤ —ñ–Ω—à–∏—Ö —Å–ø—ñ–∫–µ—Ä—ñ–≤. –ó–º—ñ–Ω—é–π—Ç–µ —ó—Ö –æ–±–µ—Ä–µ–∂–Ω–æ!
                </div>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 15px;">
                  <!-- Segment Overlap -->
                  <div style="position: relative; padding: 12px; background: #fff; border: 2px solid #e74c3c; border-radius: 6px;">
                    <label for="separationSegmentOverlap" style="display: flex; align-items: center; gap: 5px; margin-bottom: 5px; font-weight: 600; color: #e74c3c; font-size: 14px;">
                      üîÄ Segment Overlap (—Å–µ–∫—É–Ω–¥–∏):
                      <span class="tooltip-trigger tooltip-bottom" style="cursor: help; color: #3498db; font-size: 16px; line-height: 1; position: relative;">
                        ‚ÑπÔ∏è
                        <span class="tooltip-content">Segment Overlap –≤–∏–∑–Ω–∞—á–∞—î, —è–∫ –¥–æ–≤–≥–æ –º–æ–∂–Ω–∞ "–ø–µ—Ä–µ—Ö–æ–¥–∏—Ç–∏" –º—ñ–∂ —Å–µ–≥–º–µ–Ω—Ç–∞–º–∏ –ø—Ä–∏ —Ä–æ–∑–¥—ñ–ª–µ–Ω–Ω—ñ –ø–µ—Ä–µ–∫—Ä–∏–≤–∞—é—á–∏—Ö –≥–æ–ª–æ—Å—ñ–≤.

–ù–∞ —â–æ –≤–ø–ª–∏–≤–∞—î:
‚Ä¢ –ú–µ–Ω—à–µ –∑–Ω–∞—á–µ–Ω–Ω—è (0.01-0.02 —Å–µ–∫): –±—ñ–ª—å—à –∂–æ—Ä—Å—Ç–∫–µ —Ä–æ–∑–¥—ñ–ª–µ–Ω–Ω—è, –º–µ–Ω—à–µ –∑–∞–ª–∏—à–∫—ñ–≤ —ñ–Ω—à–æ–≥–æ —Å–ø—ñ–∫–µ—Ä–∞, –∞–ª–µ –º–æ–∂–µ –≤—Ç—Ä–∞—á–∞—Ç–∏ –∫–æ—Ä–æ—Ç–∫—ñ –ø–µ—Ä–µ—Ö–æ–¥–∏
‚Ä¢ –û–ø—Ç–∏–º–∞–ª—å–Ω–µ (0.02-0.05 —Å–µ–∫): –±–∞–ª–∞–Ω—Å –º—ñ–∂ —è–∫—ñ—Å—Ç—é —Ç–∞ —Å—Ç–∞–±—ñ–ª—å–Ω—ñ—Å—Ç—é (—Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–æ –¥–ª—è —è–∫–æ—Å—Ç—ñ)
‚Ä¢ –ë—ñ–ª—å—à–µ –∑–Ω–∞—á–µ–Ω–Ω—è (0.05+ —Å–µ–∫): –º'—è–∫—à–µ —Ä–æ–∑–¥—ñ–ª–µ–Ω–Ω—è, –∞–ª–µ –±—ñ–ª—å—à–µ –∑–∞–ª–∏—à–∫—ñ–≤ —ñ–Ω—à–æ–≥–æ —Å–ø—ñ–∫–µ—Ä–∞

–†–µ–∑—É–ª—å—Ç–∞—Ç –∑–º—ñ–Ω–∏ (–¥–ª—è —è–∫–æ—Å—Ç—ñ —Ä–æ–∑–¥—ñ–ª–µ–Ω–Ω—è):
‚Ä¢ –ó–º–µ–Ω—à–µ–Ω–Ω—è ‚Üí –º–µ–Ω—à–µ –∑–∞–ª–∏—à–∫—ñ–≤ —ñ–Ω—à–æ–≥–æ —Å–ø—ñ–∫–µ—Ä–∞, –∫—Ä–∞—â–µ —Ñ—ñ–ª—å—Ç—Ä—É–≤–∞–Ω–Ω—è –≥–æ–ª–æ—Å—ñ–≤, –∞–ª–µ –º–æ–∂–µ –±—É—Ç–∏ —Ä—ñ–∑–∫—ñ –ø–µ—Ä–µ—Ö–æ–¥–∏
‚Ä¢ –ó–±—ñ–ª—å—à–µ–Ω–Ω—è ‚Üí –ø–ª–∞–≤–Ω—ñ—à—ñ –ø–µ—Ä–µ—Ö–æ–¥–∏, –∞–ª–µ –±—ñ–ª—å—à–µ –∑–º—ñ—à—É–≤–∞–Ω–Ω—è –≥–æ–ª–æ—Å—ñ–≤ —Ç–∞ –∑–∞–ª–∏—à–∫—ñ–≤

üéØ –î–ª—è –≤–∞—à–æ—ó –º–µ—Ç–∏ (–º—ñ–Ω—ñ–º—É–º –∑–∞–ª–∏—à–∫—ñ–≤): –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ 0.02-0.03 —Å–µ–∫</span>
                      </span>
                    </label>
                    <input type="number" id="separationSegmentOverlap" min="0.01" max="1.0" step="0.01" value="0.5" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                    <div style="font-size: 11px; color: #666; margin-top: 3px;">–†–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–æ: 0.3-0.5 —Å–µ–∫ –¥–ª—è –∫—Ä–∞—â–æ–≥–æ –∑—à–∏–≤–∞–Ω–Ω—è —Å–µ–≥–º–µ–Ω—Ç—ñ–≤ (–∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º: 0.5)</div>
                  </div>
                  
                  <!-- Min Intersegment Gap -->
                  <div style="position: relative; padding: 12px; background: #fff; border: 2px solid #e74c3c; border-radius: 6px;">
                    <label for="separationMinIntersegmentGap" style="display: flex; align-items: center; gap: 5px; margin-bottom: 5px; font-weight: 600; color: #e74c3c; font-size: 14px;">
                      ‚ö° Min Intersegment Gap (—Å–µ–∫—É–Ω–¥–∏):
                      <span class="tooltip-trigger tooltip-bottom" style="cursor: help; color: #3498db; font-size: 16px; line-height: 1; position: relative;">
                        ‚ÑπÔ∏è
                        <span class="tooltip-content">Min Intersegment Gap - –º—ñ–Ω—ñ–º–∞–ª—å–Ω–∏–π —ñ–Ω—Ç–µ—Ä–≤–∞–ª –º—ñ–∂ –≥–æ–ª–æ—Å–∞–º–∏, —è–∫–∏–π –¥–æ–∑–≤–æ–ª—è—î —Ä–æ–∑–¥—ñ–ª–∏—Ç–∏ —ó—Ö.

–ù–∞ —â–æ –≤–ø–ª–∏–≤–∞—î:
‚Ä¢ –ú–µ–Ω—à–µ –∑–Ω–∞—á–µ–Ω–Ω—è (0.01-0.03 —Å–µ–∫): –±—ñ–ª—å—à —á—É—Ç–ª–∏–≤–µ —Ä–æ–∑–¥—ñ–ª–µ–Ω–Ω—è, –∫—Ä–∞—â–µ –¥–ª—è –ø–∞—Ä–∞–ª–µ–ª—å–Ω–∏—Ö –º–æ–Ω–æ–ª–æ–≥—ñ–≤, –º–µ–Ω—à–µ "—Å–ª–∏–ø–∞–Ω–Ω—è" –≥–æ–ª–æ—Å—ñ–≤
‚Ä¢ –û–ø—Ç–∏–º–∞–ª—å–Ω–µ (0.03-0.05 —Å–µ–∫): –±–∞–ª–∞–Ω—Å –º—ñ–∂ —á—É—Ç–ª–∏–≤—ñ—Å—Ç—é —Ç–∞ —Å—Ç–∞–±—ñ–ª—å–Ω—ñ—Å—Ç—é
‚Ä¢ –ë—ñ–ª—å—à–µ –∑–Ω–∞—á–µ–Ω–Ω—è (0.05+ —Å–µ–∫): –º–µ–Ω—à–µ –ø–æ–º–∏–ª–∫–æ–≤–∏—Ö —Ä–æ–∑–¥—ñ–ª–µ–Ω—å, –∞–ª–µ –º–æ–∂–µ "—Å–ª–∏–ø–∞—Ç–∏" –≥–æ–ª–æ—Å–∏, —â–æ –≥–æ–≤–æ—Ä—è—Ç—å –æ–¥–Ω–æ—á–∞—Å–Ω–æ

–†–µ–∑—É–ª—å—Ç–∞—Ç –∑–º—ñ–Ω–∏ (–¥–ª—è —è–∫–æ—Å—Ç—ñ —Ä–æ–∑–¥—ñ–ª–µ–Ω–Ω—è):
‚Ä¢ –ó–º–µ–Ω—à–µ–Ω–Ω—è ‚Üí –∫—Ä–∞—â–µ —Ä–æ–∑–¥—ñ–ª–µ–Ω–Ω—è –ø–∞—Ä–∞–ª–µ–ª—å–Ω–∏—Ö –≥–æ–ª–æ—Å—ñ–≤, –º–µ–Ω—à–µ "—Å–ª–∏–ø–∞–Ω–Ω—è", –∞–ª–µ –º–æ–∂–µ –±—É—Ç–∏ –±—ñ–ª—å—à–µ –ø–æ–º–∏–ª–∫–æ–≤–∏—Ö —Ä–æ–∑–¥—ñ–ª–µ–Ω—å
‚Ä¢ –ó–±—ñ–ª—å—à–µ–Ω–Ω—è ‚Üí –º–µ–Ω—à–µ –ø–æ–º–∏–ª–∫–æ–≤–∏—Ö —Ä–æ–∑–¥—ñ–ª–µ–Ω—å, –∞–ª–µ –≥–æ–ª–æ—Å–∏ –º–æ–∂—É—Ç—å "—Å–ª–∏–ø–∞—Ç–∏—Å—è" –ø—Ä–∏ –æ–¥–Ω–æ—á–∞—Å–Ω–æ–º—É –≥–æ–≤–æ—Ä—ñ–Ω–Ω—ñ

üéØ –î–ª—è –≤–∞—à–æ—ó –º–µ—Ç–∏ (–º—ñ–Ω—ñ–º—É–º –∑–∞–ª–∏—à–∫—ñ–≤): –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ 0.03-0.05 —Å–µ–∫</span>
                      </span>
                    </label>
                    <input type="number" id="separationMinIntersegmentGap" min="0.01" max="0.2" step="0.01" value="0.05" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                    <div style="font-size: 11px; color: #666; margin-top: 3px;">–†–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–æ: 0.03-0.05 —Å–µ–∫</div>
                  </div>
                  
                  <!-- Strict Mode -->
                  <div style="position: relative; padding: 12px; background: #fff; border: 2px solid #e74c3c; border-radius: 6px;">
                    <label for="separationStrictMode" style="display: flex; align-items: center; gap: 5px; margin-bottom: 5px; font-weight: 600; color: #e74c3c; font-size: 14px;">
                      üîí Strict Mode:
                      <span class="tooltip-trigger tooltip-bottom" style="cursor: help; color: #3498db; font-size: 16px; line-height: 1; position: relative;">
                        ‚ÑπÔ∏è
                        <span class="tooltip-content">Strict Mode –≥–∞—Ä–∞–Ω—Ç—É—î, —â–æ –Ω–∞–≤—ñ—Ç—å –º—ñ–Ω—ñ–º–∞–ª—å–Ω–µ –ø–µ—Ä–µ–∫—Ä–∏—Ç—Ç—è –≥–æ–ª–æ—Å—ñ–≤ –ø—Ä–∏–∑–≤–µ–¥–µ –¥–æ —Ä–æ–∑–¥—ñ–ª–µ–Ω–Ω—è.

–ù–∞ —â–æ –≤–ø–ª–∏–≤–∞—î:
‚Ä¢ –£–≤—ñ–º–∫–Ω–µ–Ω–æ (true): —Ä–æ–∑–¥—ñ–ª—è—î –ø—Ä–∏ –ö–û–ñ–ù–û–ú–£ –ø–µ—Ä–µ–∫—Ä–∏—Ç—Ç—ñ > segment_overlap, –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞ —è–∫—ñ—Å—Ç—å —Ä–æ–∑–¥—ñ–ª–µ–Ω–Ω—è, –º—ñ–Ω—ñ–º—É–º –∑–∞–ª–∏—à–∫—ñ–≤
‚Ä¢ –í–∏–º–∫–Ω–µ–Ω–æ (false): –±—ñ–ª—å—à –º'—è–∫–µ —Ä–æ–∑–¥—ñ–ª–µ–Ω–Ω—è, –º–æ–∂–µ –ø—Ä–æ–ø—É—Å–∫–∞—Ç–∏ –∫–æ—Ä–æ—Ç–∫—ñ –ø–µ—Ä–µ–∫—Ä–∏—Ç—Ç—è, –±—ñ–ª—å—à–µ –∑–∞–ª–∏—à–∫—ñ–≤ —ñ–Ω—à–æ–≥–æ —Å–ø—ñ–∫–µ—Ä–∞

–†–µ–∑—É–ª—å—Ç–∞—Ç –∑–º—ñ–Ω–∏ (–¥–ª—è —è–∫–æ—Å—Ç—ñ —Ä–æ–∑–¥—ñ–ª–µ–Ω–Ω—è):
‚Ä¢ –£–≤—ñ–º–∫–Ω–µ–Ω–æ ‚Üí –∫—Ä–∞—â–µ —Ñ—ñ–ª—å—Ç—Ä—É–≤–∞–Ω–Ω—è –≥–æ–ª–æ—Å—ñ–≤, –º–µ–Ω—à–µ –∑–∞–ª–∏—à–∫—ñ–≤ —ñ–Ω—à–æ–≥–æ —Å–ø—ñ–∫–µ—Ä–∞, –∞–ª–µ –º–æ–∂–µ –±—É—Ç–∏ –±—ñ–ª—å—à–µ —Å–µ–≥–º–µ–Ω—Ç—ñ–≤
‚Ä¢ –í–∏–º–∫–Ω–µ–Ω–æ ‚Üí –º–µ–Ω—à–µ —Å–µ–≥–º–µ–Ω—Ç—ñ–≤, –∞–ª–µ –±—ñ–ª—å—à–µ –∑–º—ñ—à—É–≤–∞–Ω–Ω—è —Ç–∞ –∑–∞–ª–∏—à–∫—ñ–≤

üéØ –î–ª—è –≤–∞—à–æ—ó –º–µ—Ç–∏ (–º—ñ–Ω—ñ–º—É–º –∑–∞–ª–∏—à–∫—ñ–≤): –û–ë–û–í'–Ø–ó–ö–û–í–û —É–≤—ñ–º–∫–Ω—ñ—Ç—å (true)</span>
                      </span>
                    </label>
                    <select id="separationStrictMode" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                      <option value="true" selected>–£–≤—ñ–º–∫–Ω–µ–Ω–æ (—Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–æ –¥–ª—è —è–∫–æ—Å—Ç—ñ)</option>
                      <option value="false">–í–∏–º–∫–Ω–µ–Ω–æ</option>
                    </select>
                    <div style="font-size: 11px; color: #e74c3c; margin-top: 3px; font-weight: 600;">‚ö†Ô∏è –ö—Ä–∏—Ç–∏—á–Ω–æ –≤–∞–∂–ª–∏–≤–æ –¥–ª—è —è–∫–æ—Å—Ç—ñ!</div>
                  </div>
                  
                  <!-- VAD Threshold -->
                  <div style="position: relative; padding: 12px; background: #fff; border: 2px solid #e74c3c; border-radius: 6px;">
                    <label for="separationVadThreshold" style="display: flex; align-items: center; gap: 5px; margin-bottom: 5px; font-weight: 600; color: #e74c3c; font-size: 14px;">
                      üé§ VAD Threshold (—á—É—Ç–ª–∏–≤—ñ—Å—Ç—å –¥–æ –≥–æ–ª–æ—Å—É):
                      <span class="tooltip-trigger tooltip-bottom" style="cursor: help; color: #3498db; font-size: 16px; line-height: 1; position: relative;">
                        ‚ÑπÔ∏è
                        <span class="tooltip-content">VAD Threshold –≤–∏–∑–Ω–∞—á–∞—î —á—É—Ç–ª–∏–≤—ñ—Å—Ç—å –¥–æ –≤–∏—è–≤–ª–µ–Ω–Ω—è –≥–æ–ª–æ—Å—É (0-1).

–ù–∞ —â–æ –≤–ø–ª–∏–≤–∞—î:
‚Ä¢ –ù–∏–∂—á–µ –∑–Ω–∞—á–µ–Ω–Ω—è (0.5-0.6): –±—ñ–ª—å—à —á—É—Ç–ª–∏–≤–µ –≤–∏—è–≤–ª–µ–Ω–Ω—è, –∫—Ä–∞—â–µ –¥–ª—è —Ç–∏—Ö–∏—Ö –≥–æ–ª–æ—Å—ñ–≤, –∞–ª–µ –º–æ–∂–µ –≤–∏—è–≤–ª—è—Ç–∏ —Ñ–æ–Ω–æ–≤—ñ —à—É–º–∏ —è–∫ –≥–æ–ª–æ—Å
‚Ä¢ –û–ø—Ç–∏–º–∞–ª—å–Ω–µ (0.6-0.7): –±–∞–ª–∞–Ω—Å –º—ñ–∂ –≤–∏—è–≤–ª–µ–Ω–Ω—è–º –≥–æ–ª–æ—Å—É —Ç–∞ —Ñ—ñ–ª—å—Ç—Ä–∞—Ü—ñ—î—é —à—É–º—ñ–≤ (—Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–æ)
‚Ä¢ –í–∏—â–µ –∑–Ω–∞—á–µ–Ω–Ω—è (0.7-0.9): –º–µ–Ω—à–µ –ø–æ–º–∏–ª–∫–æ–≤–∏—Ö —Å–ø—Ä–∞—Ü—é–≤–∞–Ω—å, –∞–ª–µ –º–æ–∂–µ –ø—Ä–æ–ø—É—Å–∫–∞—Ç–∏ —Ç–∏—Ö—ñ –≥–æ–ª–æ—Å–∏

–†–µ–∑—É–ª—å—Ç–∞—Ç –∑–º—ñ–Ω–∏ (–¥–ª—è —è–∫–æ—Å—Ç—ñ —Ä–æ–∑–¥—ñ–ª–µ–Ω–Ω—è):
‚Ä¢ –ó–º–µ–Ω—à–µ–Ω–Ω—è ‚Üí –∫—Ä–∞—â–µ –≤–∏—è–≤–ª–µ–Ω–Ω—è —Ç–∏—Ö–∏—Ö –≥–æ–ª–æ—Å—ñ–≤, –∞–ª–µ –º–æ–∂–µ –≤–∫–ª—é—á–∞—Ç–∏ —Ñ–æ–Ω–æ–≤—ñ —à—É–º–∏ –≤ —Ä–æ–∑–¥—ñ–ª–µ–Ω–Ω—è
‚Ä¢ –ó–±—ñ–ª—å—à–µ–Ω–Ω—è ‚Üí –∫—Ä–∞—â–∞ —Ñ—ñ–ª—å—Ç—Ä–∞—Ü—ñ—è —à—É–º—ñ–≤, –∞–ª–µ –º–æ–∂–µ –ø—Ä–æ–ø—É—Å–∫–∞—Ç–∏ —Ç–∏—Ö—ñ —á–∞—Å—Ç–∏–Ω–∏ –º–æ–≤–ª–µ–Ω–Ω—è

üéØ –î–ª—è –≤–∞—à–æ—ó –º–µ—Ç–∏ (–º—ñ–Ω—ñ–º—É–º –∑–∞–ª–∏—à–∫—ñ–≤): –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ 0.6-0.7</span>
                      </span>
                    </label>
                    <input type="number" id="separationVadThreshold" min="0.1" max="0.9" step="0.05" value="0.7" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                    <div style="font-size: 11px; color: #666; margin-top: 3px;">–†–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–æ: 0.6-0.7</div>
                  </div>
                  
                  <!-- Max Speech Duration -->
                  <div style="position: relative; padding: 12px; background: #fff; border: 2px solid #e74c3c; border-radius: 6px;">
                    <label for="separationMaxSpeechDuration" style="display: flex; align-items: center; gap: 5px; margin-bottom: 5px; font-weight: 600; color: #e74c3c; font-size: 14px;">
                      ‚è±Ô∏è Max Speech Duration (—Å–µ–∫—É–Ω–¥–∏):
                      <span class="tooltip-trigger tooltip-bottom" style="cursor: help; color: #3498db; font-size: 16px; line-height: 1; position: relative;">
                        ‚ÑπÔ∏è
                        <span class="tooltip-content">Max Speech Duration - –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞ —Ç—Ä–∏–≤–∞–ª—ñ—Å—Ç—å —Å–µ–≥–º–µ–Ω—Ç—É –ø–µ—Ä–µ–¥ –ø—Ä–∏–º—É—Å–æ–≤–∏–º —Ä–æ–∑–¥—ñ–ª–µ–Ω–Ω—è–º.

–ù–∞ —â–æ –≤–ø–ª–∏–≤–∞—î:
‚Ä¢ –ú–µ–Ω—à–µ –∑–Ω–∞—á–µ–Ω–Ω—è (3-5 —Å–µ–∫): –±—ñ–ª—å—à –¥—Ä—ñ–±–Ω—ñ —Å–µ–≥–º–µ–Ω—Ç–∏, –∫—Ä–∞—â–∞ —è–∫—ñ—Å—Ç—å —Ä–æ–∑–¥—ñ–ª–µ–Ω–Ω—è –¥–ª—è –¥–æ–≤–≥–∏—Ö –º–æ–Ω–æ–ª–æ–≥—ñ–≤, –º–µ–Ω—à–µ –Ω–∞–∫–æ–ø–∏—á–µ–Ω–Ω—è –ø–æ–º–∏–ª–æ–∫
‚Ä¢ –û–ø—Ç–∏–º–∞–ª—å–Ω–µ (5-10 —Å–µ–∫): –±–∞–ª–∞–Ω—Å –º—ñ–∂ —è–∫—ñ—Å—Ç—é —Ç–∞ –µ—Ñ–µ–∫—Ç–∏–≤–Ω—ñ—Å—Ç—é
‚Ä¢ –ë—ñ–ª—å—à–µ –∑–Ω–∞—á–µ–Ω–Ω—è (10+ —Å–µ–∫): –º–µ–Ω—à–µ —Å–µ–≥–º–µ–Ω—Ç—ñ–≤, –∞–ª–µ –º–æ–∂–µ –≥—ñ—Ä—à–µ —Ä–æ–∑–¥—ñ–ª—è—Ç–∏ –¥–æ–≤–≥—ñ –ø–µ—Ä–µ–∫—Ä–∏—Ç—Ç—è

–†–µ–∑—É–ª—å—Ç–∞—Ç –∑–º—ñ–Ω–∏ (–¥–ª—è —è–∫–æ—Å—Ç—ñ —Ä–æ–∑–¥—ñ–ª–µ–Ω–Ω—è):
‚Ä¢ –ó–º–µ–Ω—à–µ–Ω–Ω—è ‚Üí –∫—Ä–∞—â–µ —Ä–æ–∑–¥—ñ–ª–µ–Ω–Ω—è –¥–æ–≤–≥–∏—Ö –ø–µ—Ä–µ–∫—Ä–∏–≤–∞—é—á–∏—Ö —Å–µ–≥–º–µ–Ω—Ç—ñ–≤, –º–µ–Ω—à–µ –Ω–∞–∫–æ–ø–∏—á–µ–Ω–Ω—è –ø–æ–º–∏–ª–æ–∫
‚Ä¢ –ó–±—ñ–ª—å—à–µ–Ω–Ω—è ‚Üí –º–µ–Ω—à–µ —Å–µ–≥–º–µ–Ω—Ç—ñ–≤, –∞–ª–µ –º–æ–∂–µ –≥—ñ—Ä—à–µ –æ–±—Ä–æ–±–ª—è—Ç–∏ –¥–æ–≤–≥—ñ –ø–µ—Ä–µ–∫—Ä–∏—Ç—Ç—è

üéØ –î–ª—è –≤–∞—à–æ—ó –º–µ—Ç–∏ (–º—ñ–Ω—ñ–º—É–º –∑–∞–ª–∏—à–∫—ñ–≤): –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ 5-7 —Å–µ–∫</span>
                      </span>
                    </label>
                    <input type="number" id="separationMaxSpeechDuration" min="3" max="60" step="1" value="30" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                    <div style="font-size: 11px; color: #666; margin-top: 3px;">–†–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–æ: 20-30 —Å–µ–∫ (–∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º: 30, –Ω–µ –æ–±–º–µ–∂—É—î —è–∫—â–æ = chunk size)</div>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- Advanced Settings -->
            <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #ffc107;">
              <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
                <label style="font-weight: 600; color: #333; font-size: 14px;">üîß –î–æ–¥–∞—Ç–∫–æ–≤—ñ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è:</label>
                <button type="button" onclick="toggleAdvancedSettings()" style="padding: 4px 12px; font-size: 12px; border-radius: 4px; background: #ffc107; color: #333; border: 1px solid #ff9800; cursor: pointer; font-weight: 600;">
                  <span id="advancedSettingsToggle">‚ñº</span> –†–æ–∑–≥–æ—Ä–Ω—É—Ç–∏
                </button>
              </div>
              <div id="advancedSettingsPanel" style="display: none;">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 15px;">
                  <!-- Batch Size -->
                  <div style="position: relative;">
                    <label for="separationBatchSize" style="display: flex; align-items: center; gap: 5px; margin-bottom: 5px; font-weight: 600; color: #333; font-size: 14px;">
                      üì¶ Batch Size:
                      <span class="tooltip-trigger tooltip-bottom" style="cursor: help; color: #3498db; font-size: 16px; line-height: 1; position: relative;">
                        ‚ÑπÔ∏è
                        <span class="tooltip-content">Batch Size –≤–∏–∑–Ω–∞—á–∞—î –∫—ñ–ª—å–∫—ñ—Å—Ç—å —Å–µ–≥–º–µ–Ω—Ç—ñ–≤, —â–æ –æ–±—Ä–æ–±–ª—è—é—Ç—å—Å—è –æ–¥–Ω–æ—á–∞—Å–Ω–æ.

–ù–∞ —â–æ –≤–ø–ª–∏–≤–∞—î:
‚Ä¢ –ú–µ–Ω—à–µ –∑–Ω–∞—á–µ–Ω–Ω—è (1-2): –º–µ–Ω—à–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è –ø–∞–º'—è—Ç—ñ, —Å—Ç–∞–±—ñ–ª—å–Ω—ñ—à–∞ —Ä–æ–±–æ—Ç–∞, –∞–ª–µ –ø–æ–≤—ñ–ª—å–Ω—ñ—à–µ
‚Ä¢ –û–ø—Ç–∏–º–∞–ª—å–Ω–µ (4-8): –±–∞–ª–∞–Ω—Å –º—ñ–∂ —à–≤–∏–¥–∫—ñ—Å—Ç—é —Ç–∞ –ø–∞–º'—è—Ç—Ç—é
‚Ä¢ –ë—ñ–ª—å—à–µ –∑–Ω–∞—á–µ–Ω–Ω—è (8+): —à–≤–∏–¥—à–∞ –æ–±—Ä–æ–±–∫–∞, –∞–ª–µ –º–æ–∂–µ –≤–∏–∫–ª–∏–∫–∞—Ç–∏ memory overflow

–†–µ–∑—É–ª—å—Ç–∞—Ç –∑–º—ñ–Ω–∏:
‚Ä¢ –ó–º–µ–Ω—à–µ–Ω–Ω—è ‚Üí –º–µ–Ω—à–µ –ø–∞–º'—è—Ç—ñ, —Å—Ç–∞–±—ñ–ª—å–Ω—ñ—à–∞ —Ä–æ–±–æ—Ç–∞, –∞–ª–µ –ø–æ–≤—ñ–ª—å–Ω—ñ—à–µ
‚Ä¢ –ó–±—ñ–ª—å—à–µ–Ω–Ω—è ‚Üí —à–≤–∏–¥—à–∞ –æ–±—Ä–æ–±–∫–∞, –∞–ª–µ –±—ñ–ª—å—à–µ –ø–∞–º'—è—Ç—ñ —Ç–∞ —Ä–∏–∑–∏–∫ overflow</span>
                      </span>
                    </label>
                    <input type="number" id="separationBatchSize" min="1" max="16" step="1" value="4" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                    <div style="font-size: 11px; color: #666; margin-top: 3px;">–†–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–æ: 4-8</div>
                  </div>
                  
                  <!-- Dynamic Batching -->
                  <div style="position: relative;">
                    <label for="separationDynamicBatching" style="display: flex; align-items: center; gap: 5px; margin-bottom: 5px; font-weight: 600; color: #333; font-size: 14px;">
                      üîÑ Dynamic Batching:
                      <span class="tooltip-trigger tooltip-bottom" style="cursor: help; color: #3498db; font-size: 16px; line-height: 1; position: relative;">
                        ‚ÑπÔ∏è
                        <span class="tooltip-content">Dynamic Batching –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ —Ä–µ–≥—É–ª—é—î —Ä–æ–∑–º—ñ—Ä –±–∞—Ç—á—É –∑–∞–ª–µ–∂–Ω–æ –≤—ñ–¥ –¥–æ—Å—Ç—É–ø–Ω–æ—ó –ø–∞–º'—è—Ç—ñ.

–ù–∞ —â–æ –≤–ø–ª–∏–≤–∞—î:
‚Ä¢ –£–≤—ñ–º–∫–Ω–µ–Ω–æ: –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–∞ –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è, –∞–ª–µ –º–æ–∂–µ –≤–∏–∫–ª–∏–∫–∞—Ç–∏ memory overflow –Ω–∞ –≤–µ–ª–∏–∫–∏—Ö —Ñ–∞–π–ª–∞—Ö
‚Ä¢ –í–∏–º–∫–Ω–µ–Ω–æ: —Ñ—ñ–∫—Å–æ–≤–∞–Ω–∏–π batch_size, —Å—Ç–∞–±—ñ–ª—å–Ω—ñ—à–∞ —Ä–æ–±–æ—Ç–∞, –º–µ–Ω—à–µ —Ä–∏–∑–∏–∫—É overflow

–†–µ–∑—É–ª—å—Ç–∞—Ç –∑–º—ñ–Ω–∏:
‚Ä¢ –£–≤—ñ–º–∫–Ω–µ–Ω–æ ‚Üí –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–∞ –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è, –∞–ª–µ —Ä–∏–∑–∏–∫ overflow
‚Ä¢ –í–∏–º–∫–Ω–µ–Ω–æ ‚Üí —Å—Ç–∞–±—ñ–ª—å–Ω—ñ—à–∞ —Ä–æ–±–æ—Ç–∞, –º–µ–Ω—à–µ —Ä–∏–∑–∏–∫—É –ø—Ä–æ–±–ª–µ–º –∑ –ø–∞–º'—è—Ç—Ç—é (—Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–æ)</span>
                      </span>
                    </label>
                    <select id="separationDynamicBatching" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                      <option value="false" selected>–í–∏–º–∫–Ω–µ–Ω–æ (—Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–æ)</option>
                      <option value="true">–£–≤—ñ–º–∫–Ω–µ–Ω–æ</option>
                    </select>
                    <div style="font-size: 11px; color: #666; margin-top: 3px;">–í–∏–º–∫–Ω—ñ—Ç—å –¥–ª—è —Å—Ç–∞–±—ñ–ª—å–Ω–æ—Å—Ç—ñ</div>
                  </div>
                  
                  <!-- VAD Model -->
                  <div style="position: relative;">
                    <label for="separationVadModel" style="display: flex; align-items: center; gap: 5px; margin-bottom: 5px; font-weight: 600; color: #333; font-size: 14px;">
                      üé§ VAD Model:
                      <span class="tooltip-trigger tooltip-bottom" style="cursor: help; color: #3498db; font-size: 16px; line-height: 1; position: relative;">
                        ‚ÑπÔ∏è
                        <span class="tooltip-content">VAD Model –≤–∏–∑–Ω–∞—á–∞—î –º–æ–¥–µ–ª—å –¥–ª—è –≤–∏—è–≤–ª–µ–Ω–Ω—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ –≥–æ–ª–æ—Å—É.

–ù–∞ —â–æ –≤–ø–ª–∏–≤–∞—î:
‚Ä¢ speechbrain/vad-crdnn-libriparty: —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞ –º–æ–¥–µ–ª—å, –¥–æ–±—Ä–µ –ø—Ä–∞—Ü—é—î –¥–ª—è –±—ñ–ª—å—à–æ—Å—Ç—ñ –≤–∏–ø–∞–¥–∫—ñ–≤
‚Ä¢ –Ü–Ω—à—ñ –º–æ–¥–µ–ª—ñ: –º–æ–∂—É—Ç—å –±—É—Ç–∏ –æ–ø—Ç–∏–º—ñ–∑–æ–≤–∞–Ω—ñ –¥–ª—è —Å–ø–µ—Ü–∏—Ñ—ñ—á–Ω–∏—Ö —Ç–∏–ø—ñ–≤ –∞—É–¥—ñ–æ

–†–µ–∑—É–ª—å—Ç–∞—Ç –∑–º—ñ–Ω–∏:
‚Ä¢ –†—ñ–∑–Ω—ñ –º–æ–¥–µ–ª—ñ –º–æ–∂—É—Ç—å –ø–æ-—Ä—ñ–∑–Ω–æ–º—É –≤–∏—è–≤–ª—è—Ç–∏ –≥–æ–ª–æ—Å, —â–æ –≤–ø–ª–∏–≤–∞—î –Ω–∞ —è–∫—ñ—Å—Ç—å —Ä–æ–∑–¥—ñ–ª–µ–Ω–Ω—è</span>
                      </span>
                    </label>
                    <select id="separationVadModel" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                      <option value="speechbrain/vad-crdnn-libriparty" selected>speechbrain/vad-crdnn-libriparty (—Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–æ)</option>
                    </select>
                    <div style="font-size: 11px; color: #666; margin-top: 3px;">–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞ –º–æ–¥–µ–ª—å VAD</div>
                  </div>
                  
                  <!-- Diarization Model -->
                  <div style="position: relative;">
                    <label for="separationDiarizationModel" style="display: flex; align-items: center; gap: 5px; margin-bottom: 5px; font-weight: 600; color: #333; font-size: 14px;">
                      üéôÔ∏è Diarization Model:
                      <span class="tooltip-trigger tooltip-bottom" style="cursor: help; color: #3498db; font-size: 16px; line-height: 1; position: relative;">
                        ‚ÑπÔ∏è
                        <span class="tooltip-content">‚ö†Ô∏è –£–í–ê–ì–ê: –¶–µ–π –ø–∞—Ä–∞–º–µ—Ç—Ä –ø–æ–∫–∏ —â–æ –ù–ï –í–ò–ö–û–†–ò–°–¢–û–í–£–Ñ–¢–¨–°–Ø –≤ –∫–æ–¥—ñ.

Diarization Model - —Ü–µ –º–æ–¥–µ–ª—å –¥–ª—è –¥—ñ–∞—Ä–∏–∑–∞—Ü—ñ—ó (–≤–∏–∑–Ω–∞—á–µ–Ω–Ω—è —Ö—Ç–æ –∫–æ–ª–∏ –≥–æ–≤–æ—Ä–∏—Ç—å), –∞ –Ω–µ –¥–ª—è —Ä–æ–∑–¥—ñ–ª–µ–Ω–Ω—è –≥–æ–ª–æ—Å—ñ–≤.

–ú–æ–¥–µ–ª—å –¥–ª—è —Ä–æ–∑–¥—ñ–ª–µ–Ω–Ω—è (separation) - —Ü–µ speechbrain/sepformer-whamr16k, —è–∫–∞ —Ñ—ñ–∫—Å–æ–≤–∞–Ω–∞ –≤ –∫–æ–¥—ñ.

–¶–µ–π –ø–∞—Ä–∞–º–µ—Ç—Ä –∑–±–µ—Ä—ñ–≥–∞—î—Ç—å—Å—è –¥–ª—è –º–∞–π–±—É—Ç–Ω—å–æ—ó —ñ–Ω—Ç–µ–≥—Ä–∞—Ü—ñ—ó –¥—ñ–∞—Ä–∏–∑–∞—Ü—ñ—ó, –∞–ª–µ –Ω–∞—Ä–∞–∑—ñ –Ω–µ –≤–ø–ª–∏–≤–∞—î –Ω–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Ä–æ–∑–¥—ñ–ª–µ–Ω–Ω—è.</span>
                      </span>
                    </label>
                    <select id="separationDiarizationModel" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; opacity: 0.6;" disabled>
                      <option value="speechbrain/diarization-mfa" selected>speechbrain/diarization-mfa (–Ω–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è)</option>
                    </select>
                    <div style="font-size: 11px; color: #999; margin-top: 3px;">‚ö†Ô∏è –ü–∞—Ä–∞–º–µ—Ç—Ä –¥–ª—è –º–∞–π–±—É—Ç–Ω—å–æ—ó —ñ–Ω—Ç–µ–≥—Ä–∞—Ü—ñ—ó (–ø–æ–∫–∏ –Ω–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è)</div>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- Reset to Defaults Button -->
            <div style="margin-top: 15px; text-align: right;">
              <button type="button" onclick="resetSeparationSettings()" style="padding: 6px 12px; font-size: 12px; border-radius: 4px; background: #6c757d; color: white; border: none; cursor: pointer; font-weight: 600;">
                üîÑ –°–∫–∏–Ω—É—Ç–∏ –¥–æ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è
              </button>
            </div>
          </div>
        </div>
        
        <!-- Parameter Optimization Section -->
        <div style="margin-bottom: 20px; padding: 15px; background: #e8f5e9; border-radius: 6px; border: 2px solid #4caf50;">
          <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px;">
            <label style="font-weight: 600; color: #2e7d32; font-size: 16px;">ü§ñ –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–∏–π –ø—ñ–¥–±—ñ—Ä –ø–∞—Ä–∞–º–µ—Ç—Ä—ñ–≤:</label>
            <button type="button" onclick="toggleOptimizationPanel()" style="padding: 4px 12px; font-size: 12px; border-radius: 4px; background: #4caf50; color: white; border: 1px solid #45a049; cursor: pointer; font-weight: 600;">
              <span id="optimizationToggle">‚ñº</span> –†–æ–∑–≥–æ—Ä–Ω—É—Ç–∏
            </button>
          </div>
          <div id="optimizationPanel" style="display: none;">
            <div style="margin-bottom: 15px; padding: 10px; background: #fff; border-radius: 4px; border: 1px solid #4caf50;">
              <p style="margin: 0 0 10px 0; font-size: 13px; color: #333;">
                –°–∏—Å—Ç–µ–º–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –ø—ñ–¥–±–∏—Ä–∞—î –æ–ø—Ç–∏–º–∞–ª—å–Ω—ñ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ –Ω–∞ –æ—Å–Ω–æ–≤—ñ –≤–∞—à–æ–≥–æ —Ñ—ñ–¥–±–µ–∫—É. 
                –ü—ñ—Å–ª—è —Ç–µ—Å—Ç—É–≤–∞–Ω–Ω—è —Å–∫–∞–∂—ñ—Ç—å "–∫—Ä–∞—â–µ" –∞–±–æ "–≥—ñ—Ä—à–µ", —ñ —Å–∏—Å—Ç–µ–º–∞ –∑–≥–µ–Ω–µ—Ä—É—î –Ω–æ–≤—É –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—é.
              </p>
            </div>
            
            <!-- Current Session Info -->
            <div id="optimizationSessionInfo" style="margin-bottom: 15px; padding: 10px; background: #fff3cd; border-radius: 4px; border: 1px solid #ffc107; display: none;">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <strong style="color: #856404;">üìä –ü–æ—Ç–æ—á–Ω–∞ —Å–µ—Å—ñ—è:</strong>
                <span id="optimizationIteration" style="color: #856404; font-weight: 600;">–Ü—Ç–µ—Ä–∞—Ü—ñ—è: 0</span>
              </div>
              <div id="optimizationStats" style="font-size: 12px; color: #856404;">
                <div>‚úÖ –ö—Ä–∞—â–µ: <span id="optimizationBetterCount">0</span></div>
                <div>‚ùå –ì—ñ—Ä—à–µ: <span id="optimizationWorseCount">0</span></div>
                <div>‚öñÔ∏è –¢–∞–∫ —Å–∞–º–æ: <span id="optimizationSameCount">0</span></div>
              </div>
            </div>
            
            <!-- Current Config Display -->
            <div id="optimizationCurrentConfig" style="margin-bottom: 15px; padding: 10px; background: #fff; border-radius: 4px; border: 1px solid #ddd; display: none;">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                <strong style="color: #333;">üìã –ü–æ—Ç–æ—á–Ω–∞ –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—è –¥–ª—è —Ç–µ—Å—Ç—É–≤–∞–Ω–Ω—è:</strong>
                <span id="optimizationGenerationMethod" style="padding: 4px 8px; border-radius: 4px; font-size: 11px; font-weight: 600; display: none;"></span>
              </div>
              <div id="optimizationConfigChanges" style="margin-bottom: 8px; padding: 8px; background: #f0f8ff; border-radius: 4px; border-left: 3px solid #2196F3; display: none; font-size: 11px;"></div>
              <pre id="optimizationConfigJson" style="margin: 0; padding: 8px; background: #f5f5f5; border-radius: 4px; font-size: 11px; overflow-x: auto; max-height: 200px; overflow-y: auto;"></pre>
              <button type="button" onclick="applyOptimizationConfig()" style="margin-top: 8px; padding: 6px 12px; font-size: 12px; border-radius: 4px; background: #4caf50; color: white; border: none; cursor: pointer; font-weight: 600;">
                ‚úÖ –ó–∞—Å—Ç–æ—Å—É–≤–∞—Ç–∏ —Ü—ñ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏
              </button>
            </div>
            
            <!-- Controls -->
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; margin-bottom: 15px;">
              <button type="button" onclick="startOptimizationSession()" style="padding: 10px; font-size: 13px; border-radius: 4px; background: #2196F3; color: white; border: none; cursor: pointer; font-weight: 600;">
                üöÄ –ü–æ—á–∞—Ç–∏ —Å–µ—Å—ñ—é
              </button>
              <button type="button" onclick="getCurrentOptimizationConfig()" style="padding: 10px; font-size: 13px; border-radius: 4px; background: #FF9800; color: white; border: none; cursor: pointer; font-weight: 600;">
                üìã –û—Ç—Ä–∏–º–∞—Ç–∏ –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—é
              </button>
              <button type="button" onclick="sendOptimizationFeedback('better')" style="padding: 10px; font-size: 13px; border-radius: 4px; background: #4caf50; color: white; border: none; cursor: pointer; font-weight: 600;">
                ‚úÖ –ö—Ä–∞—â–µ
              </button>
              <button type="button" onclick="sendOptimizationFeedback('worse')" style="padding: 10px; font-size: 13px; border-radius: 4px; background: #f44336; color: white; border: none; cursor: pointer; font-weight: 600;">
                ‚ùå –ì—ñ—Ä—à–µ
              </button>
              <button type="button" onclick="sendOptimizationFeedback('same')" style="padding: 10px; font-size: 13px; border-radius: 4px; background: #FF9800; color: white; border: none; cursor: pointer; font-weight: 600;">
                ‚öñÔ∏è –¢–∞–∫ —Å–∞–º–æ
              </button>
              <button type="button" onclick="exportBestConfig()" style="padding: 10px; font-size: 13px; border-radius: 4px; background: #9C27B0; color: white; border: none; cursor: pointer; font-weight: 600;">
                üíæ –ï–∫—Å–ø–æ—Ä—Ç—É–≤–∞—Ç–∏ –Ω–∞–π–∫—Ä–∞—â—É
              </button>
              <button type="button" onclick="resetOptimizationSession()" style="padding: 10px; font-size: 13px; border-radius: 4px; background: #757575; color: white; border: none; cursor: pointer; font-weight: 600;">
                üîÑ –°–∫–∏–Ω—É—Ç–∏
              </button>
            </div>
            
            <!-- History -->
            <div id="optimizationHistory" style="margin-top: 15px; padding: 10px; background: #fff; border-radius: 4px; border: 1px solid #ddd; display: none;">
              <strong style="display: block; margin-bottom: 8px; color: #333;">üìú –û—Å—Ç–∞–Ω–Ω—ñ —Ç–µ—Å—Ç–∏:</strong>
              <div id="optimizationHistoryList" style="font-size: 11px; max-height: 150px; overflow-y: auto;"></div>
            </div>
          </div>
        </div>
        
        <!-- Notes Modal for Optimization Feedback -->
        <div id="optimizationNotesModal" style="display: none; position: fixed; z-index: 10000; left: 0; top: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); align-items: center; justify-content: center;">
          <div style="background: white; padding: 20px; border-radius: 8px; max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto;">
            <h3 style="margin-top: 0; margin-bottom: 15px; color: #333;">–î–æ–¥–∞—Ç–∫–æ–≤—ñ –Ω–æ—Ç–∞—Ç–∫–∏</h3>
            <p style="font-size: 13px; color: #666; margin-bottom: 10px;">–û–ø–∏—à—ñ—Ç—å, —â–æ —Å–∞–º–µ –±—É–ª–æ –∫—Ä–∞—â–µ/–≥—ñ—Ä—à–µ (–Ω–µ–æ–±–æ–≤'—è–∑–∫–æ–≤–æ):</p>
            <textarea id="optimizationNotesText" rows="5" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; font-family: inherit; resize: vertical;" placeholder="–ù–∞–ø—Ä–∏–∫–ª–∞–¥: –º–µ–Ω—à–µ –∑–∞–ª–∏—à–∫—ñ–≤ —ñ–Ω—à–æ–≥–æ —Å–ø—ñ–∫–µ—Ä–∞, –∫—Ä–∞—â–∞ —è–∫—ñ—Å—Ç—å –Ω–∞ –ø–æ—á–∞—Ç–∫—É —Ñ–∞–π–ª—É, —à–≤–∏–¥—à–∞ –æ–±—Ä–æ–±–∫–∞..."></textarea>
            <div style="margin-top: 15px; display: flex; gap: 10px; justify-content: flex-end;">
              <button type="button" onclick="closeNotesModal()" style="padding: 8px 16px; font-size: 13px; border-radius: 4px; background: #6c757d; color: white; border: none; cursor: pointer; font-weight: 600;">
                –°–∫–∞—Å—É–≤–∞—Ç–∏
              </button>
              <button type="button" onclick="submitNotesModal()" style="padding: 8px 16px; font-size: 13px; border-radius: 4px; background: #4caf50; color: white; border: none; cursor: pointer; font-weight: 600;">
                –í—ñ–¥–ø—Ä–∞–≤–∏—Ç–∏
              </button>
            </div>
          </div>
        </div>
        
        <!-- Status Section -->
        <div style="margin-bottom: 20px;">
          <label style="display: block; margin-bottom: 10px; font-weight: 600; color: #333;">üìä –°—Ç–∞—Ç—É—Å:</label>
          <div id="separationDebugStatus" style="padding: 15px; background: #f8f9fa; border-radius: 4px; font-family: monospace; font-size: 12px; min-height: 50px; border: 1px solid #e0e0e0;">
            –û—á—ñ–∫—É–≤–∞–Ω–Ω—è –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —Ñ–∞–π–ª—É...
          </div>
        </div>
        
        <!-- Original Audio Section -->
        <div id="separationDebugOriginalSection" style="display: none; margin-bottom: 20px; padding: 15px; background: #fff; border-radius: 6px; border: 2px solid #3498db;">
          <h3 style="margin-top: 0; margin-bottom: 15px; color: #3498db; font-size: 18px;">üéµ –û—Ä–∏–≥—ñ–Ω–∞–ª—å–Ω–∞ –¥–æ—Ä—ñ–∂–∫–∞</h3>
          <div id="separationDebugOriginalAudio" style="margin-bottom: 10px;">
            <!-- Audio player will be inserted here -->
          </div>
          <div id="separationDebugOriginalInfo" style="font-size: 12px; color: #666;"></div>
        </div>
        
        <!-- Separated Tracks Section -->
        <div id="separationDebugTracksSection" style="display: none;">
          <h3 style="margin-top: 0; margin-bottom: 15px; color: #27ae60; font-size: 18px;">üîÄ –†–æ–∑–¥—ñ–ª–µ–Ω—ñ —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∏</h3>
          <div id="separationDebugTracksContainer" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 20px;">
            <!-- Separated tracks will be inserted here -->
          </div>
        </div>
        
        <!-- Progress Log Section -->
        <div style="margin-top: 20px;">
          <label style="display: block; margin-bottom: 10px; font-weight: 600; color: #333;">üìù –õ–æ–≥ –ø—Ä–æ—Ü–µ—Å—É:</label>
          <textarea id="separationDebugLog" readonly style="width: 100%; height: 200px; font-family: monospace; font-size: 11px; padding: 10px; border: 1px solid #ddd; border-radius: 4px; resize: vertical; background: #f8f9fa;"></textarea>
        </div>
      </div>
      <div class="debug-modal-footer debug" style="padding: 15px 20px; border-top: 1px solid #e0e0e0;">
        <button class="btn btn-primary debug" id="runSeparationDebugBtn" onclick="runSeparationDebug()" style="padding: 8px 16px; font-size: 14px; border-radius: 6px; background: #3498db; color: white; border: none; cursor: pointer; font-weight: 600; margin-right: 10px;">
          ‚ñ∂Ô∏è –ó–∞–ø—É—Å—Ç–∏—Ç–∏ —Ä–æ–∑–¥—ñ–ª–µ–Ω–Ω—è
        </button>
        <button class="btn btn-secondary debug" onclick="closeSeparationDebugModal()" style="padding: 8px 16px; font-size: 14px; border-radius: 6px; background: #95a5a6; color: white; border: none; cursor: pointer; font-weight: 600;">
          –ó–∞–∫—Ä–∏—Ç–∏
        </button>
      </div>
    </div>
  </div>
  
  <!-- Global Variables Modal -->
  <div id="globalVariablesModal" class="debug-modal debug" style="display: none;" onclick="if(event.target === this) closeGlobalVariablesModal()">
    <div class="debug-modal-content debug" onclick="event.stopPropagation()" style="max-width: 800px;">
      <div class="debug-modal-header debug">
        <h2 class="debug">üìä Global Variables</h2>
        <button class="debug-modal-close debug" onclick="closeGlobalVariablesModal()">&times;</button>
      </div>
      <div class="debug-modal-body debug">
        <div style="margin-bottom: 15px;">
          <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #333;">Current Table (JSON):</label>
          <textarea id="globalVariablesCurrentTable" class="debug" readonly style="width: 100%; height: 500px; font-family: monospace; font-size: 12px; padding: 10px; border: 1px solid #ddd; border-radius: 4px; resize: vertical;"></textarea>
        </div>
      </div>
      <div class="debug-modal-footer debug">
        <button class="btn btn-primary debug" onclick="copyGlobalVariable()" style="padding: 8px 16px; font-size: 14px; border-radius: 6px; background: #27ae60; color: white; border: none; cursor: pointer; font-weight: 600;">
          üìã Copy
        </button>
        <button class="btn btn-primary debug" onclick="refreshGlobalVariables()" style="padding: 8px 16px; font-size: 14px; border-radius: 6px; background: #3498db; color: white; border: none; cursor: pointer; font-weight: 600; margin-left: 10px;">
          üîÑ Refresh
        </button>
        <button class="btn btn-secondary debug" onclick="closeGlobalVariablesModal()" style="padding: 8px 16px; font-size: 14px; border-radius: 6px; background: #95a5a6; color: white; border: none; cursor: pointer; font-weight: 600; margin-left: 10px;">
          Close
        </button>
      </div>
    </div>
  </div>
  
  <script>
    // ============================================
    // Console Log Capture System
    // ============================================
    // –ì–ª–æ–±–∞–ª—å–Ω–∏–π –º–∞—Å–∏–≤ –¥–ª—è –∑–±–µ—Ä—ñ–≥–∞–Ω–Ω—è –ª–æ–≥—ñ–≤ –∫–æ–Ω—Å–æ–ª—ñ
    window.consoleLogs = [];
    window.consoleLogCaptureEnabled = true;
    
    // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è —Ñ–æ—Ä–º–∞—Ç—É–≤–∞–Ω–Ω—è –æ–±'—î–∫—Ç—ñ–≤ —É —Ä—è–¥–æ–∫
    function formatLogArgs(args) {
      return Array.from(args).map(arg => {
        if (typeof arg === 'object' && arg !== null) {
          try {
            return JSON.stringify(arg, null, 2);
          } catch (e) {
            return String(arg);
          }
        }
        return String(arg);
      }).join(' ');
    }
    
    // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –æ—Ä–∏–≥—ñ–Ω–∞–ª—å–Ω—ñ –º–µ—Ç–æ–¥–∏ console
    const originalConsole = {
      log: console.log.bind(console),
      error: console.error.bind(console),
      warn: console.warn.bind(console),
      info: console.info.bind(console),
      debug: console.debug.bind(console)
    };
    
    // –ü–µ—Ä–µ—Ö–æ–ø–ª—é—î–º–æ console.log
    console.log = function(...args) {
      if (window.consoleLogCaptureEnabled) {
        const timestamp = new Date().toISOString();
        const logEntry = {
          type: 'log',
          timestamp: timestamp,
          message: formatLogArgs(args)
        };
        window.consoleLogs.push(logEntry);
        // –û–±–º–µ–∂—É—î–º–æ —Ä–æ–∑–º—ñ—Ä –º–∞—Å–∏–≤—É (–∑–±–µ—Ä—ñ–≥–∞—î–º–æ –æ—Å—Ç–∞–Ω–Ω—ñ 1000 –∑–∞–ø–∏—Å—ñ–≤)
        if (window.consoleLogs.length > 1000) {
          window.consoleLogs = window.consoleLogs.slice(-1000);
        }
      }
      originalConsole.log(...args);
    };
    
    // –ü–µ—Ä–µ—Ö–æ–ø–ª—é—î–º–æ console.error
    console.error = function(...args) {
      if (window.consoleLogCaptureEnabled) {
        const timestamp = new Date().toISOString();
        const logEntry = {
          type: 'error',
          timestamp: timestamp,
          message: formatLogArgs(args)
        };
        window.consoleLogs.push(logEntry);
        if (window.consoleLogs.length > 1000) {
          window.consoleLogs = window.consoleLogs.slice(-1000);
        }
      }
      originalConsole.error(...args);
    };
    
    // –ü–µ—Ä–µ—Ö–æ–ø–ª—é—î–º–æ console.warn
    console.warn = function(...args) {
      if (window.consoleLogCaptureEnabled) {
        const timestamp = new Date().toISOString();
        const logEntry = {
          type: 'warn',
          timestamp: timestamp,
          message: formatLogArgs(args)
        };
        window.consoleLogs.push(logEntry);
        if (window.consoleLogs.length > 1000) {
          window.consoleLogs = window.consoleLogs.slice(-1000);
        }
      }
      originalConsole.warn(...args);
    };
    
    // –ü–µ—Ä–µ—Ö–æ–ø–ª—é—î–º–æ console.info
    console.info = function(...args) {
      if (window.consoleLogCaptureEnabled) {
        const timestamp = new Date().toISOString();
        const logEntry = {
          type: 'info',
          timestamp: timestamp,
          message: formatLogArgs(args)
        };
        window.consoleLogs.push(logEntry);
        if (window.consoleLogs.length > 1000) {
          window.consoleLogs = window.consoleLogs.slice(-1000);
        }
      }
      originalConsole.info(...args);
    };
    
    // –ü–µ—Ä–µ—Ö–æ–ø–ª—é—î–º–æ console.debug
    console.debug = function(...args) {
      if (window.consoleLogCaptureEnabled) {
        const timestamp = new Date().toISOString();
        const logEntry = {
          type: 'debug',
          timestamp: timestamp,
          message: formatLogArgs(args)
        };
        window.consoleLogs.push(logEntry);
        if (window.consoleLogs.length > 1000) {
          window.consoleLogs = window.consoleLogs.slice(-1000);
        }
      }
      originalConsole.debug(...args);
    };
    
    // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –æ—Ç—Ä–∏–º–∞–Ω–Ω—è –ª–æ–≥—ñ–≤ —É —Ñ–æ—Ä–º–∞—Ç–æ–≤–∞–Ω–æ–º—É –≤–∏–≥–ª—è–¥—ñ
    window.getFormattedConsoleLogs = function(filterType = null) {
      const logs = filterType 
        ? window.consoleLogs.filter(log => log.type === filterType)
        : window.consoleLogs;
      
      return logs.map(log => {
        const time = new Date(log.timestamp).toLocaleTimeString();
        const typePrefix = log.type.toUpperCase().padEnd(5);
        return `[${time}] ${typePrefix} ${log.message}`;
      }).join('\n');
    };
    
    // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –æ—á–∏—â–µ–Ω–Ω—è –ª–æ–≥—ñ–≤
    window.clearConsoleLogs = function() {
      window.consoleLogs = [];
    };
    
    console.log('üìã Console log capture system initialized');
    const form = document.getElementById('diarizationForm');
    const submitBtn = document.getElementById('submitBtn');
    const spinner = document.getElementById('spinner');
    const btnText = submitBtn.querySelector('.btn-text');
    const errorMessage = document.getElementById('errorMessage');
    const resultsContainer = document.getElementById('resultsContainer');
    const progressSection = document.getElementById('progressSection');
    const progressSteps = document.getElementById('progressSteps');
    let xhr = null;
    let lastResult = null;
    let currentAnalysisData = null; // –ì–ª–æ–±–∞–ª—å–Ω–∞ –∑–º—ñ–Ω–Ω–∞ –¥–ª—è –∑–±–µ—Ä—ñ–≥–∞–Ω–Ω—è –¥–∞–Ω–∏—Ö –∞–Ω–∞–ª—ñ–∑—É
    window.currentTable = null; // Stores JSON from analyzeDialogue() after Apply
    
    // Load demo configuration from server
    let demoConfig = {
      speakerCount: 2,
      pipelineMode: 'mode3',
      llmMode: 'smart',
      transcriptionEngine: 'speechmatics',
      isLocal: false
    };
    
    async function loadDemoConfig() {
      try {
        const response = await fetch('/api/demo-config');
        if (response.ok) {
          demoConfig = await response.json();
          console.log('üîç [DEMO] Loaded config from server:', demoConfig);
        } else {
          console.warn('‚ö†Ô∏è [DEMO] Failed to load demo config, status:', response.status);
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è [DEMO] Failed to load demo config, using defaults:', error);
      }
    }
    
    // Load config on page load
    loadDemoConfig();
    
    // Listen for messages from audio generator
    window.addEventListener('message', async (event) => {
      // Verify origin for security (optional, adjust as needed)
      // if (event.origin !== window.location.origin) return;
      
      if (event.data && event.data.type === 'AUDIO_GENERATOR_FILE') {
        console.log('üì• Received audio and dialogue from generator');
        
        try {
          const { file, dialogue } = event.data;
          
          // Convert base64 to File
          const byteCharacters = atob(file.data);
          const byteNumbers = new Array(byteCharacters.length);
          for (let i = 0; i < byteCharacters.length; i++) {
            byteNumbers[i] = byteCharacters.charCodeAt(i);
          }
          const byteArray = new Uint8Array(byteNumbers);
          const blob = new Blob([byteArray], { type: file.type });
          const audioFile = new File([blob], file.name, { type: file.type });
          
          // Set the file in the file input
          const audioFileInput = document.getElementById('audioFile');
          const dataTransfer = new DataTransfer();
          dataTransfer.items.add(audioFile);
          audioFileInput.files = dataTransfer.files;
          
          // Store dialogue text if available
          if (dialogue) {
            // Store dialogue in a way that can be accessed later
            window.generatorDialogue = dialogue;
            console.log('üìù Stored dialogue text:', dialogue.length, 'characters');
            
            // Optionally show a notification
            const notification = document.createElement('div');
            notification.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #2ecc71; color: white; padding: 15px 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); z-index: 10000; max-width: 400px;';
            notification.innerHTML = `
              <div style="font-weight: 600; margin-bottom: 5px;">‚úì Audio and Dialogue Loaded</div>
              <div style="font-size: 13px;">Audio file and dialogue text have been loaded. You can now process the audio.</div>
            `;
            document.body.appendChild(notification);
            setTimeout(() => {
              notification.style.opacity = '0';
              notification.style.transition = 'opacity 0.3s';
              setTimeout(() => notification.remove(), 300);
            }, 3000);
          }
          
          // Close generator modal if open
          closeGeneratorModal();
          
          console.log('‚úì Audio file loaded into form:', file.name);
        } catch (error) {
          console.error('Error processing generator file:', error);
          alert('Error loading audio from generator: ' + error.message);
        }
      }
    });
    
    // Initialize progress steps
    function initProgressSteps() {
      progressSteps.innerHTML = `
        <div class="progress-step" data-step="1">
          <div class="step-number">1</div>
          <div class="step-content">
            <div class="step-title">Initial Audio Analysis</div>
            <div class="step-status">Waiting...</div>
          </div>
        </div>
        <div class="progress-step" data-step="2">
          <div class="step-number">2</div>
          <div class="step-content">
            <div class="step-title">Speaker Separation</div>
            <div class="step-status">Waiting...</div>
          </div>
        </div>
        <div class="progress-step" data-step="3">
          <div class="step-number">3</div>
          <div class="step-content">
            <div class="step-title">Voice Track Transcription & Role Analysis</div>
            <div class="step-status">Waiting...</div>
          </div>
        </div>
        <div class="progress-step" data-step="5">
          <div class="step-number">5</div>
          <div class="step-content">
            <div class="step-title">Overlap Correction</div>
            <div class="step-status">Waiting...</div>
          </div>
        </div>
      `;
    }
    
    // Update progress step
    function updateProgressStep(step, status, description) {
      const stepEl = progressSteps.querySelector(`[data-step="${step}"]`);
      if (!stepEl) return;
      
      const statusEl = stepEl.querySelector('.step-status');
      const stepNumber = stepEl.querySelector('.step-number');
      
      stepEl.className = `progress-step step-${status}`;
      statusEl.textContent = description || status;
      
      if (status === 'completed') {
        stepNumber.textContent = '‚úì';
        stepNumber.style.background = '#2ecc71';
      } else if (status === 'processing') {
        stepNumber.style.background = '#3498db';
      }
    }
    
    // Extract segments from response
    function extractSegments(data) {
      console.log('üîç [extractSegments] Called with:', {
        hasData: !!data,
        dataType: typeof data,
        dataKeys: data ? Object.keys(data) : []
      });
      
      if (!data) {
        console.warn('‚ö†Ô∏è [extractSegments] Data is null or undefined');
        return { originalSegments: [], correctedSegments: [] };
      }
      
      let originalSegments = [];
      let correctedSegments = [];
      
      // Extract from primaryDiarization
      if (data.primaryDiarization) {
        console.log('üîç [extractSegments] Found primaryDiarization:', {
          hasRecordings: !!data.primaryDiarization.recordings,
          recordingsIsArray: Array.isArray(data.primaryDiarization.recordings),
          recordingsLength: data.primaryDiarization.recordings?.length || 0,
          hasSegments: !!data.primaryDiarization.segments,
          segmentsIsArray: Array.isArray(data.primaryDiarization.segments),
          segmentsLength: data.primaryDiarization.segments?.length || 0
        });
        
        const primary = data.primaryDiarization;
        if (primary.recordings && Array.isArray(primary.recordings) && primary.recordings[0]) {
          const recording = primary.recordings[0];
          console.log('üîç [extractSegments] Processing recording:', {
            hasResults: !!recording.results,
            resultsKeys: recording.results ? Object.keys(recording.results) : []
          });
          
          if (recording.results) {
            const resultKey = Object.keys(recording.results)[0];
            console.log('üîç [extractSegments] Using resultKey:', resultKey);
            
            if (recording.results[resultKey] && recording.results[resultKey].segments) {
              originalSegments = Array.isArray(recording.results[resultKey].segments) 
                ? recording.results[resultKey].segments 
                : [];
              console.log('‚úÖ [extractSegments] Extracted originalSegments from recordings:', originalSegments.length);
            } else {
              console.warn('‚ö†Ô∏è [extractSegments] No segments in recording.results[' + resultKey + ']');
            }
          }
        } else if (primary.segments) {
          originalSegments = Array.isArray(primary.segments) ? primary.segments : [];
          console.log('‚úÖ [extractSegments] Extracted originalSegments from primary.segments:', originalSegments.length);
        } else {
          console.warn('‚ö†Ô∏è [extractSegments] primaryDiarization has no recordings or segments');
        }
      } else {
        console.warn('‚ö†Ô∏è [extractSegments] No primaryDiarization in data');
      }
      
      // Extract from correctedDiarization
      if (data.correctedDiarization) {
        console.log('üîç [extractSegments] Found correctedDiarization:', {
          hasRecordings: !!data.correctedDiarization.recordings,
          recordingsIsArray: Array.isArray(data.correctedDiarization.recordings),
          recordingsLength: data.correctedDiarization.recordings?.length || 0,
          hasSegments: !!data.correctedDiarization.segments,
          segmentsIsArray: Array.isArray(data.correctedDiarization.segments),
          segmentsLength: data.correctedDiarization.segments?.length || 0
        });
        
        const corrected = data.correctedDiarization;
        if (corrected.recordings && Array.isArray(corrected.recordings) && corrected.recordings[0]) {
          const recording = corrected.recordings[0];
          if (recording.results && recording.results['overlap-corrected']) {
            correctedSegments = Array.isArray(recording.results['overlap-corrected'].segments)
              ? recording.results['overlap-corrected'].segments
              : [];
            console.log('‚úÖ [extractSegments] Extracted correctedSegments from recordings:', correctedSegments.length);
          } else {
            console.warn('‚ö†Ô∏è [extractSegments] No overlap-corrected segments in recording.results');
          }
        } else if (corrected.segments) {
          correctedSegments = Array.isArray(corrected.segments) ? corrected.segments : [];
          console.log('‚úÖ [extractSegments] Extracted correctedSegments from corrected.segments:', correctedSegments.length);
        } else {
          console.warn('‚ö†Ô∏è [extractSegments] correctedDiarization has no recordings or segments');
        }
      } else {
        console.warn('‚ö†Ô∏è [extractSegments] No correctedDiarization in data');
      }
      
      // Ensure we always return arrays
      const result = { 
        originalSegments: Array.isArray(originalSegments) ? originalSegments : [], 
        correctedSegments: Array.isArray(correctedSegments) ? correctedSegments : [] 
      };
      
      console.log('‚úÖ [extractSegments] Final result:', {
        originalSegmentsCount: result.originalSegments.length,
        correctedSegmentsCount: result.correctedSegments.length
      });
      
      return result;
    }
    
    // Extract Standard diarization segments split by Speaker 0 and Speaker 1
    function extractStandardSegments(data) {
      const segments = [];
      
      if (data.primaryDiarization) {
        const primary = data.primaryDiarization;
        let standardSegments = [];
        
        if (primary.recordings && Array.isArray(primary.recordings) && primary.recordings[0]) {
          const recording = primary.recordings[0];
          if (recording.results) {
            const resultKey = Object.keys(recording.results)[0];
            if (recording.results[resultKey] && recording.results[resultKey].segments) {
              standardSegments = recording.results[resultKey].segments;
            }
          }
        } else if (primary.segments) {
          standardSegments = primary.segments;
        }
        
        // Split by speaker
        standardSegments.forEach(segment => {
          const speaker = (segment.speaker || segment.speaker_label || '').toUpperCase();
          if (speaker === 'SPEAKER_00' || speaker === 'SPEAKER_0' || speaker === '0') {
            segments.push({ ...segment, _column: 'speaker0' });
          } else if (speaker === 'SPEAKER_01' || speaker === 'SPEAKER_1' || speaker === '1') {
            segments.push({ ...segment, _column: 'speaker1' });
          }
        });
      }
      
      return segments;
    }
    
    // Extract NextLevel diarization segments from markdown table or correctedDiarization
    function extractNextLevelSegments(data) {
      const segments = [];
      
      // Try to extract from markdown table first
      if (data.markdownTable) {
        const tableLines = data.markdownTable.split('\n').filter(line => line.trim() && line.includes('|'));
        
        // Skip header and separator rows (first 2 lines)
        for (let i = 2; i < tableLines.length; i++) {
          const cells = tableLines[i].split('|').map(c => c.trim()).filter(c => c);
          if (cells.length >= 5) {
            const speaker = cells[1] || '';
            const text = cells[2] || '';
            const start = parseFloat(cells[3]) || 0;
            const end = parseFloat(cells[4]) || 0;
            
            if (text && (speaker.toLowerCase() === 'agent' || speaker.toLowerCase() === 'client')) {
              const role = speaker.toLowerCase();
              segments.push({
                text: text.trim(),
                start: start,
                end: end,
                role: role,
                speaker: role === 'agent' ? 'Agent' : 'Client',
                _column: role
              });
            }
          }
        }
        
        // Log role distribution after parsing markdown table
        if (segments.length > 0) {
          const agentCount = segments.filter(s => s._column === 'agent').length;
          const clientCount = segments.filter(s => s._column === 'client').length;
          
          console.log('üìä [extractNextLevelSegments] Role distribution:', {
            total: segments.length,
            agent: agentCount,
            client: clientCount,
            ratio: agentCount > 0 ? (clientCount / agentCount).toFixed(2) : 'N/A'
          });
          
          if (agentCount > 0 && clientCount === 0) {
            console.warn('‚ö†Ô∏è [extractNextLevelSegments] WARNING: All segments are Agent!');
          } else if (clientCount > 0 && agentCount === 0) {
            console.warn('‚ö†Ô∏è [extractNextLevelSegments] WARNING: All segments are Client!');
          }
        }
      }
      
      // Fallback: extract from correctedDiarization with role mapping
      if (segments.length === 0 && data.correctedDiarization) {
        const corrected = data.correctedDiarization;
        let correctedSegments = [];
        
        if (corrected.recordings && Array.isArray(corrected.recordings) && corrected.recordings[0]) {
          const recording = corrected.recordings[0];
          if (recording.results && recording.results['overlap-corrected']) {
            correctedSegments = recording.results['overlap-corrected'].segments || [];
          }
        } else if (corrected.segments) {
          correctedSegments = corrected.segments;
        }
        
        console.log('üîç [extractNextLevelSegments] Fallback: processing correctedSegments:', {
          correctedSegmentsCount: correctedSegments.length,
          sampleSegment: correctedSegments[0] || null
        });
        
        // Map segments to Agent/Client based on role
        correctedSegments.forEach(segment => {
          const role = normalizeSpeakerName(segment.role || segment.role_label || segment.speakerRole || '');
          if (role === 'agent' || role === 'client') {
            segments.push({
              ...segment,
              role: role,
              speaker: role === 'agent' ? 'Agent' : 'Client',
              _column: role
            });
          }
        });
        
        console.log('‚úÖ [extractNextLevelSegments] Fallback: extracted segments:', {
          totalSegments: segments.length,
          agentCount: segments.filter(s => s._column === 'agent').length,
          clientCount: segments.filter(s => s._column === 'client').length
        });
      }
      
      // If still no segments, try to extract from markdown table with SPEAKER_XX format
      // and map to Agent/Client based on role analysis or voice tracks
      if (segments.length === 0 && data.markdownTable) {
        console.log('üîç [extractNextLevelSegments] Trying to extract from markdown with SPEAKER_XX format...');
        const tableLines = data.markdownTable.split('\n').filter(line => line.trim() && line.includes('|'));
        
        // Try to get role mapping from voiceTracks or correctedDiarization
        let speaker0Role = null;
        let speaker1Role = null;
        
        if (data.voiceTracks && Array.isArray(data.voiceTracks) && data.voiceTracks.length >= 2) {
          speaker0Role = normalizeSpeakerName(data.voiceTracks[0]?.roleAnalysis?.role || '');
          speaker1Role = normalizeSpeakerName(data.voiceTracks[1]?.roleAnalysis?.role || '');
        }
        
        // Skip header and separator rows
        for (let i = 2; i < tableLines.length; i++) {
          const cells = tableLines[i].split('|').map(c => c.trim()).filter(c => c);
          if (cells.length >= 5) {
            const speaker = cells[1] || '';
            const text = cells[2] || '';
            const start = parseFloat(cells[3]) || 0;
            const end = parseFloat(cells[4]) || 0;
            
            if (text) {
              let role = null;
              const speakerUpper = speaker.toUpperCase();
              
              // Map SPEAKER_00/SPEAKER_01 to Agent/Client based on role analysis
              if (speakerUpper === 'SPEAKER_00' || speakerUpper === 'SPEAKER_0' || speakerUpper === '0') {
                role = speaker0Role || 'agent'; // Default to agent if unknown
              } else if (speakerUpper === 'SPEAKER_01' || speakerUpper === 'SPEAKER_1' || speakerUpper === '1') {
                role = speaker1Role || 'client'; // Default to client if unknown
              } else if (speaker.toLowerCase() === 'agent' || speaker.toLowerCase() === 'client') {
                role = speaker.toLowerCase();
              }
              
              if (role === 'agent' || role === 'client') {
                segments.push({
                  text: text.trim(),
                  start: start,
                  end: end,
                  role: role,
                  speaker: role === 'agent' ? 'Agent' : 'Client',
                  _column: role
                });
              }
            }
          }
        }
        
        console.log('‚úÖ [extractNextLevelSegments] Extracted from SPEAKER_XX format:', {
          totalSegments: segments.length,
          agentCount: segments.filter(s => s._column === 'agent').length,
          clientCount: segments.filter(s => s._column === 'client').length
        });
      }
      
      return segments;
    }
    
    // Get speaker label
    function getSpeakerLabel(segment) {
      if (segment.role === 'operator' || segment.role === 'agent') {
        return 'Agent';
      } else if (segment.role === 'client' || segment.role === 'customer') {
        return 'Client';
      }
      return segment.speaker || 'Unknown';
    }
    
    function formatSeconds(seconds) {
      if (seconds === null || seconds === undefined || isNaN(seconds)) {
        return '‚Äî';
      }
      const totalSeconds = Math.max(0, seconds);
      const mins = Math.floor(totalSeconds / 60);
      const secs = (totalSeconds % 60).toFixed(2).padStart(5, '0');
      return `${mins}:${secs}`;
    }
    
    function determineStandardColumn(segment) {
      const speaker = (segment?.speaker || segment?.speaker_label || '').toUpperCase();
      return speaker === 'SPEAKER_01' ? 'speaker1' : 'speaker0';
    }
    
    function determineNextLevelColumn(segment) {
      const roleNorm = normalizeSpeakerName(segment?.role || segment?.role_label || segment?.speakerRole);
      return roleNorm === 'client' ? 'client' : 'agent';
    }
    
    // Extract original segments from uploaded dialogue text
    // Normalize dialogue format from various input formats to unified structure
    function normalizeDialogueFormat(originalText) {
      if (!originalText || typeof originalText !== 'string') {
        return [];
      }
      
      const normalizedReplicas = [];
      
      // Try to parse as JSON first
      try {
        const jsonData = JSON.parse(originalText);
        if (Array.isArray(jsonData)) {
          // Array format: [{role: "agent", text: "..."}, ...]
          jsonData.forEach((item, index) => {
            if (item && typeof item === 'object') {
              const role = normalizeRole(item.role || item.speaker || item.character || '');
              const text = item.text || item.content || item.dialogue || item.replica || '';
              if (text && text.trim()) {
                normalizedReplicas.push({
                  role: role,
                  text: text.trim(),
                  lineIndex: index,
                  raw: item
                });
              }
            }
          });
          if (normalizedReplicas.length > 0) {
            return normalizedReplicas;
          }
        } else if (typeof jsonData === 'object') {
          // Object format: {agent: [...], client: [...]} or {dialogues: [...]}
          if (jsonData.dialogues && Array.isArray(jsonData.dialogues)) {
            jsonData.dialogues.forEach((item, index) => {
              const role = normalizeRole(item.role || item.speaker || '');
              const text = item.text || item.content || '';
              if (text && text.trim()) {
                normalizedReplicas.push({
                  role: role,
                  text: text.trim(),
                  lineIndex: index,
                  raw: item
                });
              }
            });
          } else {
            // Try to find arrays with role names
            Object.keys(jsonData).forEach(key => {
              const normalizedKey = normalizeRole(key);
              if (normalizedKey && Array.isArray(jsonData[key])) {
                jsonData[key].forEach((text, index) => {
                  if (typeof text === 'string' && text.trim()) {
                    normalizedReplicas.push({
                      role: normalizedKey,
                      text: text.trim(),
                      lineIndex: normalizedReplicas.length,
                      raw: { role: key, text: text }
                    });
                  }
                });
              }
            });
          }
          if (normalizedReplicas.length > 0) {
            return normalizedReplicas;
          }
        }
      } catch (e) {
        // Not JSON, continue with text parsing
      }
      
      // Parse as text format
      const lines = originalText.split('\n').filter(line => line.trim());
      
      lines.forEach((line, index) => {
        const trimmed = line.trim();
        if (!trimmed) return;
        
        // Pattern 1: "Agent: text" or "Client: text" or "Speaker 1: text"
        let match = trimmed.match(/^(Agent|Client|Operator|Support|Customer|User|Speaker\s*[01]|SPEAKER_0[01]|Speaker\s*[01]):\s*(.+)$/i);
        if (match) {
          const role = normalizeRole(match[1]);
          const text = match[2].trim();
          if (text) {
            normalizedReplicas.push({
              role: role,
              text: text,
              lineIndex: index,
              raw: { line: trimmed }
            });
            return;
          }
        }
        
        // Pattern 2: Numbered format "1. Agent: text" or "1) Agent: text"
        match = trimmed.match(/^\d+[.)]\s*(Agent|Client|Operator|Support|Customer|User|Speaker\s*[01]|SPEAKER_0[01]):\s*(.+)$/i);
        if (match) {
          const role = normalizeRole(match[1]);
          const text = match[2].trim();
          if (text) {
            normalizedReplicas.push({
              role: role,
              text: text,
              lineIndex: index,
              raw: { line: trimmed }
            });
            return;
          }
        }
        
        // Pattern 3: Markdown format "- Agent: text" or "* Client: text"
        match = trimmed.match(/^[-*]\s*(Agent|Client|Operator|Support|Customer|User|Speaker\s*[01]|SPEAKER_0[01]):\s*(.+)$/i);
        if (match) {
          const role = normalizeRole(match[1]);
          const text = match[2].trim();
          if (text) {
            normalizedReplicas.push({
              role: role,
              text: text,
              lineIndex: index,
              raw: { line: trimmed }
            });
            return;
          }
        }
        
        // Pattern 4: Just text without explicit role
        // –î–æ–¥–∞—î–º–æ —Ä–µ–ø–ª—ñ–∫—É –Ω–∞–≤—ñ—Ç—å –±–µ–∑ —è–≤–Ω–æ—ó —Ä–æ–ª—ñ (–∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–∏–π –ø–∞—Ç–µ—Ä–Ω)
        if (normalizedReplicas.length > 0) {
          const lastRole = normalizedReplicas[normalizedReplicas.length - 1].role;
          // –Ø–∫—â–æ –ø–æ–ø–µ—Ä–µ–¥–Ω—è —Ä–µ–ø–ª—ñ–∫–∞ –±—É–ª–∞ agent, —Ü—è –º–æ–∂–µ –±—É—Ç–∏ client (–∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–∏–π –ø–∞—Ç–µ—Ä–Ω)
          const inferredRole = lastRole === 'agent' ? 'client' : lastRole === 'client' ? 'agent' : null;
          normalizedReplicas.push({
            role: inferredRole,
            text: trimmed,
            lineIndex: index,
            raw: { line: trimmed, inferred: true }
          });
        } else {
          // –Ø–∫—â–æ —Ü–µ –ø–µ—Ä—à–∞ —Ä–µ–ø–ª—ñ–∫–∞ –±–µ–∑ —Ä–æ–ª—ñ, –¥–æ–¥–∞—î–º–æ —ó—ó –∑ null —Ä–æ–ª–ª—é
          normalizedReplicas.push({
            role: null,
            text: trimmed,
            lineIndex: index,
            raw: { line: trimmed }
          });
        }
      });
      
      return normalizedReplicas;
    }
    
    // Normalize role names to 'agent' or 'client'
    function normalizeRole(roleString) {
      if (!roleString || typeof roleString !== 'string') {
        return null;
      }
      
      const normalized = roleString.trim().toLowerCase();
      
      // Agent synonyms
      const agentSynonyms = ['agent', 'operator', 'support', 'representative', 'assistant', 'staff', 
                             'speaker 0', 'speaker0', 'speaker_00', 'speaker_0', 'speaker 00'];
      if (agentSynonyms.some(syn => normalized.includes(syn) || normalized === syn)) {
        return 'agent';
      }
      
      // Client synonyms
      const clientSynonyms = ['client', 'customer', 'user', 'caller', 'speaker 1', 'speaker1', 
                              'speaker_01', 'speaker_1', 'speaker 01'];
      if (clientSynonyms.some(syn => normalized.includes(syn) || normalized === syn)) {
        return 'client';
      }
      
      // Try to match by number
      if (normalized.match(/speaker\s*0|speaker_0/)) {
        return 'agent';
      }
      if (normalized.match(/speaker\s*1|speaker_1/)) {
        return 'client';
      }
      
      return null; // Unknown role
    }
    
    function extractOriginalSegments(originalText, diarizationSegments = []) {
      if (!originalText || typeof originalText !== 'string') {
        return [];
      }
      
      // Use normalized format
      const normalizedReplicas = normalizeDialogueFormat(originalText);
      
      const segments = [];
      const lines = originalText.split('\n').filter(line => line.trim());
      
      // Try to parse different formats
      // Format 1: "Speaker 1: text" or "Agent: text" or "Client: text"
      // Format 2: "1: text" or "SPEAKER_00: text"
      // Format 3: Just lines of dialogue (will need to match with diarization)
      
      let currentTime = 0;
      const avgSegmentDuration = diarizationSegments.length > 0 
        ? diarizationSegments.reduce((sum, seg) => {
            const duration = (parseFloat(seg.end) || 0) - (parseFloat(seg.start) || 0);
            return sum + duration;
          }, 0) / diarizationSegments.length
        : 3.0; // Default 3 seconds per segment
      
      // Convert normalized replicas to segments format (for backward compatibility)
      // Note: These segments don't have accurate timestamps - they'll be matched via LLM
      normalizedReplicas.forEach((replica, index) => {
        // Try to find matching diarization segment by text similarity (fallback, not primary method)
          let matchedSegment = null;
          let bestSimilarity = 0;
          
          for (const diarSeg of diarizationSegments) {
            const diarText = (diarSeg.text || '').trim().toLowerCase();
          const origText = replica.text.toLowerCase();
            
          // Simple similarity check (will be overridden by LLM matching)
            const similarity = calculateTextSimilarity(origText, diarText);
            if (similarity > bestSimilarity && similarity > 0.3) {
              bestSimilarity = similarity;
              matchedSegment = diarSeg;
            }
          }
          
          const start = matchedSegment ? parseFloat(matchedSegment.start) || currentTime : currentTime;
          const end = matchedSegment ? parseFloat(matchedSegment.end) || (start + avgSegmentDuration) : (start + avgSegmentDuration);
          
          segments.push({
          text: replica.text,
            start: start,
            end: end,
          role: replica.role, // Normalized role: 'agent' or 'client'
          speaker: replica.role === 'agent' ? 'SPEAKER_00' : 'SPEAKER_01',
            _column: 'original',
          raw: replica.raw || { line: replica.text, index: replica.lineIndex },
          normalized: true // Flag to indicate this was normalized
          });
          
          currentTime = end;
      });
      
      return segments;
    }
    
    // Normalize text for matching (same as in textHighlighting.js)
    function normalizeTextForMatching(text) {
      if (!text || typeof text !== 'string') return '';
      return text
        .toLowerCase()
        .replace(/[^\w\s]/g, ' ')
        .replace(/\s+/g, ' ')
        .trim();
    }
    
    // Find phrase positions in text (similar to textHighlighting.js)
    function findPhrasePositions(text, phrase, tolerance = 0.8) {
      const positions = [];
      const normalizedText = normalizeTextForMatching(text);
      const normalizedPhrase = normalizeTextForMatching(phrase);
      
      if (!normalizedPhrase || normalizedPhrase.length < 3) return positions;
      
      // Try exact match first
      let index = normalizedText.indexOf(normalizedPhrase);
      if (index !== -1) {
        // Find corresponding position in original text
        const words = text.split(/(\s+)/);
        let charIndex = 0;
        let wordStart = 0;
        
        for (let i = 0; i < words.length; i++) {
          const word = words[i];
          const normalizedWord = normalizeTextForMatching(word);
          
          if (charIndex <= index && index < charIndex + normalizedWord.length) {
            wordStart = text.indexOf(word, wordStart);
            positions.push({
              start: wordStart,
              end: wordStart + word.length,
              phrase: phrase
            });
            break;
          }
          
          charIndex += normalizedWord.length;
          if (i < words.length - 1) {
            charIndex += 1; // space
          }
        }
      }
      
      // If no exact match, try word-based similarity
      if (positions.length === 0) {
        const phraseWords = normalizedPhrase.split(/\s+/).filter(w => w.length > 2);
        const textWords = normalizedText.split(/\s+/);
        
        for (let i = 0; i <= textWords.length - phraseWords.length; i++) {
          const window = textWords.slice(i, i + phraseWords.length).join(' ');
          const similarity = calculateTextSimilarity(window, normalizedPhrase);
          
          if (similarity >= tolerance) {
            // Find word positions in original text
            const words = text.split(/(\s+)/);
            let wordIndex = 0;
            let charIndex = 0;
            
            for (let j = 0; j < words.length && wordIndex < i + phraseWords.length; j++) {
              const word = words[j];
              if (word.trim()) {
                if (wordIndex >= i) {
                  const wordStart = text.indexOf(word, charIndex);
                  positions.push({
                    start: wordStart,
                    end: wordStart + word.length,
                    phrase: phrase
                  });
                }
                wordIndex++;
              }
              charIndex += word.length;
            }
            break;
          }
        }
      }
      
      return positions;
    }
    
    // Simple text similarity calculation
    function calculateTextSimilarity(text1, text2) {
      if (!text1 || !text2) return 0;
      if (text1 === text2) return 1;
      
      const words1 = new Set(text1.split(/\s+/).filter(w => w.length > 2));
      const words2 = new Set(text2.split(/\s+/).filter(w => w.length > 2));
      
      if (words1.size === 0 || words2.size === 0) return 0;
      
      const intersection = new Set([...words1].filter(x => words2.has(x)));
      const union = new Set([...words1, ...words2]);
      
      return intersection.size / union.size;
    }
    
    function alignSegmentsByTime(standardSegments = [], nextLevelSegments = [], originalSegments = [], options = {}) {
      const tolerance = options.tolerance || 0.45;
      const rows = [];
      
      const addSegment = (segment, columnKey) => {
        if (!segment || !columnKey) return;
        const { start, end } = getSegmentTimeRange(segment);
        if (start === null) return;
        const text = (segment.text || segment.word || '').trim();
        if (!text) return;
        
        let targetRow = rows.find(row => Math.abs(row.anchor - start) <= tolerance);
        if (!targetRow) {
          targetRow = {
            anchor: start,
            columns: {
              original: [],
              speaker0: [],
              speaker1: [],
              agent: [],
              client: []
            }
          };
          rows.push(targetRow);
        }
        
        targetRow.anchor = Math.min(targetRow.anchor, start);
        targetRow.columns[columnKey].push({
          text,
          start,
          end,
          raw: segment
        });
      };
      
      // Add original segments first
      originalSegments.forEach(segment => {
        addSegment(segment, 'original');
      });
      
      standardSegments.forEach(segment => {
        // Use _column if available, otherwise determine from speaker
        const columnKey = segment._column || determineStandardColumn(segment);
        addSegment(segment, columnKey);
      });
      
      nextLevelSegments.forEach(segment => {
        // Use _column if available, otherwise determine from role
        const columnKey = segment._column || determineNextLevelColumn(segment);
        addSegment(segment, columnKey);
      });
      
      return rows.sort((a, b) => a.anchor - b.anchor);
    }
    
    // Compare original text with diarized text and find mismatches
    function findMismatches(originalText, diarizedText) {
      if (!originalText || !diarizedText) {
        return { matches: [], mismatches: [], missing: [] };
      }
      
      const normalize = (text) => text.toLowerCase().replace(/[^\w\s]/g, ' ').replace(/\s+/g, ' ').trim();
      const origWords = normalize(originalText).split(/\s+/).filter(w => w.length > 0);
      const diarWords = normalize(diarizedText).split(/\s+/).filter(w => w.length > 0);
      
      const matches = [];
      const mismatches = [];
      const missing = [];
      
      // Find word-level matches and mismatches
      let origIndex = 0;
      let diarIndex = 0;
      
      while (origIndex < origWords.length || diarIndex < diarWords.length) {
        if (origIndex >= origWords.length) {
          // Extra words in diarization (not in original)
          mismatches.push({ word: diarWords[diarIndex], index: diarIndex, type: 'extra' });
          diarIndex++;
        } else if (diarIndex >= diarWords.length) {
          // Missing words in diarization (present in original)
          missing.push({ word: origWords[origIndex], index: origIndex, type: 'missing' });
          origIndex++;
        } else if (origWords[origIndex] === diarWords[diarIndex]) {
          // Match
          matches.push({ word: origWords[origIndex], origIndex, diarIndex });
          origIndex++;
          diarIndex++;
        } else {
          // Mismatch - try to find the word later
          let found = false;
          for (let j = diarIndex + 1; j < Math.min(diarIndex + 5, diarWords.length); j++) {
            if (origWords[origIndex] === diarWords[j]) {
              // Found later - mark intermediate as extra
              for (let k = diarIndex; k < j; k++) {
                mismatches.push({ word: diarWords[k], index: k, type: 'extra' });
              }
              diarIndex = j + 1;
              origIndex++;
              found = true;
              break;
            }
          }
          
          if (!found) {
            // Check if diarized word appears later in original
            let foundInOrig = false;
            for (let j = origIndex + 1; j < Math.min(origIndex + 5, origWords.length); j++) {
              if (origWords[j] === diarWords[diarIndex]) {
                // Found later - mark intermediate as missing
                for (let k = origIndex; k < j; k++) {
                  missing.push({ word: origWords[k], index: k, type: 'missing' });
                }
                origIndex = j + 1;
                diarIndex++;
                foundInOrig = true;
                break;
              }
            }
            
            if (!foundInOrig) {
              // True mismatch
              mismatches.push({ word: diarWords[diarIndex], index: diarIndex, type: 'mismatch' });
              missing.push({ word: origWords[origIndex], index: origIndex, type: 'missing' });
              origIndex++;
              diarIndex++;
            }
          }
        }
      }
      
      return { matches, mismatches, missing };
    }
    
    // Highlight text with mismatch information
    function highlightMismatches(text, mismatches, missing, isOriginal = true) {
      if (!text) return text;
      
      const highlights = [];
      
      if (isOriginal) {
        // In original: highlight both present (matches) and missing elements
        // Missing elements should be highlighted
        missing.forEach(item => {
          // Find the word in the original text
          const words = text.split(/(\s+)/);
          let wordIndex = 0;
          let charIndex = 0;
          
          for (let i = 0; i < words.length; i++) {
            const word = words[i].trim();
            if (word && normalizeTextForMatching(word) === item.word) {
              if (wordIndex === item.index) {
                const wordStart = text.indexOf(word, charIndex);
                highlights.push({
                  start: wordStart,
                  end: wordStart + word.length,
                  color: 'orange',
                  type: 'missing',
                  tooltip: 'Missing in diarization'
                });
                break;
              }
              wordIndex++;
            }
            charIndex += words[i].length;
          }
        });
      } else {
        // In diarized: highlight only mismatches (not missing, as absence can't be displayed)
        mismatches.forEach(item => {
          const words = text.split(/(\s+)/);
          let wordIndex = 0;
          let charIndex = 0;
          
          for (let i = 0; i < words.length; i++) {
            const word = words[i].trim();
            if (word && normalizeTextForMatching(word) === item.word) {
              if (wordIndex === item.index) {
                const wordStart = text.indexOf(word, charIndex);
                highlights.push({
                  start: wordStart,
                  end: wordStart + word.length,
                  color: item.type === 'extra' ? 'red' : 'orange',
                  type: item.type,
                  tooltip: item.type === 'extra' ? 'Extra word (not in original)' : 'Mismatch with original'
                });
                break;
              }
              wordIndex++;
            }
            charIndex += words[i].length;
          }
        });
      }
      
      // Sort highlights
      highlights.sort((a, b) => a.start - b.start);
      
      // Apply highlights
      if (highlights.length === 0) return escapeHtml(text);
      
      let result = '';
      let lastIndex = 0;
      
      highlights.forEach(highlight => {
        if (highlight.start > lastIndex) {
          result += escapeHtml(text.substring(lastIndex, highlight.start));
        }
        
        const highlightedText = text.substring(highlight.start, highlight.end);
        const colorClass = `text-highlight-${highlight.color}`;
        const tooltip = highlight.tooltip ? ` title="${escapeHtml(highlight.tooltip)}"` : '';
        result += `<span class="${colorClass}" data-type="${highlight.type}"${tooltip}>${escapeHtml(highlightedText)}</span>`;
        
        lastIndex = highlight.end;
      });
      
      if (lastIndex < text.length) {
        result += escapeHtml(text.substring(lastIndex));
      }
      
      return result;
    }
    
    function renderComparisonTable(rows, container, textAnalysis = null) {
      if (!container) return;
      
      if (!rows || rows.length === 0) {
        container.innerHTML = `
          <div class="comparison-empty">
            No aligned segments available. Please run diarization first.
          </div>
        `;
        return;
      }
      
      // Helper function to highlight overlaps in text
      const highlightOverlaps = (text, start, end, textAnalysis) => {
        if (!textAnalysis || !textAnalysis.Green || !Array.isArray(textAnalysis.Green)) {
          return escapeHtml(text);
        }
        
        const highlights = [];
        
        textAnalysis.Green.forEach(overlap => {
          const overlapStart = parseFloat(overlap.start) || 0;
          const overlapEnd = parseFloat(overlap.end) || overlapStart;
          
          // Check if overlap time range intersects with segment time range
          if (overlapStart < end && overlapEnd > start) {
            // Find the overlap text in the segment text
            const overlapText = overlap.text || '';
            const parts = overlapText.split('|').map(p => p.trim());
            
            parts.forEach(part => {
              if (part && text.toLowerCase().includes(part.toLowerCase())) {
                const positions = findPhrasePositions(text, part);
                positions.forEach(pos => {
                  highlights.push({
                    start: pos.start,
                    end: pos.end,
                    color: 'green',
                    type: 'overlap',
                    tooltip: 'Overlapping speech detected'
                  });
                });
              }
            });
          }
        });
        
        if (highlights.length === 0) {
          return escapeHtml(text);
        }
        
        // Sort and apply highlights
        highlights.sort((a, b) => a.start - b.start);
        let result = '';
        let lastIndex = 0;
        
        highlights.forEach(highlight => {
          if (highlight.start > lastIndex) {
            result += escapeHtml(text.substring(lastIndex, highlight.start));
          }
          const highlightedText = text.substring(highlight.start, highlight.end);
          const colorClass = `text-highlight-${highlight.color}`;
          const tooltip = highlight.tooltip ? ` title="${escapeHtml(highlight.tooltip)}"` : '';
          result += `<span class="${colorClass}" data-type="${highlight.type}"${tooltip}>${escapeHtml(highlightedText)}</span>`;
          lastIndex = highlight.end;
        });
        
        if (lastIndex < text.length) {
          result += escapeHtml(text.substring(lastIndex));
        }
        
        return result;
      };
      
      // Helper function to format text with highlighting
      const formatText = (text, start, end, allRowData, isStandard = false) => {
        if (!text) return '';
        
        let formattedText = text;
          
          // First, apply overlap highlighting (Green) if textAnalysis is available
          if (textAnalysis) {
          formattedText = highlightOverlaps(formattedText, start, end, textAnalysis);
          } else {
          formattedText = escapeHtml(formattedText);
        }
        
        // Apply mismatch highlighting if original text is available
        if (allRowData && allRowData.columns.original && allRowData.columns.original.length > 0) {
          const originalText = allRowData.columns.original
              .map(seg => seg.text).join(' ');
            
            if (originalText) {
            const plainText = text;
              const mismatchInfo = findMismatches(originalText, plainText);
            formattedText = highlightMismatches(plainText, mismatchInfo.mismatches, mismatchInfo.missing, false);
              // Re-apply overlap highlighting on top
              if (textAnalysis) {
              formattedText = highlightOverlaps(formattedText, start, end, textAnalysis);
              }
            }
          }
          
          // If text is still plain (not HTML), escape it
        if (typeof formattedText === 'string' && !formattedText.includes('<span')) {
          formattedText = escapeHtml(formattedText);
        }
        
        return formattedText;
      };
      
      // Build table rows - each row shows Standard and NextLevel segments side by side
      let segmentId = 1;
      let html = '<table class="comparison-table"><thead><tr>';
      html += '<th>Segment ID</th>';
      html += '<th>Speaker (Standard)</th>';
      html += '<th>Text (Standard)</th>';
      html += '<th>Speaker (NextLevel)</th>';
      html += '<th>Text (NextLevel)</th>';
      html += '<th>Start Time</th>';
      html += '<th>End Time</th>';
      html += '</tr></thead><tbody>';
      
      // Collect all segments and sort by start time
      const allSegments = [];
      
      rows.forEach(row => {
        // Add Standard segments
        [...(row.columns.speaker0 || []), ...(row.columns.speaker1 || [])].forEach(seg => {
          allSegments.push({
            type: 'standard',
            segment: seg,
            row: row
          });
        });
        
        // Add NextLevel segments
        [...(row.columns.agent || []), ...(row.columns.client || [])].forEach(seg => {
          allSegments.push({
            type: 'nextlevel',
            segment: seg,
            row: row
          });
        });
      });
      
      // Sort all segments by start time
      allSegments.sort((a, b) => {
        const startA = parseFloat(a.segment.start) || 0;
        const startB = parseFloat(b.segment.start) || 0;
        return startA - startB;
      });
      
      // Group segments by time windows to find matches
      const timeWindow = 0.5; // 0.5 second tolerance for matching
      const matchedStandard = new Set();
      const matchedNextLevel = new Set();
      
      // First pass: match Standard and NextLevel segments by time overlap
      allSegments.forEach((item, idx) => {
        if (item.type === 'standard' && !matchedStandard.has(idx)) {
          const segStart = parseFloat(item.segment.start) || 0;
          const segEnd = parseFloat(item.segment.end) || parseFloat(item.segment.start) || 0;
          
          // Find best matching NextLevel segment
          let bestMatch = null;
          let bestMatchIdx = -1;
          let bestOverlap = 0;
          
          allSegments.forEach((candidate, candIdx) => {
            if (candidate.type === 'nextlevel' && !matchedNextLevel.has(candIdx)) {
              const candStart = parseFloat(candidate.segment.start) || 0;
              const candEnd = parseFloat(candidate.segment.end) || parseFloat(candidate.segment.start) || 0;
              
              // Calculate overlap
              const overlapStart = Math.max(segStart, candStart);
              const overlapEnd = Math.min(segEnd, candEnd);
              const overlap = Math.max(0, overlapEnd - overlapStart);
              
              if (overlap > bestOverlap || (overlap > 0 && bestMatch === null)) {
                bestOverlap = overlap;
                bestMatch = candidate;
                bestMatchIdx = candIdx;
              }
            }
          });
          
          // Create row with Standard and (optionally) matched NextLevel
          const seg = item.segment;
          const rowData = item.row;
          
        html += '<tr>';
          html += `<td>${segmentId++}</td>`;
          
          // Standard columns
          const segColumn = seg.raw?._column || seg._column;
          const speakerLabel = segColumn === 'speaker0' ? 'Speaker 0' : 
                               segColumn === 'speaker1' ? 'Speaker 1' :
                               seg.raw?.speaker || seg.speaker || 'Speaker';
          html += `<td>${escapeHtml(speakerLabel)}</td>`;
          html += `<td>${formatText(seg.text, segStart, segEnd, rowData, true)}</td>`;
          
          // NextLevel columns
          if (bestMatch && bestMatchIdx >= 0) {
            matchedStandard.add(idx);
            matchedNextLevel.add(bestMatchIdx);
            
            const nextSeg = bestMatch.segment;
            const nextStart = parseFloat(nextSeg.start) || 0;
            const nextEnd = parseFloat(nextSeg.end) || parseFloat(nextSeg.start) || 0;
            const nextRowData = bestMatch.row;
            
            const nextSegColumn = nextSeg.raw?._column || nextSeg._column;
            const nextSpeakerLabel = nextSegColumn === 'agent' ? 'Agent' :
                                     nextSegColumn === 'client' ? 'Client' :
                                     nextSeg.raw?.speaker || nextSeg.raw?.role || nextSeg.speaker || nextSeg.role || 'Speaker';
            html += `<td>${escapeHtml(nextSpeakerLabel)}</td>`;
            html += `<td>${formatText(nextSeg.text, nextStart, nextEnd, nextRowData, false)}</td>`;
            
            // Use combined time range
            const combinedStart = Math.min(segStart, nextStart);
            const combinedEnd = Math.max(segEnd, nextEnd);
            html += `<td>${formatSeconds(combinedStart)}</td>`;
            html += `<td>${formatSeconds(combinedEnd)}</td>`;
          } else {
            html += '<td><span class="comparison-empty">‚Äî</span></td>';
            html += '<td><span class="comparison-empty">‚Äî</span></td>';
            html += `<td>${formatSeconds(segStart)}</td>`;
            html += `<td>${formatSeconds(segEnd)}</td>`;
          }
          
          html += '</tr>';
        }
      });
      
      // Second pass: add unmatched NextLevel segments
      allSegments.forEach((item, idx) => {
        if (item.type === 'nextlevel' && !matchedNextLevel.has(idx)) {
          const seg = item.segment;
          const segStart = parseFloat(seg.start) || 0;
          const segEnd = parseFloat(seg.end) || parseFloat(seg.start) || 0;
          const rowData = item.row;
          
          html += '<tr>';
          html += `<td>${segmentId++}</td>`;
          
          // Standard columns (empty)
          html += '<td><span class="comparison-empty">‚Äî</span></td>';
          html += '<td><span class="comparison-empty">‚Äî</span></td>';
          
          // NextLevel columns
          const segColumn = seg.raw?._column || seg._column;
          const speakerLabel = segColumn === 'agent' ? 'Agent' :
                               segColumn === 'client' ? 'Client' :
                               seg.raw?.speaker || seg.raw?.role || seg.speaker || seg.role || 'Speaker';
          html += `<td>${escapeHtml(speakerLabel)}</td>`;
          html += `<td>${formatText(seg.text, segStart, segEnd, rowData, false)}</td>`;
          
          html += `<td>${formatSeconds(segStart)}</td>`;
          html += `<td>${formatSeconds(segEnd)}</td>`;
        html += '</tr>';
        }
      });
      
      html += '</tbody></table>';
      container.innerHTML = html;
    }
    
    // Show summary info
    // Render markdown table
    function renderMarkdownTable(markdown, container, originalSegments = [], textAnalysis = null, options = {}) {
      if (!markdown) {
        container.innerHTML = '<div class="error-label">No markdown content received.</div>';
        return;
      }
      
      // Check if this is comparison table (comparisonTableContainer)
      const isComparisonTable = container && container.id === 'comparisonTableContainer';
      const comparisonData = options.isComparison ? options : null;
      const standardSegments = comparisonData?.standardSegments || [];
      const allPrimarySegments = comparisonData?.allPrimarySegments || []; // All segments from primaryDiarization
      const nextLevelMarkdownTable = comparisonData?.nextLevelMarkdownTable || null;
      const originalReplicasMatch = comparisonData?.originalReplicasMatch || new Map(); // LLM-matched original replicas
      
      // Parse NextLevel markdown table if available - store as map by time for quick lookup
      // Also store as array for overlap matching
      const nextLevelSegmentsMap = new Map(); // key: "start_end", value: {speaker, text, start, end}
      const nextLevelSegments = [];
      
      if (nextLevelMarkdownTable) {
        const tableLines = nextLevelMarkdownTable.split('\n').filter(line => line.trim() && line.includes('|'));
        for (let i = 2; i < tableLines.length; i++) {
          const cells = tableLines[i].split('|').map(c => c.trim()).filter(c => c);
          if (cells.length >= 5) {
            const speaker = cells[1] || '';
            const text = cells[2] || '';
            const start = parseFloat(cells[3]) || 0;
            const end = parseFloat(cells[4]) || 0;
            
            if (text && (speaker.toLowerCase() === 'agent' || speaker.toLowerCase() === 'client')) {
              const segment = {
                speaker: speaker,
                text: text.trim(),
                start: start,
                end: end
              };
              
              // Store in map for exact time lookup
              const timeKey = `${start.toFixed(2)}_${end.toFixed(2)}`;
              nextLevelSegmentsMap.set(timeKey, segment);
              
              // Also store in array for overlap matching
              nextLevelSegments.push(segment);
            }
          }
        }
      }
      
      console.log('üìã Rendering markdown table, length:', markdown.length);
      console.log('üìã textAnalysis:', textAnalysis ? {
        hasBlue: !!textAnalysis.Blue,
        hasGreen: !!textAnalysis.Green,
        hasRed: !!textAnalysis.Red,
        blueCount: textAnalysis.Blue?.length || 0,
        greenCount: textAnalysis.Green?.length || 0,
        redCount: textAnalysis.Red?.length || 0
      } : 'null');
      
      // Parse markdown table and render as HTML
      const lines = markdown.split('\n');
      let html = '<table class="markdown-table">';
      let inTable = false;
      let headerProcessed = false;
      let hasTableRows = false;
      let rowCount = 0;
      let dataRowNumber = 0; // –ù–æ–º–µ—Ä —Ä—è–¥–∫–∞ –¥–∞–Ω–∏—Ö (–ø–æ—á–∏–Ω–∞—î—Ç—å—Å—è –∑ 1, –Ω–µ –≤—Ä–∞—Ö–æ–≤—É—î –∑–∞–≥–æ–ª–æ–≤–æ–∫)
      
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const trimmedLine = line.trim();
        
        // Check if this is a markdown table row
        if (trimmedLine.startsWith('|') && trimmedLine.endsWith('|')) {
          hasTableRows = true;
          
          if (!inTable) {
            inTable = true;
            html += '<thead><tr>';
          }
          
          // Split by | - markdown tables have | at start and end
          const parts = trimmedLine.split('|');
          const cells = [];
          
          // Process parts: skip first empty, process middle, skip last empty
          for (let j = 0; j < parts.length; j++) {
            const part = parts[j];
            if (j === 0 && part.trim() === '') continue;
            if (j === parts.length - 1 && part.trim() === '') continue;
            cells.push(part.trim());
          }
          
          // Skip separator row (|---|---| or |:---:|)
          const isSeparator = cells.length > 0 && cells.every(c => {
            const trimmed = c.trim();
            return trimmed === '' || trimmed.match(/^:?-+:?$/) || trimmed.match(/^:?-+:?$/);
          });
          
          if (isSeparator) {
            if (!headerProcessed && inTable) {
              html += '</tr></thead><tbody>';
              headerProcessed = true;
            }
            continue;
          }
          
          // Valid data row
          rowCount++;
          // –î–ª—è —Ä—è–¥–∫—ñ–≤ –¥–∞–Ω–∏—Ö (–ø—ñ—Å–ª—è headerProcessed) –∑–±—ñ–ª—å—à—É—î–º–æ dataRowNumber
          if (headerProcessed) {
            dataRowNumber++;
          }
          html += '<tr>';
          
          // Extract segment times and speaker from markdown row (columns: Segment ID | Speaker | Text | Start Time | End Time)
          let segmentStart = null;
          let segmentEnd = null;
          let segmentSpeaker = null;
          if (headerProcessed && cells.length >= 5) {
            segmentStart = parseFloat(cells[3]) || null;
            segmentEnd = parseFloat(cells[4]) || null;
            segmentSpeaker = cells[1]?.trim() || null; // Speaker column
          }
          
          // For comparison table header, add Original columns first, then Standard, then NextLevel
          if (!headerProcessed && isComparisonTable) {
            // Render: Segment ID | Role Original | Text Original | Speaker (Standard) | Text (Standard) | Speaker (NextLevel) | Text (NextLevel) | Start Time | End Time
            // Segment ID
            html += `<th>${escapeHtml(cells[0] || 'Segment ID')}</th>`;
            // Add Original columns first
            html += '<th>Role Original</th>';
            html += '<th>Text Original</th>';
            // Add Standard columns
            html += '<th>Speaker (Standard)</th>';
            html += '<th>Text (Standard)</th>';
            // Add NextLevel columns
            html += '<th>Speaker (NextLevel)</th>';
            html += '<th>Text (NextLevel)</th>';
            // Add Start Time and End Time at the end
            html += '<th>Start Time</th>';
            html += '<th>End Time</th>';
          } else if (headerProcessed && isComparisonTable) {
            // For comparison table data rows, add Standard and NextLevel data
            // IMPORTANT: 
            // - Standard: Use ORIGINAL segments from primaryDiarization (NO processing)
            // - NextLevel: Use data from nextLevelMarkdownTable (processed, but correct)
            // cells[0] = Segment ID
            // cells[1] = Speaker (Standard: SPEAKER_00/SPEAKER_01)
            // cells[2] = Text (Standard) - IGNORE THIS, use original from primaryDiarization
            // cells[3] = Start Time
            // cells[4] = End Time
            
            const standardSpeaker = cells[1]?.trim() || '';
            const startTime = cells[3]?.trim() || '';
            const endTime = cells[4]?.trim() || '';
            
            // Find ALL matching ORIGINAL Standard segments by time from primaryDiarization (NO processing)
            // IMPORTANT: Search in ALL primary segments from recordings[0].results.speechmatics.segments
            // This ensures we get the raw, unprocessed text from Speechmatics
            let matchingStandardSegs = [];
            
            if (segmentStart !== null && segmentEnd !== null && allPrimarySegments.length > 0) {
              // Find all segments that match this time range
              // Use exact match first (tolerance 0.1s), then overlap, then proximity
              allPrimarySegments.forEach(seg => {
                const segStart = parseFloat(seg.start) || 0;
                const segEnd = parseFloat(seg.end) || parseFloat(seg.start) || 0;
                
                // Check for exact time match (with small tolerance ~0.1s)
                const startDiff = Math.abs(segStart - segmentStart);
                const endDiff = Math.abs(segEnd - segmentEnd);
                const isExactMatch = startDiff < 0.1 && endDiff < 0.1;
                
                // Calculate overlap
                const overlapStart = Math.max(segStart, segmentStart);
                const overlapEnd = Math.min(segEnd, segmentEnd);
                const overlap = Math.max(0, overlapEnd - overlapStart);
                
                // Include if exact match, has overlap, or start time is very close (within 1.5 seconds)
                if (isExactMatch || overlap > 0 || startDiff < 1.5) {
                  matchingStandardSegs.push({
                    seg: seg,
                    overlap: overlap,
                    startDiff: startDiff,
                    endDiff: endDiff,
                    isExactMatch: isExactMatch
                  });
                }
              });
              
              // Sort by: exact match first, then by overlap (best first), then by start time difference
              matchingStandardSegs.sort((a, b) => {
                if (a.isExactMatch !== b.isExactMatch) return b.isExactMatch - a.isExactMatch;
                if (b.overlap !== a.overlap) return b.overlap - a.overlap;
                return a.startDiff - b.startDiff;
              });
            }
            
            // Use the best matching segment (exact match > best overlap > closest start time)
            const matchingStandardSeg = matchingStandardSegs.length > 0 ? matchingStandardSegs[0].seg : null;
            
            // Get NextLevel data from nextLevelMarkdownTable (parsed earlier)
            // IMPORTANT: Copy directly from Legacy Markdown Table, match by time
            let nextLevelSpeaker = '';
            let nextLevelText = '';
            
            if (segmentStart !== null && segmentEnd !== null && nextLevelSegments.length > 0) {
              // First try exact time match (tolerance 0.1s)
              const timeKey = `${segmentStart.toFixed(2)}_${segmentEnd.toFixed(2)}`;
              let exactMatch = nextLevelSegmentsMap.get(timeKey);
              
              // If no exact match, try with small tolerance
              if (!exactMatch) {
                nextLevelSegments.forEach(seg => {
                  const startDiff = Math.abs(seg.start - segmentStart);
                  const endDiff = Math.abs(seg.end - segmentEnd);
                  if (startDiff < 0.1 && endDiff < 0.1) {
                    exactMatch = seg;
                  }
                });
              }
              
              if (exactMatch) {
                nextLevelSpeaker = exactMatch.speaker;
                nextLevelText = exactMatch.text;
              } else {
                // Fallback: find best matching segment by time overlap
                let bestMatch = null;
                let bestOverlap = 0;
                let bestStartDiff = Infinity;
                
                nextLevelSegments.forEach(seg => {
                  const segStart = parseFloat(seg.start) || 0;
                  const segEnd = parseFloat(seg.end) || parseFloat(seg.start) || 0;
                  
                  // Calculate overlap
                  const overlapStart = Math.max(segStart, segmentStart);
                  const overlapEnd = Math.min(segEnd, segmentEnd);
                  const overlap = Math.max(0, overlapEnd - overlapStart);
                  
                  const startDiff = Math.abs(segStart - segmentStart);
                  
                  // Prefer segments with overlap, then by closest start time
                  if (overlap > bestOverlap || (overlap === bestOverlap && startDiff < bestStartDiff)) {
                    bestOverlap = overlap;
                    bestStartDiff = startDiff;
                    bestMatch = seg;
                  } else if (bestMatch === null && startDiff < 1.5) {
                    // Fallback: if no overlap, use closest start time (1.5 second tolerance)
                    bestMatch = seg;
                    bestStartDiff = startDiff;
                  }
                });
                
                if (bestMatch) {
                  nextLevelSpeaker = bestMatch.speaker || '';
                  nextLevelText = bestMatch.text || '';
                }
              }
            }
            
            // Render row: Segment ID | Role Original | Text Original | Speaker (Standard) | Text (Standard) | Speaker (NextLevel) | Text (NextLevel) | Start Time | End Time
            // Segment ID
            html += `<td>${escapeHtml(cells[0]?.trim() || '')}</td>`;
            
            // Add Original columns FIRST (Role Original and Text Original)
            // –ü—Ä—ñ–æ—Ä–∏—Ç–µ—Ç 1: –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –∑–∞—Å—Ç–æ—Å–æ–≤–∞–Ω—ñ —Ä–µ–ø–ª—ñ–∫–∏ –∑ applyOriginalReplicas (—è–∫—â–æ —î)
            // –ü—Ä—ñ–æ—Ä–∏—Ç–µ—Ç 2: –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ LLM-matched original replicas
            let originalRole = null;
            let originalText = null;
            
            // –°–ø–æ—á–∞—Ç–∫—É –ø–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ —î –∑–∞—Å—Ç–æ—Å–æ–≤–∞–Ω—ñ —Ä–µ–ø–ª—ñ–∫–∏ (–∑ applyOriginalReplicas)
            // dataRowNumber - —Ü–µ –Ω–æ–º–µ—Ä —Ä—è–¥–∫–∞ –¥–∞–Ω–∏—Ö (–ø–æ—á–∏–Ω–∞—î—Ç—å—Å—è –∑ 1, –Ω–µ –≤—Ä–∞—Ö–æ–≤—É—î –∑–∞–≥–æ–ª–æ–≤–æ–∫)
            // –í—ñ–¥–ø–æ–≤—ñ–¥–∞—î replicaNumber –≤ window.appliedOriginalReplicas
            if (headerProcessed && window.appliedOriginalReplicas && Array.isArray(window.appliedOriginalReplicas)) {
              const appliedReplica = window.appliedOriginalReplicas.find(r => r.replicaNumber === dataRowNumber);
              
              if (appliedReplica) {
                originalRole = appliedReplica.role;
                originalText = appliedReplica.text;
                console.log(`‚úÖ [renderMarkdownTable] Using applied replica ${dataRowNumber} for data row:`, {
                  role: originalRole,
                  text: originalText?.substring(0, 50)
                });
              }
            }
            
            // –Ø–∫—â–æ –Ω–µ –∑–Ω–∞–π—à–ª–∏ –≤ –∑–∞—Å—Ç–æ—Å–æ–≤–∞–Ω–∏—Ö —Ä–µ–ø–ª—ñ–∫–∞—Ö, –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ LLM matching
            if (!originalRole && !originalText && matchingStandardSeg && allPrimarySegments.length > 0) {
              const segmentIndex = allPrimarySegments.findIndex(seg => 
                seg === matchingStandardSeg || 
                (parseFloat(seg.start) === parseFloat(matchingStandardSeg.start) && 
                 parseFloat(seg.end) === parseFloat(matchingStandardSeg.end))
              );
              
              if (segmentIndex >= 0 && originalReplicasMatch && originalReplicasMatch.has(segmentIndex)) {
                const originalMatch = originalReplicasMatch.get(segmentIndex);
                originalRole = originalMatch.originalRole === 'agent' ? 'Agent' : 
                              originalMatch.originalRole === 'client' ? 'Client' : 
                              originalMatch.originalRole || null;
                originalText = originalMatch.originalText || null;
              }
            }
            
            // –í—ñ–¥–æ–±—Ä–∞–∂–∞—î–º–æ Role Original —Ç–∞ Text Original
            if (originalRole || originalText) {
              html += `<td>${escapeHtml(originalRole || '‚Äî')}</td>`;
              html += `<td>${escapeHtml(originalText || '‚Äî')}</td>`;
            } else {
              html += '<td><span class="comparison-empty">‚Äî</span></td>';
              html += '<td><span class="comparison-empty">‚Äî</span></td>';
            }
            
            // Speaker (Standard) - from original segment or markdown table
            if (matchingStandardSeg) {
              const speakerLabel = matchingStandardSeg._column === 'speaker0' ? 'Speaker 0' : 
                                   matchingStandardSeg._column === 'speaker1' ? 'Speaker 1' :
                                   matchingStandardSeg.speaker || matchingStandardSeg.speaker_label || 'Speaker';
              html += `<td>${escapeHtml(speakerLabel)}</td>`;
            } else {
              // Fallback to markdown table speaker
              let speakerLabel = standardSpeaker;
              if (standardSpeaker.toUpperCase() === 'SPEAKER_00' || standardSpeaker.toUpperCase() === 'SPEAKER_0') {
                speakerLabel = 'Speaker 0';
              } else if (standardSpeaker.toUpperCase() === 'SPEAKER_01' || standardSpeaker.toUpperCase() === 'SPEAKER_1') {
                speakerLabel = 'Speaker 1';
              }
              html += `<td>${escapeHtml(speakerLabel)}</td>`;
            }
            
            // Text (Standard) - use ORIGINAL text from primaryDiarization, NO processing
            // IMPORTANT: Get text directly from segment.text - this is raw Speechmatics output
            // Do NOT use words array or any processing - show original errors like "acne support"
            if (matchingStandardSeg) {
              // Get original text directly from segment.text field
              // This is the raw, unprocessed text from Speechmatics first stage
              // It may contain errors like "acne support" instead of "Acme support"
              // This is intentional - we want to show the original diarization without improvements
              const originalText = matchingStandardSeg.text || '';
              
              // Only fallback to transcript if text is not available
              // But prefer text as it's the most direct field
              const finalText = originalText || matchingStandardSeg.transcript || '';
              
              html += `<td>${escapeHtml(finalText)}</td>`;
            } else {
              html += '<td><span class="comparison-empty">‚Äî</span></td>';
            }
            
            // Add NextLevel columns (Speaker and Text from nextLevelMarkdownTable)
            if (nextLevelSpeaker && nextLevelText) {
              html += `<td>${escapeHtml(nextLevelSpeaker)}</td>`;
              html += `<td>${escapeHtml(nextLevelText)}</td>`;
            } else {
              html += '<td><span class="comparison-empty">‚Äî</span></td>';
              html += '<td><span class="comparison-empty">‚Äî</span></td>';
            }
            
            // Add Start Time and End Time at the end
            html += `<td>${escapeHtml(startTime)}</td>`;
            html += `<td>${escapeHtml(endTime)}</td>`;
          } else {
            // Regular markdown table (not comparison)
          cells.forEach((cell, cellIndex) => {
            const tag = headerProcessed ? 'td' : 'th';
            let cellHtml;
            // For data rows, column index 2 is "Text" (Segment ID | Speaker | Text | Start Time | End Time)
            // –ó–ê–ö–û–ú–ï–ù–¢–û–í–ê–ù–û: –õ–æ–≥—ñ–∫–∞ –≤–∏–¥—ñ–ª–µ–Ω–Ω—è —Ñ—Ä–∞–≥–º–µ–Ω—Ç—ñ–≤ —Ç–∏–º—á–∞—Å–æ–≤–æ –≤–∏–º–∫–Ω–µ–Ω–∞ –∑–∞ –≤–∏–º–æ–≥–æ—é –∑–∞–º–æ–≤–Ω–∏–∫–∞
            // if (headerProcessed && cellIndex === 2 && textAnalysis) {
            //   cellHtml = highlightOriginalText(cell, originalSegments, textAnalysis, segmentStart, segmentEnd, segmentSpeaker);
            // } else {
              cellHtml = escapeHtml(cell);
            // }
            html += `<${tag}>${cellHtml}</${tag}>`;
          });
          }
          html += '</tr>';
        } else if (inTable && trimmedLine === '' && headerProcessed) {
          // Empty line after table body - might indicate end
          continue;
        } else if (inTable && !trimmedLine.startsWith('|') && headerProcessed) {
          // Non-table line after table started - might be end of table
          continue;
        }
      }
      
      // Close table if still open
      if (inTable) {
        if (headerProcessed) {
          html += '</tbody>';
        } else {
          html += '</tr></thead>';
        }
      }
      
      html += '</table>';
      
      // If no table found, render as preformatted text
      if (!hasTableRows) {
        console.warn('‚ö†Ô∏è No table rows found, rendering as preformatted text');
        html = `<div style="white-space: pre-wrap; font-family: monospace; padding: 12px 14px; background: #f8f9fa; color: #2c3e50; border-radius: 6px; border: 1px solid #e0e0e0;">${escapeHtml(markdown)}</div>`;
      }
      
      container.innerHTML = html;
      console.log('‚úÖ Markdown table rendered, rows:', rowCount);
    }
    
    // Escape regular expression special characters
    function escapeRegExp(string) {
      return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }
    
    // Escape HTML
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
    
    // Get text from original segment (supports multiple possible schemas)
    function getSegmentText(segment) {
      if (!segment || typeof segment !== 'object') return '';
      if (typeof segment.text === 'string') return segment.text;
      if (typeof segment.transcript === 'string') return segment.transcript;
      if (Array.isArray(segment.words) && segment.words.length > 0) {
        // Some schemas store words array; join into phrase
        return segment.words.map(w => w.word || w.text || '').join(' ').trim();
      }
      if (Array.isArray(segment.alternatives) && segment.alternatives[0]?.content) {
        return segment.alternatives[0].content;
      }
      return '';
    }
    
    /**
     * Highlight text with colors based on textAnalysis
     * Blue: repeated phrases
     * Green: overlaps
     * Red: discrepancies (hallucinations)
     * 
     * @param {string} text - —Ç–µ–∫—Å—Ç –¥–ª—è –≤–∏–¥—ñ–ª–µ–Ω–Ω—è
     * @param {object} textAnalysis - –æ–±'—î–∫—Ç –∑ Blue, Green, Red –º–∞—Å–∏–≤–∞–º–∏
     * @param {number} segmentStart - —á–∞—Å –ø–æ—á–∞—Ç–∫—É —Å–µ–≥–º–µ–Ω—Ç–∞
     * @param {number} segmentEnd - —á–∞—Å –∫—ñ–Ω—Ü—è —Å–µ–≥–º–µ–Ω—Ç–∞
     * @param {string} segmentSpeaker - —Å–ø—ñ–∫–µ—Ä –ø–æ—Ç–æ—á–Ω–æ–≥–æ —Å–µ–≥–º–µ–Ω—Ç–∞ (Agent/Client)
     * 
     * –ó–ê–ö–û–ú–ï–ù–¢–û–í–ê–ù–û: –õ–æ–≥—ñ–∫–∞ –≤–∏–¥—ñ–ª–µ–Ω–Ω—è —Ñ—Ä–∞–≥–º–µ–Ω—Ç—ñ–≤ —Ç–∏–º—á–∞—Å–æ–≤–æ –≤–∏–º–∫–Ω–µ–Ω–∞ –∑–∞ –≤–∏–º–æ–≥–æ—é –∑–∞–º–æ–≤–Ω–∏–∫–∞
     */
    /*
    function highlightTextWithColors(text, textAnalysis, segmentStart = null, segmentEnd = null, segmentSpeaker = null) {
      if (!textAnalysis) {
        console.warn('üî¥ highlightTextWithColors: textAnalysis is null/undefined', { text: text?.substring(0, 50) });
        return escapeHtml(text || '');
      }
      if (!text) {
        return '';
      }
      
      const hasBlue = !!(textAnalysis.Blue && Array.isArray(textAnalysis.Blue) && textAnalysis.Blue.length > 0);
      const hasGreen = !!(textAnalysis.Green && Array.isArray(textAnalysis.Green) && textAnalysis.Green.length > 0);
      const hasRed = !!(textAnalysis.Red && Array.isArray(textAnalysis.Red) && textAnalysis.Red.length > 0);
      
      if (!hasBlue && !hasGreen && !hasRed) {
        console.warn('üî¥ highlightTextWithColors: textAnalysis has no data', {
          textAnalysis,
          text: text.substring(0, 50),
          segmentStart,
          segmentEnd
        });
        return escapeHtml(text);
      }

      // Function to find phrase in text
      const findPhraseInText = (text, phrase) => {
        if (!text || !phrase || typeof text !== 'string' || typeof phrase !== 'string') {
          return null;
        }
        
        phrase = phrase.trim();
        if (phrase.length < 1) return null;
        
        // Step 1: Exact search (case-insensitive)
        const textLower = text.toLowerCase();
        const phraseLower = phrase.toLowerCase();
        let index = textLower.indexOf(phraseLower);
        
        if (index !== -1) {
          return { start: index, end: index + phrase.length };
        }
        
        // Step 2: Search with word boundaries
        const phraseWords = phraseLower.split(/\s+/).filter(w => w.length > 0);
        if (phraseWords.length === 0) return null;
        
        if (phraseWords.length === 1) {
          const word = phraseWords[0];
          const regex = new RegExp(`\\b${word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'i');
          const match = text.match(regex);
          if (match) {
            return { start: match.index, end: match.index + match[0].length };
          }
          const simpleIndex = textLower.indexOf(word);
          if (simpleIndex !== -1) {
            return { start: simpleIndex, end: simpleIndex + word.length };
          }
          return null;
        }
        
        // Step 3: Multi-word phrase search
        const escapeRegex = (str) => str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const wordsPattern = phraseWords.map(w => escapeRegex(w)).join('[\\s\\p{P}]*');
        const regex = new RegExp(wordsPattern, 'iu');
        const match = text.match(regex);
        
        if (match) {
          return { start: match.index, end: match.index + match[0].length };
        }
        
        return null;
      };

      const highlights = [];
      const timeTolerance = 0.5;
      const processedPositions = new Set();
      
      // Function to find words in text - –ø–æ–∫—Ä–∞—â–µ–Ω–∞ –≤–µ—Ä—Å—ñ—è –∑ –∫—Ä–∞—â–æ—é –æ–±—Ä–æ–±–∫–æ—é
      const findWordsInText = (text, phrase) => {
        if (!text || !phrase || typeof text !== 'string' || typeof phrase !== 'string') {
          return [];
        }
        
        phrase = phrase.trim();
        if (phrase.length < 1) return [];
        
        const phraseWords = phrase.split(/\s+/).filter(w => w.length > 0);
        if (phraseWords.length === 0) return [];
        
        const wordPositions = [];
        const textLower = text.toLowerCase();
        
        phraseWords.forEach(word => {
          const wordLower = word.toLowerCase();
          const cleanWord = word.replace(/[^\w]/g, '');
          
          if (cleanWord.length < 1) return;
          
          let wordFound = false;
          
          // –ö—Ä–æ–∫ 1: –®—É–∫–∞—î–º–æ –∑ word boundary (–Ω–∞–π—Ç–æ—á–Ω—ñ—à–∏–π –ø–æ—à—É–∫)
          const regex = new RegExp(`\\b${cleanWord.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'gi');
          let match;
          regex.lastIndex = 0;
          
          while ((match = regex.exec(text)) !== null) {
            const posKey = `${match.index}-${match.index + match[0].length}`;
            if (!processedPositions.has(posKey)) {
              wordPositions.push({
                start: match.index,
                end: match.index + match[0].length,
                word: match[0]
              });
              processedPositions.add(posKey);
              wordFound = true;
              break; // –ó–Ω–∞–π—à–ª–∏ - –≤–∏—Ö–æ–¥–∏–º–æ
            }
          }
          
          // –ö—Ä–æ–∫ 2: –Ø–∫—â–æ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ –∑ word boundary, —à—É–∫–∞—î–º–æ —Ç–æ—á–Ω–µ —Å–ª–æ–≤–æ –∑ –ø–µ—Ä–µ–≤—ñ—Ä–∫–æ—é boundary
          if (!wordFound) {
            let searchIndex = 0;
            while (true) {
              const simpleIndex = textLower.indexOf(wordLower, searchIndex);
              if (simpleIndex === -1) break;
              
              const posKey = `${simpleIndex}-${simpleIndex + word.length}`;
              if (!processedPositions.has(posKey)) {
                const beforeChar = simpleIndex > 0 ? text[simpleIndex - 1] : ' ';
                const afterChar = simpleIndex + word.length < text.length ? text[simpleIndex + word.length] : ' ';
                const isWordBoundary = !/\w/.test(beforeChar) && !/\w/.test(afterChar);
                
                // –î–ª—è —Å–ª—ñ–≤ –¥–æ–≤–∂–∏–Ω–æ—é >= 2 –ø—Ä–∏–π–º–∞—î–º–æ, —è–∫—â–æ —î word boundary –∞–±–æ —Å–ª–æ–≤–æ –¥–æ–≤—à–µ 3 —Å–∏–º–≤–æ–ª—ñ–≤
                if (isWordBoundary || (word.length >= 3 && word.length >= 2)) {
                  wordPositions.push({
                    start: simpleIndex,
                    end: simpleIndex + word.length,
                    word: text.substring(simpleIndex, simpleIndex + word.length)
                  });
                  processedPositions.add(posKey);
                  wordFound = true;
                  break; // –ó–Ω–∞–π—à–ª–∏ - –≤–∏—Ö–æ–¥–∏–º–æ
                }
              }
              searchIndex = simpleIndex + 1;
            }
          }
          
          // –ö—Ä–æ–∫ 3: –Ø–∫—â–æ —Å–ª–æ–≤–æ –º–∞—î –ø—É–Ω–∫—Ç—É–∞—Ü—ñ—é —ñ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ, —à—É–∫–∞—î–º–æ cleanWord
          if (!wordFound && cleanWord !== word && cleanWord.length > 0) {
            const cleanWordLower = cleanWord.toLowerCase();
            let searchIndex = 0;
            while (true) {
              const cleanIndex = textLower.indexOf(cleanWordLower, searchIndex);
              if (cleanIndex === -1) break;
              
              const posKey = `${cleanIndex}-${cleanIndex + cleanWord.length}`;
              if (!processedPositions.has(posKey)) {
                // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ word boundary –¥–ª—è cleanWord
                const beforeChar = cleanIndex > 0 ? text[cleanIndex - 1] : ' ';
                const afterChar = cleanIndex + cleanWord.length < text.length ? text[cleanIndex + cleanWord.length] : ' ';
                const isWordBoundary = !/\w/.test(beforeChar) && !/\w/.test(afterChar);
                
                if (isWordBoundary || cleanWord.length >= 3) {
                  wordPositions.push({
                    start: cleanIndex,
                    end: cleanIndex + cleanWord.length,
                    word: text.substring(cleanIndex, cleanIndex + cleanWord.length)
                  });
                  processedPositions.add(posKey);
                  wordFound = true;
                  break; // –ó–Ω–∞–π—à–ª–∏ - –≤–∏—Ö–æ–¥–∏–º–æ
                }
              }
              searchIndex = cleanIndex + 1;
            }
          }
        });
        
        return wordPositions;
      };

      // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –Ω–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—ó —ñ–º–µ–Ω—ñ —Å–ø—ñ–∫–µ—Ä–∞ –¥–ª—è –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è
      const normalizeSpeaker = (speaker) => {
        if (!speaker) return null;
        const normalized = speaker.trim().toLowerCase();
        // –ù–æ—Ä–º–∞–ª—ñ–∑—É—î–º–æ —Ä—ñ–∑–Ω—ñ –≤–∞—Ä—ñ–∞–Ω—Ç–∏ –Ω–∞–∑–≤ —Å–ø—ñ–∫–µ—Ä—ñ–≤
        if (normalized === 'agent' || normalized === 'operator') return 'agent';
        if (normalized === 'client' || normalized === 'customer') return 'client';
        return normalized;
      };
      
      const normalizedSegmentSpeaker = normalizeSpeaker(segmentSpeaker);
      
      // Blue: repeated phrases - —Ç—ñ–ª—å–∫–∏ —è–∫—â–æ –Ω–∞–ª–µ–∂–∞—Ç—å –¥–æ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ —Å–ø—ñ–∫–µ—Ä–∞
      if (textAnalysis.Blue && Array.isArray(textAnalysis.Blue)) {
        textAnalysis.Blue.forEach(item => {
          if (segmentStart !== null && segmentEnd !== null) {
            const parsedStart = parseFloat(item.start);
            const parsedEnd = parseFloat(item.end);
            const itemStart = Number.isFinite(parsedStart) ? parsedStart : null;
            const itemEnd = Number.isFinite(parsedEnd) ? parsedEnd : itemStart;
            const hasItemTime = itemStart !== null && itemEnd !== null;
            if (hasItemTime) {
            if (!(itemStart < segmentEnd + timeTolerance && itemEnd > segmentStart - timeTolerance)) return;
            }
          }
          
          // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —Å–ø—ñ–∫–µ—Ä–∞: —è–∫—â–æ –≤–∫–∞–∑–∞–Ω–æ segmentSpeaker, —Ñ—ñ–ª—å—Ç—Ä—É—î–º–æ –∑–∞ —Å–ø—ñ–∫–µ—Ä–æ–º
          if (segmentSpeaker && item.speaker) {
            const normalizedItemSpeaker = normalizeSpeaker(item.speaker);
            // –Ø–∫—â–æ —Ñ—Ä–∞–∑–∞ –Ω–∞–ª–µ–∂–∏—Ç—å —ñ–Ω—à–æ–º—É —Å–ø—ñ–∫–µ—Ä—É, –≤–æ–Ω–∞ –º–∞—î –±—É—Ç–∏ –≤ Red, –∞ –Ω–µ –≤ Blue
            if (normalizedSegmentSpeaker && normalizedItemSpeaker && normalizedSegmentSpeaker !== normalizedItemSpeaker) {
              // –¶—è —Ñ—Ä–∞–∑–∞ –Ω–∞–ª–µ–∂–∏—Ç—å —ñ–Ω—à–æ–º—É —Å–ø—ñ–∫–µ—Ä—É - –Ω–µ –¥–æ–¥–∞—î–º–æ –≤ Blue, –≤–æ–Ω–∞ –±—É–¥–µ –≤ Red
              return;
            }
          }
          
          const wordPositions = findWordsInText(text, item.text);
          wordPositions.forEach(pos => {
            highlights.push({ ...pos, color: 'blue', type: 'repeated' });
          });
          
          if (wordPositions.length === 0) {
            const pos = findPhraseInText(text, item.text);
            if (pos) {
              highlights.push({ ...pos, color: 'blue', type: 'repeated' });
            }
          }
        });
      }

      // Green: overlaps - —Ç—ñ–ª—å–∫–∏ —è–∫—â–æ –Ω–∞–ª–µ–∂–∞—Ç—å –¥–æ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ —Å–ø—ñ–∫–µ—Ä–∞
      if (textAnalysis.Green && Array.isArray(textAnalysis.Green)) {
        textAnalysis.Green.forEach(item => {
          if (segmentStart !== null && segmentEnd !== null) {
            const parsedStart = parseFloat(item.start);
            const parsedEnd = parseFloat(item.end);
            const itemStart = Number.isFinite(parsedStart) ? parsedStart : null;
            const itemEnd = Number.isFinite(parsedEnd) ? parsedEnd : itemStart;
            const hasItemTime = itemStart !== null && itemEnd !== null;
            if (hasItemTime) {
            if (!(itemStart < segmentEnd + timeTolerance && itemEnd > segmentStart - timeTolerance)) return;
            }
          }
          
          // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —Å–ø—ñ–∫–µ—Ä–∞: —è–∫—â–æ –≤–∫–∞–∑–∞–Ω–æ segmentSpeaker, —Ñ—ñ–ª—å—Ç—Ä—É—î–º–æ –∑–∞ —Å–ø—ñ–∫–µ—Ä–æ–º
          if (segmentSpeaker && item.speaker) {
            const normalizedItemSpeaker = normalizeSpeaker(item.speaker);
            // –Ø–∫—â–æ —Ñ—Ä–∞–∑–∞ –Ω–∞–ª–µ–∂–∏—Ç—å —ñ–Ω—à–æ–º—É —Å–ø—ñ–∫–µ—Ä—É, –≤–æ–Ω–∞ –º–∞—î –±—É—Ç–∏ –≤ Red, –∞ –Ω–µ –≤ Green
            if (normalizedSegmentSpeaker && normalizedItemSpeaker && normalizedSegmentSpeaker !== normalizedItemSpeaker) {
              // –¶—è —Ñ—Ä–∞–∑–∞ –Ω–∞–ª–µ–∂–∏—Ç—å —ñ–Ω—à–æ–º—É —Å–ø—ñ–∫–µ—Ä—É - –Ω–µ –¥–æ–¥–∞—î–º–æ –≤ Green, –≤–æ–Ω–∞ –±—É–¥–µ –≤ Red
              return;
            }
          }
          
          const parts = item.text.split('|').map(p => p.trim()).filter(p => p.length > 0);
          parts.forEach(part => {
            const wordPositions = findWordsInText(text, part);
            wordPositions.forEach(pos => {
              highlights.push({ ...pos, color: 'green', type: 'overlap' });
            });
            
            if (wordPositions.length === 0) {
              const pos = findPhraseInText(text, part);
              if (pos) {
                highlights.push({ ...pos, color: 'green', type: 'overlap' });
              }
            }
          });
        });
      }

      // Red: discrepancies + —Ñ—Ä–∞–∑–∏ –∑ Blue/Green, —è–∫—ñ –Ω–∞–ª–µ–∂–∞—Ç—å —ñ–Ω—à–æ–º—É —Å–ø—ñ–∫–µ—Ä—É
      // –°–ø–æ—á–∞—Ç–∫—É –¥–æ–¥–∞—î–º–æ —Ñ—Ä–∞–∑–∏ –∑ Red
      if (textAnalysis.Red && Array.isArray(textAnalysis.Red)) {
        textAnalysis.Red.forEach(item => {
          if (segmentStart !== null && segmentEnd !== null) {
            const parsedStart = parseFloat(item.start);
            const parsedEnd = parseFloat(item.end);
            const itemStart = Number.isFinite(parsedStart) ? parsedStart : null;
            const itemEnd = Number.isFinite(parsedEnd) ? parsedEnd : itemStart;
            const hasItemTime = itemStart !== null && itemEnd !== null;
            if (hasItemTime) {
            if (!(itemStart < segmentEnd + timeTolerance && itemEnd > segmentStart - timeTolerance)) return;
            }
          }
          
          const wordPositions = findWordsInText(text, item.text);
          wordPositions.forEach(pos => {
            highlights.push({ ...pos, color: 'red', type: 'discrepancy' });
          });
          
          if (wordPositions.length === 0) {
            const pos = findPhraseInText(text, item.text);
            if (pos) {
              highlights.push({ ...pos, color: 'red', type: 'discrepancy' });
            }
          }
        });
      }
      
      // –î–æ–¥–∞—î–º–æ —Ñ—Ä–∞–∑–∏ –∑ Blue, —è–∫—ñ –Ω–∞–ª–µ–∂–∞—Ç—å —ñ–Ω—à–æ–º—É —Å–ø—ñ–∫–µ—Ä—É - –≤–æ–Ω–∏ –º–∞—é—Ç—å –±—É—Ç–∏ –≤ Red
      if (segmentSpeaker && textAnalysis.Blue && Array.isArray(textAnalysis.Blue)) {
        textAnalysis.Blue.forEach(item => {
          if (!item.speaker) return;
          
          if (segmentStart !== null && segmentEnd !== null) {
            const parsedStart = parseFloat(item.start);
            const parsedEnd = parseFloat(item.end);
            const itemStart = Number.isFinite(parsedStart) ? parsedStart : null;
            const itemEnd = Number.isFinite(parsedEnd) ? parsedEnd : itemStart;
            const hasItemTime = itemStart !== null && itemEnd !== null;
            if (hasItemTime) {
            if (!(itemStart < segmentEnd + timeTolerance && itemEnd > segmentStart - timeTolerance)) return;
            }
          }
          
          const normalizedItemSpeaker = normalizeSpeaker(item.speaker);
          // –Ø–∫—â–æ —Ñ—Ä–∞–∑–∞ –Ω–∞–ª–µ–∂–∏—Ç—å —ñ–Ω—à–æ–º—É —Å–ø—ñ–∫–µ—Ä—É, –≤–æ–Ω–∞ –º–∞—î –±—É—Ç–∏ –≤ Red
          if (normalizedSegmentSpeaker && normalizedItemSpeaker && normalizedSegmentSpeaker !== normalizedItemSpeaker) {
            const wordPositions = findWordsInText(text, item.text);
            wordPositions.forEach(pos => {
              highlights.push({ ...pos, color: 'red', type: 'wrong-speaker' });
            });
            
            if (wordPositions.length === 0) {
              const pos = findPhraseInText(text, item.text);
              if (pos) {
                highlights.push({ ...pos, color: 'red', type: 'wrong-speaker' });
              }
            }
          }
        });
      }
      
      // –î–æ–¥–∞—î–º–æ —Ñ—Ä–∞–∑–∏ –∑ Green, —è–∫—ñ –Ω–∞–ª–µ–∂–∞—Ç—å —ñ–Ω—à–æ–º—É —Å–ø—ñ–∫–µ—Ä—É - –≤–æ–Ω–∏ –º–∞—é—Ç—å –±—É—Ç–∏ –≤ Red
      if (segmentSpeaker && textAnalysis.Green && Array.isArray(textAnalysis.Green)) {
        textAnalysis.Green.forEach(item => {
          if (!item.speaker) return;
          
          if (segmentStart !== null && segmentEnd !== null) {
            const parsedStart = parseFloat(item.start);
            const parsedEnd = parseFloat(item.end);
            const itemStart = Number.isFinite(parsedStart) ? parsedStart : null;
            const itemEnd = Number.isFinite(parsedEnd) ? parsedEnd : itemStart;
            const hasItemTime = itemStart !== null && itemEnd !== null;
            if (hasItemTime) {
            if (!(itemStart < segmentEnd + timeTolerance && itemEnd > segmentStart - timeTolerance)) return;
            }
          }
          
          const normalizedItemSpeaker = normalizeSpeaker(item.speaker);
          // –Ø–∫—â–æ —Ñ—Ä–∞–∑–∞ –Ω–∞–ª–µ–∂–∏—Ç—å —ñ–Ω—à–æ–º—É —Å–ø—ñ–∫–µ—Ä—É, –≤–æ–Ω–∞ –º–∞—î –±—É—Ç–∏ –≤ Red
          if (normalizedSegmentSpeaker && normalizedItemSpeaker && normalizedSegmentSpeaker !== normalizedItemSpeaker) {
            const parts = item.text.split('|').map(p => p.trim()).filter(p => p.length > 0);
            parts.forEach(part => {
              const wordPositions = findWordsInText(text, part);
              wordPositions.forEach(pos => {
                highlights.push({ ...pos, color: 'red', type: 'wrong-speaker' });
              });
              
              if (wordPositions.length === 0) {
                const pos = findPhraseInText(text, part);
                if (pos) {
                  highlights.push({ ...pos, color: 'red', type: 'wrong-speaker' });
                }
              }
            });
          }
        });
      }

      if (highlights.length === 0) {
        return escapeHtml(text);
      }
      
      // Sort by position
      highlights.sort((a, b) => a.start - b.start);

      // Merge overlapping highlights (priority: Red > Green > Blue)
      const merged = [];
      const priority = { red: 3, green: 2, blue: 1 };
      
      for (let i = 0; i < highlights.length; i++) {
        let current = { ...highlights[i] };
        for (let j = i + 1; j < highlights.length && highlights[j].start < current.end; j++) {
          current.end = Math.max(current.end, highlights[j].end);
          if (priority[highlights[j].color] > priority[current.color]) {
            current.color = highlights[j].color;
            current.type = highlights[j].type;
          }
          i = j;
        }
        merged.push(current);
      }

      // Build HTML
      let result = '';
      let lastIndex = 0;

      merged.forEach(highlight => {
        if (highlight.start > lastIndex) {
          result += escapeHtml(text.substring(lastIndex, highlight.start));
        }
        
        const highlightedText = text.substring(highlight.start, Math.min(highlight.end, text.length));
        const bgColor = highlight.color === 'blue' ? '#dbeafe' : highlight.color === 'green' ? '#d1fae5' : '#fee2e2';
        const textColor = highlight.color === 'blue' ? '#1e40af' : highlight.color === 'green' ? '#065f46' : '#991b1b';
        result += `<span class="text-highlight-${highlight.color}" data-type="${highlight.type}" style="background-color: ${bgColor}; color: ${textColor}; padding: 2px 0; border-radius: 2px;">${escapeHtml(highlightedText)}</span>`;
        lastIndex = Math.min(highlight.end, text.length);
      });

      if (lastIndex < text.length) {
        result += escapeHtml(text.substring(lastIndex));
      }

      return result;
    }
    */
    
    // Highlight fragments of cell text using textAnalysis
    // –ó–ê–ö–û–ú–ï–ù–¢–û–í–ê–ù–û: –õ–æ–≥—ñ–∫–∞ –≤–∏–¥—ñ–ª–µ–Ω–Ω—è —Ñ—Ä–∞–≥–º–µ–Ω—Ç—ñ–≤ —Ç–∏–º—á–∞—Å–æ–≤–æ –≤–∏–º–∫–Ω–µ–Ω–∞ –∑–∞ –≤–∏–º–æ–≥–æ—é –∑–∞–º–æ–≤–Ω–∏–∫–∞
    /*
    function highlightOriginalText(cellText, originalSegments, textAnalysis, segmentStart = null, segmentEnd = null, segmentSpeaker = null) {
      if (!textAnalysis || !cellText) {
      return escapeHtml(cellText || '');
      }
      
      // Use the same highlighting logic as app.js, –ø–µ—Ä–µ–¥–∞—î–º–æ —Å–ø—ñ–∫–µ—Ä–∞ –¥–ª—è —Ñ—ñ–ª—å—Ç—Ä–∞—Ü—ñ—ó
      return highlightTextWithColors(cellText, textAnalysis, segmentStart, segmentEnd, segmentSpeaker);
    }
    */
    
    // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è –∫–µ—à—É LLM
    async function saveLLMCache() {
      const btn = document.getElementById('saveCacheBtn');
      const originalText = btn.innerHTML;
      
      // –ü–æ–∫–∞–∑—É—î–º–æ —ñ–Ω–¥–∏–∫–∞—Ç–æ—Ä –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è
      btn.disabled = true;
      btn.style.opacity = '0.6';
      btn.style.cursor = 'not-allowed';
      btn.innerHTML = '‚è≥ Saving...';
      
      try {
        const response = await fetch('/api/save-llm-cache', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          }
        });
        
        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'Failed to save cache');
        }
        
        // –û—Ç—Ä–∏–º—É—î–º–æ blob –¥–ª—è –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è
        const blob = await response.blob();
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `llm-cache-backup-${new Date().toISOString().split('T')[0]}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        window.URL.revokeObjectURL(url);
        
        // –ü–æ–∫–∞–∑—É—î–º–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –ø—Ä–æ —É—Å–ø—ñ—Ö
        const successMsg = document.createElement('div');
        successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #10b981; color: white; padding: 12px 20px; border-radius: 8px; z-index: 10000; box-shadow: 0 4px 6px rgba(0,0,0,0.1);';
        successMsg.innerHTML = '‚úÖ Cache saved successfully!';
        document.body.appendChild(successMsg);
        setTimeout(() => successMsg.remove(), 3000);
      } catch (error) {
        console.error('‚ùå [saveLLMCache] Error:', error);
        alert(`‚ùå Failed to save cache: ${error.message}`);
      } finally {
        // –í—ñ–¥–Ω–æ–≤–ª—é—î–º–æ –∫–Ω–æ–ø–∫—É
        btn.disabled = false;
        btn.style.opacity = '1';
        btn.style.cursor = 'pointer';
        btn.innerHTML = originalText;
      }
    }
    
    // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –æ—á–∏—â–µ–Ω–Ω—è –∫–µ—à—É LLM
    async function clearLLMCache() {
      const btn = document.getElementById('clearCacheBtn');
      if (!btn) {
        console.error('[clearLLMCache] Button not found');
        alert('Clear cache button not found');
        return;
      }
      
      const originalText = btn.innerHTML;
      
      if (!confirm('‚ö†Ô∏è Are you sure you want to clear the LLM cache? This will remove all cached LLM responses.')) {
        return;
      }
      
      // –ü–æ–∫–∞–∑—É—î–º–æ —ñ–Ω–¥–∏–∫–∞—Ç–æ—Ä –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è
      btn.disabled = true;
      btn.style.opacity = '0.6';
      btn.style.cursor = 'not-allowed';
      btn.innerHTML = '‚è≥ Clearing...';
      
      try {
        const response = await fetch('/api/clear-llm-cache', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          }
        });
        
        const result = await response.json();
        
        if (response.ok) {
          // –ü–æ–∫–∞–∑—É—î–º–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –ø—Ä–æ —É—Å–ø—ñ—Ö
          const successMsg = document.createElement('div');
          successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #10b981; color: white; padding: 12px 20px; border-radius: 8px; z-index: 10000; box-shadow: 0 4px 6px rgba(0,0,0,0.1);';
          successMsg.innerHTML = `‚úÖ Cache cleared! Removed ${result.deletedCount || 0} files`;
          document.body.appendChild(successMsg);
          setTimeout(() => successMsg.remove(), 5000);
        } else {
          throw new Error(result.error || 'Failed to clear cache');
        }
      } catch (error) {
        console.error('‚ùå [clearLLMCache] Error:', error);
        alert(`‚ùå Failed to clear cache: ${error.message}`);
      } finally {
        // –í—ñ–¥–Ω–æ–≤–ª—é—î–º–æ –∫–Ω–æ–ø–∫—É
        btn.disabled = false;
        btn.style.opacity = '1';
        btn.style.cursor = 'pointer';
        btn.innerHTML = originalText;
      }
    }
    
    // ============================================
    // –î–û–ü–û–ú–Ü–ñ–ù–Ü –§–£–ù–ö–¶–Ü–á –î–õ–Ø –û–ß–Ü–ö–£–í–ê–ù–ù–Ø –¢–ê –ü–ï–†–ï–í–Ü–†–û–ö
    // ============================================
    
    // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –æ—á—ñ–∫—É–≤–∞–Ω–Ω—è –ø–æ—è–≤–∏ –µ–ª–µ–º–µ–Ω—Ç–∞ –≤ DOM
    async function waitForElement(selector, maxAttempts = 50, interval = 100) {
      return new Promise((resolve, reject) => {
        let attempts = 0;
        const startTime = Date.now();
        console.log(`üîç [waitForElement] Starting to wait for: ${selector}`);
        
        const check = () => {
          attempts++;
          const element = document.querySelector(selector);
          if (element) {
            const elapsed = Date.now() - startTime;
            console.log(`‚úÖ [waitForElement] Found ${selector} after ${attempts} attempts (${elapsed}ms)`);
            resolve(element);
          } else if (attempts >= maxAttempts) {
            const elapsed = Date.now() - startTime;
            console.error(`‚ùå [waitForElement] ${selector} not found after ${attempts} attempts (${elapsed}ms)`);
            reject(new Error(`Element ${selector} not found after ${maxAttempts} attempts`));
          } else {
            if (attempts % 10 === 0) {
              console.log(`‚è≥ [waitForElement] Still waiting for ${selector}... (attempt ${attempts}/${maxAttempts})`);
            }
            setTimeout(check, interval);
          }
        };
        check();
      });
    }
    
    // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –æ—á—ñ–∫—É–≤–∞–Ω–Ω—è –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç—ñ UI (–º–æ–¥–∞–ª—å–Ω–µ –≤—ñ–∫–Ω–æ –≤—ñ–¥–∫—Ä–∏—Ç–µ, –µ–ª–µ–º–µ–Ω—Ç–∏ –¥–æ—Å—Ç—É–ø–Ω—ñ)
    async function waitForUIReady() {
      const startTime = Date.now();
      console.log('üîÑ [waitForUIReady] Starting UI readiness check...');
      
      try {
        // –ö—Ä–æ–∫ 1: –ß–µ–∫–∞—î–º–æ, –ø–æ–∫–∏ –º–æ–¥–∞–ª—å–Ω–µ –≤—ñ–∫–Ω–æ –≤—ñ–¥–∫—Ä–∏—î—Ç—å—Å—è
        console.log('üìã [waitForUIReady] Step 1: Waiting for debugModal...');
        const debugModal = await waitForElement('#debugModal', 20, 50);
        console.log('‚úÖ [waitForUIReady] Step 1: debugModal found, display:', debugModal.style.display);
        
        if (debugModal.style.display === 'none') {
          console.log('üîÑ [waitForUIReady] Modal is closed, opening it...');
          showDebugModal();
          await new Promise(resolve => setTimeout(resolve, 200));
          console.log('‚úÖ [waitForUIReady] Modal opened, new display:', debugModal.style.display);
        }
        
        // –ö—Ä–æ–∫ 2: –ß–µ–∫–∞—î–º–æ, –ø–æ–∫–∏ groundTruthTextarea –∑'—è–≤–∏—Ç—å—Å—è
        console.log('üìã [waitForUIReady] Step 2: Waiting for groundTruthTextarea...');
        const groundTruthTextarea = await waitForElement('#groundTruthTextarea', 20, 50);
        console.log('‚úÖ [waitForUIReady] Step 2: groundTruthTextarea found', {
          hasValue: !!groundTruthTextarea.value,
          valueLength: groundTruthTextarea.value?.length || 0
        });
        
        // –ö—Ä–æ–∫ 3: –ß–µ–∫–∞—î–º–æ, –ø–æ–∫–∏ –∫–Ω–æ–ø–∫–∞ Run –∑'—è–≤–∏—Ç—å—Å—è
        console.log('üìã [waitForUIReady] Step 3: Waiting for runBtn...');
        const runBtn = await waitForElement('#runBtn', 20, 50);
        console.log('‚úÖ [waitForUIReady] Step 3: runBtn found', {
          disabled: runBtn.disabled,
          innerHTML: runBtn.innerHTML.substring(0, 50)
        });
        
        const elapsed = Date.now() - startTime;
        console.log(`‚úÖ [waitForUIReady] All UI elements ready! (${elapsed}ms)`);
        
        return { debugModal, groundTruthTextarea, runBtn };
      } catch (error) {
        const elapsed = Date.now() - startTime;
        console.error(`‚ùå [waitForUIReady] Error after ${elapsed}ms:`, error);
        throw error;
      }
    }
    
    // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –æ—á—ñ–∫—É–≤–∞–Ω–Ω—è –ø–æ—è–≤–∏ JSON –≤ groundTruthTextarea
    async function waitForJSONInTextarea(textarea, maxAttempts = 50, interval = 100) {
      return new Promise((resolve, reject) => {
        let attempts = 0;
        const startTime = Date.now();
        console.log('üîÑ [waitForJSONInTextarea] Starting to wait for JSON...');
        
        const check = () => {
          attempts++;
          const value = textarea.value.trim();
          
          if (attempts === 1) {
            console.log('üìã [waitForJSONInTextarea] Initial textarea value:', {
              hasValue: !!value,
              valueLength: value.length,
              startsWithBrace: value.startsWith('{'),
              preview: value.substring(0, 100)
            });
          }
          
          if (value && value.startsWith('{')) {
            try {
              const parsed = JSON.parse(value);
              if (parsed && parsed.originalReplicas && Array.isArray(parsed.originalReplicas)) {
                const elapsed = Date.now() - startTime;
                console.log(`‚úÖ [waitForJSONInTextarea] Valid JSON found after ${attempts} attempts (${elapsed}ms)`, {
                  originalReplicasCount: parsed.originalReplicas.length,
                  nextLevelReplicasCount: parsed.nextLevelReplicas?.length || 0
                });
                resolve(parsed);
                return;
              } else {
                if (attempts % 10 === 0) {
                  console.log(`‚è≥ [waitForJSONInTextarea] JSON found but missing originalReplicas array (attempt ${attempts})`);
                }
              }
            } catch (e) {
              if (attempts % 10 === 0) {
                console.log(`‚è≥ [waitForJSONInTextarea] JSON parse error (attempt ${attempts}):`, e.message);
              }
            }
          } else {
            if (attempts % 10 === 0) {
              console.log(`‚è≥ [waitForJSONInTextarea] Still waiting for JSON... (attempt ${attempts}/${maxAttempts})`, {
                hasValue: !!value,
                valueLength: value.length,
                preview: value.substring(0, 50)
              });
            }
          }
          
          if (attempts >= maxAttempts) {
            const elapsed = Date.now() - startTime;
            console.error(`‚ùå [waitForJSONInTextarea] Timeout after ${attempts} attempts (${elapsed}ms)`, {
              finalValue: textarea.value.substring(0, 200)
            });
            reject(new Error(`JSON not found in textarea after ${maxAttempts} attempts`));
          } else {
            setTimeout(check, interval);
          }
        };
        check();
      });
    }
    
    // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –æ—á—ñ–∫—É–≤–∞–Ω–Ω—è –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç—ñ —Ç–∞–±–ª–∏—Ü—ñ –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è
    async function waitForComparisonTable(maxAttempts = 30, interval = 200) {
      return new Promise((resolve, reject) => {
        let attempts = 0;
        const startTime = Date.now();
        console.log('üîÑ [waitForComparisonTable] Starting to wait for comparison table...');
        
        const check = () => {
          attempts++;
          const comparisonContainer = document.getElementById('comparisonTableContainer');
          const table = comparisonContainer?.querySelector('table.comparison-table') || 
                        comparisonContainer?.querySelector('table');
          
          const rowCount = table ? table.querySelectorAll('tbody tr, tr').length : 0;
          
          if (table && rowCount > 1) {
            const elapsed = Date.now() - startTime;
            console.log(`‚úÖ [waitForComparisonTable] Table ready after ${attempts} attempts (${elapsed}ms)`, {
              rowCount: rowCount
            });
            resolve(table);
          } else if (attempts >= maxAttempts) {
            const elapsed = Date.now() - startTime;
            console.error(`‚ùå [waitForComparisonTable] Timeout after ${attempts} attempts (${elapsed}ms)`, {
              containerExists: !!comparisonContainer,
              tableExists: !!table,
              rowCount: rowCount
            });
            reject(new Error(`Comparison table not ready after ${maxAttempts} attempts`));
          } else {
            if (attempts % 5 === 0) {
              console.log(`‚è≥ [waitForComparisonTable] Still waiting... (attempt ${attempts}/${maxAttempts})`, {
                containerExists: !!comparisonContainer,
                tableExists: !!table,
                rowCount: rowCount
              });
            }
            setTimeout(check, interval);
          }
        };
        check();
      });
    }
    
    // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –æ–±—Ä–æ–±–∫–∏ –Ω–∞—Ç–∏—Å–∫–∞–Ω–Ω—è –∫–Ω–æ–ø–∫–∏ "Load Dialogue"
    function handleLoadDialogue() {
      // –ó–∞–≤–∂–¥–∏ –≤—ñ–¥–∫—Ä–∏–≤–∞—î–º–æ file picker –¥–ª—è –≤–∏–±–æ—Ä—É —Ñ–∞–π–ª—É
      console.log('üîÑ [handleLoadDialogue] Opening file picker...');
      const loadDialogueInput = document.getElementById('loadDialogueInput');
      if (loadDialogueInput) {
        loadDialogueInput.click();
      } else {
        console.error('‚ùå [handleLoadDialogue] loadDialogueInput not found!');
        alert('‚ö†Ô∏è –ü–æ–º–∏–ª–∫–∞: –ø–æ–ª–µ –≤–∏–±–æ—Ä—É —Ñ–∞–π–ª—É –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ');
      }
    }
    
    // –û–∫—Ä–µ–º–∞ —Ñ—É–Ω–∫—Ü—ñ—è –¥–ª—è –æ–±—Ä–æ–±–∫–∏ –≤–∂–µ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ–≥–æ –¥—ñ–∞–ª–æ–≥—É (–º–æ–∂–Ω–∞ –≤–∏–∫–ª–∏–∫–∞—Ç–∏ –≤—Ä—É—á–Ω—É –∞–±–æ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ)
    async function processExistingDialogue() {
      // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ —î –≤–∂–µ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–∏–π —Ñ–∞–π–ª (—Å–ø–æ—á–∞—Ç–∫—É –∑ window, –ø–æ—Ç—ñ–º –∑ localStorage)
      let uploadedText = window.uploadedDialogueText;
      
      if (!uploadedText) {
        // –°–ø—Ä–æ–±—É—î–º–æ –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –∑ localStorage
        try {
          const savedText = localStorage.getItem('uploadedDialogueText');
          if (savedText) {
            uploadedText = savedText;
            window.uploadedDialogueText = uploadedText;
            console.log('‚úÖ [processExistingDialogue] Loaded dialogue from localStorage');
          }
        } catch (e) {
          console.warn('‚ö†Ô∏è [processExistingDialogue] Failed to load from localStorage:', e);
        }
      }
      
      if (uploadedText) {
        console.log('üîÑ [processExistingDialogue] Found uploaded dialogue, processing...', {
          textLength: uploadedText.length,
          hasText: !!uploadedText
        });
        await processUploadedDialogue();
      } else {
        alert('‚ö†Ô∏è –§–∞–π–ª –¥—ñ–∞–ª–æ–≥—É –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ. –ë—É–¥—å –ª–∞—Å–∫–∞, —Å–ø–æ—á–∞—Ç–∫—É –∑–∞–≤–∞–Ω—Ç–∞–∂—Ç–µ —Ñ–∞–π–ª —á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫—É "üìÅ Load Dialogue".');
      }
    }
    
    // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –æ–±—Ä–æ–±–∫–∏ –≤–∂–µ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ–≥–æ –¥—ñ–∞–ª–æ–≥—É
    async function processUploadedDialogue() {
      try {
        // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ —î –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–∏–π —Ñ–∞–π–ª (—Å–ø–æ—á–∞—Ç–∫—É –∑ window, –ø–æ—Ç—ñ–º –∑ localStorage)
        let uploadedText = window.uploadedDialogueText;
        
        if (!uploadedText) {
          // –°–ø—Ä–æ–±—É—î–º–æ –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –∑ localStorage
          try {
            const savedText = localStorage.getItem('uploadedDialogueText');
            if (savedText) {
              uploadedText = savedText;
              window.uploadedDialogueText = uploadedText;
              console.log('‚úÖ [processUploadedDialogue] Loaded dialogue from localStorage');
            }
          } catch (e) {
            console.warn('‚ö†Ô∏è [processUploadedDialogue] Failed to load from localStorage:', e);
          }
        }
        
        if (!uploadedText) {
          alert('‚ö†Ô∏è –§–∞–π–ª –¥—ñ–∞–ª–æ–≥—É –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ. –ë—É–¥—å –ª–∞—Å–∫–∞, —Å–ø–æ—á–∞—Ç–∫—É –∑–∞–≤–∞–Ω—Ç–∞–∂—Ç–µ —Ñ–∞–π–ª —á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫—É "üìÅ Load Dialogue".');
          return;
        }
        
        console.log('üîÑ [processUploadedDialogue] Processing uploaded dialogue...', {
          textLength: uploadedText.length,
          preview: uploadedText.substring(0, 100)
        });
        
        // –ö—Ä–æ–∫ 1: –û—á—ñ–∫—É—î–º–æ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç—ñ UI
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        console.log('üöÄ [processUploadedDialogue] STARTING');
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        console.log('üìã [processUploadedDialogue] Input data:', {
          textLength: uploadedText.length,
          preview: uploadedText.substring(0, 100)
        });
        
        const processStartTime = Date.now();
        console.log('üìã [processUploadedDialogue] STEP 1: Waiting for UI to be ready...');
        const { groundTruthTextarea, runBtn } = await waitForUIReady();
        console.log('‚úÖ [processUploadedDialogue] STEP 1: UI ready');
        
        // –ö—Ä–æ–∫ 2: –ó–∞–ø–æ–≤–Ω—é—î–º–æ textarea
        console.log('üìã [processUploadedDialogue] STEP 2: Filling textarea...');
        console.log('üìã [processUploadedDialogue] Textarea state before:', {
          hasValue: !!groundTruthTextarea.value,
          valueLength: groundTruthTextarea.value?.length || 0
        });
        
        groundTruthTextarea.value = uploadedText;
        console.log('‚úÖ [processUploadedDialogue] STEP 2: Textarea filled', {
          valueLength: groundTruthTextarea.value.length,
          preview: groundTruthTextarea.value.substring(0, 50)
        });
        
        // –ö—Ä–æ–∫ 3: –ù–∞—Ç–∏—Å–∫–∞—î–º–æ –∫–Ω–æ–ø–∫—É Run
        console.log('üìã [processUploadedDialogue] STEP 3: Preparing to click Run button...');
        console.log('üìã [processUploadedDialogue] Run button state before:', {
          innerHTML: runBtn.innerHTML,
          disabled: runBtn.disabled,
          opacity: runBtn.style.opacity
        });
        
        runBtn.innerHTML = '‚ñ∂Ô∏è Run';
        runBtn.disabled = false;
        runBtn.style.opacity = '1';
        runBtn.style.cursor = 'pointer';
        
        console.log('üìã [processUploadedDialogue] Run button state after:', {
          innerHTML: runBtn.innerHTML,
          disabled: runBtn.disabled,
          opacity: runBtn.style.opacity
        });
        
        console.log('üîÑ [processUploadedDialogue] STEP 3: Clicking Run button...');
        runBtn.click();
        
        const elapsed = Date.now() - processStartTime;
        console.log(`‚úÖ [processUploadedDialogue] STEP 3: Run button clicked (${elapsed}ms)`);
        console.log('‚è≥ [processUploadedDialogue] Now waiting for runDebugActionNew() to process...');
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        
      } catch (error) {
        console.error('‚ùå [processUploadedDialogue] Error:', error);
        alert(`‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ–±—Ä–æ–±—Ü—ñ –¥—ñ–∞–ª–æ–≥—É: ${error.message}`);
      }
    }
    
    // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –¥—ñ–∞–ª–æ–≥—É –∑ —Ñ–∞–π–ª—É
    async function loadDialogueFile(event) {
      const file = event.target.files[0];
      if (!file) {
        return;
      }
      
      // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª—É
      const fileName = file.name.toLowerCase();
      const validExtensions = ['.txt', '.md', '.json'];
      const isValidFormat = validExtensions.some(ext => fileName.endsWith(ext));
      
      if (!isValidFormat) {
        alert('‚ùå –ù–µ–ø—ñ–¥—Ç—Ä–∏–º—É–≤–∞–Ω–∏–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª—É. –ü—ñ–¥—Ç—Ä–∏–º—É—é—Ç—å—Å—è —Ç—ñ–ª—å–∫–∏: .txt, .md, .json');
        event.target.value = ''; // –û—á–∏—â–∞—î–º–æ input
        return;
      }
      
      const reader = new FileReader();
      
      reader.onload = async function(e) {
        try {
          const content = e.target.result;
          // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ —Å–∏—Ä–∏–π –≤–º—ñ—Å—Ç —Ñ–∞–π–ª—É –±–µ–∑ –±—É–¥—å-—è–∫–æ–≥–æ —Ñ–æ—Ä–º–∞—Ç—É–≤–∞–Ω–Ω—è
          const textContent = content;
          
          // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–∏–π —Ç–µ–∫—Å—Ç –≥–ª–æ–±–∞–ª—å–Ω–æ
          window.uploadedDialogueText = textContent;
          
          // –¢–∞–∫–æ–∂ –∑–±–µ—Ä—ñ–≥–∞—î–º–æ –≤ localStorage –¥–ª—è –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è –ø—ñ—Å–ª—è –ø–µ—Ä–µ–∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è
          try {
            localStorage.setItem('uploadedDialogueText', textContent);
            console.log('‚úÖ [loadDialogueFile] Saved dialogue to localStorage');
          } catch (e) {
            console.warn('‚ö†Ô∏è [loadDialogueFile] Failed to save to localStorage:', e);
          }
          
          // –í—ñ–¥–æ–±—Ä–∞–∂–∞—î–º–æ –≤–º—ñ—Å—Ç —É debug textarea (—è–∫—â–æ —î)
          const debugTextarea = document.getElementById('debugTextarea');
          if (debugTextarea) {
            debugTextarea.value = textContent;
          }
          
          // –ó–∞–ø–æ–≤–Ω—é—î–º–æ groundTruthTextarea —Ç–∞ –≤—ñ–¥–∫—Ä–∏–≤–∞—î–º–æ –º–æ–¥–∞–ª—å–Ω–µ –≤—ñ–∫–Ω–æ
          const groundTruthTextarea = document.getElementById('groundTruthTextarea');
          const debugModal = document.getElementById('debugModal');
          
          if (groundTruthTextarea) {
            groundTruthTextarea.value = textContent;
            console.log('‚úÖ [loadDialogueFile] File content loaded into groundTruthTextarea');
          }
          
          // –í—ñ–¥–∫—Ä–∏–≤–∞—î–º–æ debug –º–æ–¥–∞–ª—å–Ω–µ –≤—ñ–∫–Ω–æ, —è–∫—â–æ –≤–æ–Ω–æ —â–µ –Ω–µ –≤—ñ–¥–∫—Ä–∏—Ç–µ
          if (debugModal && debugModal.style.display === 'none') {
            showDebugModal();
          }
          
          // –í—ñ–¥–ø—Ä–∞–≤–ª—è—î–º–æ –Ω–∞ –±–µ–∫–µ–Ω–¥ –¥–ª—è –∑–±–µ—Ä—ñ–≥–∞–Ω–Ω—è
          try {
            const response = await fetch('/api/dialogue-scripts', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                text: textContent,
                lines: textContent.split('\n').map(line => line.trim()).filter(Boolean),
                meta: {
                  fileName: file.name,
                  uploadedAt: new Date().toISOString()
                }
              })
            });
            
            if (!response.ok) {
              throw new Error('Failed to save dialogue to server');
            }
            
            const result = await response.json();
            console.log('‚úÖ Dialogue saved to server:', result);
            
            // –Ø–∫—â–æ —î —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏ –¥—ñ–∞—Ä–∏–∑–∞—Ü—ñ—ó, –∑–∞–ø—É—Å–∫–∞—î–º–æ –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è
            if (currentAnalysisData) {
              console.log('üîÑ Triggering comparison with diarization results...');
              
              const compareResponse = await fetch('/api/compare-with-dialogue', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  groundTruthText: textContent,
                  diarizationData: currentAnalysisData
                })
              });
              
              if (compareResponse.ok) {
                const compareResult = await compareResponse.json();
                console.log('‚úÖ Comparison completed:', compareResult);
                
                // –û–Ω–æ–≤–ª—é—î–º–æ currentAnalysisData –∑ –º–µ—Ç—Ä–∏–∫–∞–º–∏ –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è
                currentAnalysisData.groundTruthMetrics = compareResult.groundTruthMetrics;
                currentAnalysisData.uploadedDialogueText = textContent;
                
                // –ü–µ—Ä–µ–º–∞–ª—å–æ–≤—É—î–º–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏ –∑ –Ω–æ–≤–∏–º–∏ –º–µ—Ç—Ä–∏–∫–∞–º–∏
                showResults(currentAnalysisData);
                
                // –ü–æ–∫–∞–∑—É—î–º–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –ø—Ä–æ —É—Å–ø—ñ—Ö
                const successMsg = document.createElement('div');
                successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #10b981; color: white; padding: 12px 20px; border-radius: 8px; z-index: 10000; box-shadow: 0 4px 6px rgba(0,0,0,0.1);';
                const nextLevelPercent = compareResult.groundTruthMetrics?.nextLevel?.matchPercent || 'N/A';
                const speechmaticsPercent = compareResult.groundTruthMetrics?.speechmatics?.matchPercent || 'N/A';
                successMsg.innerHTML = `
                  <div style="font-weight: 600; margin-bottom: 5px;">‚úÖ Dialogue uploaded and compared!</div>
                  <div style="font-size: 13px;">NextLevel: ${nextLevelPercent}% | Speechmatics: ${speechmaticsPercent}%</div>
                `;
                document.body.appendChild(successMsg);
                setTimeout(() => successMsg.remove(), 5000);
              } else {
                const errorData = await compareResponse.json();
                throw new Error(errorData.error || 'Comparison failed');
              }
            } else {
              // –ù–µ–º–∞—î —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤ –¥—ñ–∞—Ä–∏–∑–∞—Ü—ñ—ó - –ø—Ä–æ—Å—Ç–æ –∑–±–µ—Ä—ñ–≥–∞—î–º–æ
              const successMsg = document.createElement('div');
              successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #10b981; color: white; padding: 12px 20px; border-radius: 8px; z-index: 10000; box-shadow: 0 4px 6px rgba(0,0,0,0.1);';
              successMsg.innerHTML = `‚úÖ –§–∞–π–ª "${file.name}" —É—Å–ø—ñ—à–Ω–æ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ!<br><small>–ü—ñ—Å–ª—è –æ–±—Ä–æ–±–∫–∏ –∞—É–¥—ñ–æ –±—É–¥–µ –≤–∏–∫–æ–Ω–∞–Ω–æ –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è.</small>`;
              document.body.appendChild(successMsg);
              setTimeout(() => successMsg.remove(), 3000);
            }
            
            // –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –∑–∞–ø—É—Å–∫–∞—î–º–æ –æ–±—Ä–æ–±–∫—É –ø—ñ—Å–ª—è –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —Ñ–∞–π–ª—É
            // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ async —Ñ—É–Ω–∫—Ü—ñ—é –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ –æ—á—ñ–∫—É–≤–∞–Ω–Ω—è
            (async () => {
              const processStartTime = Date.now();
              console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
              console.log('üöÄ [loadDialogueFile] STARTING AUTO-PROCESSING PIPELINE');
              console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
              
              try {
                // –ö—Ä–æ–∫ 1: –û—á—ñ–∫—É—î–º–æ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç—ñ UI
                console.log('üìã [loadDialogueFile] STEP 1: Waiting for UI to be ready...');
                const { groundTruthTextarea, runBtn } = await waitForUIReady();
                console.log('‚úÖ [loadDialogueFile] STEP 1: UI ready');
                
                // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —â–æ textarea –∑–∞–ø–æ–≤–Ω–µ–Ω–∏–π
                console.log('üìã [loadDialogueFile] STEP 1.1: Checking textarea content...');
                if (!groundTruthTextarea.value || !groundTruthTextarea.value.trim()) {
                  console.log('‚ö†Ô∏è [loadDialogueFile] Textarea is empty, filling it...');
                  groundTruthTextarea.value = textContent;
                } else {
                  console.log('‚úÖ [loadDialogueFile] Textarea already has content:', {
                    length: groundTruthTextarea.value.length,
                    preview: groundTruthTextarea.value.substring(0, 50)
                  });
                }
                
                // –ö—Ä–æ–∫ 2: –ù–∞—Ç–∏—Å–∫–∞—î–º–æ –∫–Ω–æ–ø–∫—É Run
                console.log('üìã [loadDialogueFile] STEP 2: Preparing to click Run button...');
                console.log('üìã [loadDialogueFile] Run button state before:', {
                  innerHTML: runBtn.innerHTML,
                  disabled: runBtn.disabled,
                  opacity: runBtn.style.opacity
                });
                
                runBtn.innerHTML = '‚ñ∂Ô∏è Run';
                runBtn.disabled = false;
                runBtn.style.opacity = '1';
                runBtn.style.cursor = 'pointer';
                
                console.log('üìã [loadDialogueFile] Run button state after:', {
                  innerHTML: runBtn.innerHTML,
                  disabled: runBtn.disabled,
                  opacity: runBtn.style.opacity
                });
                
                console.log('üîÑ [loadDialogueFile] STEP 2: Clicking Run button...');
                runBtn.click();
                
                const elapsed = Date.now() - processStartTime;
                console.log(`‚úÖ [loadDialogueFile] STEP 2: Run button clicked (${elapsed}ms)`);
                console.log('‚è≥ [loadDialogueFile] Now waiting for runDebugActionNew() to process...');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
              } catch (error) {
                const elapsed = Date.now() - processStartTime;
                console.error(`‚ùå [loadDialogueFile] ERROR in auto-processing after ${elapsed}ms:`, error);
                console.error('‚ùå [loadDialogueFile] Error stack:', error.stack);
              }
            })();
          } catch (error) {
            console.error('‚ùå [loadDialogueFile] Error saving/comparing:', error);
            alert(`‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—ñ/–ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—ñ: ${error.message}`);
          }
        } catch (error) {
          console.error('‚ùå [loadDialogueFile] Error:', error);
          alert(`‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—ñ —Ñ–∞–π–ª—É: ${error.message}`);
        }
      };
      
      reader.onerror = function() {
        alert('‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ —á–∏—Ç–∞–Ω–Ω—ñ —Ñ–∞–π–ª—É');
        event.target.value = ''; // –û—á–∏—â–∞—î–º–æ input
      };
      
      // –ß–∏—Ç–∞—î–º–æ —Ñ–∞–π–ª —è–∫ —Ç–µ–∫—Å—Ç
      reader.readAsText(file);
      
      // –û—á–∏—â–∞—î–º–æ input, —â–æ–± –º–æ–∂–Ω–∞ –±—É–ª–æ –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ —Ç–æ–π —Å–∞–º–∏–π —Ñ–∞–π–ª –∑–Ω–æ–≤—É
      setTimeout(() => {
        event.target.value = '';
      }, 100);
    }
    
    // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –≤—ñ–¥–∫—Ä–∏—Ç—Ç—è –º–æ–¥–∞–ª—å–Ω–æ–≥–æ –≤—ñ–∫–Ω–∞ –∑ debug –¥–∞–Ω–∏–º–∏
    function showDebugModal() {
      // –ü–æ–∫–∞–∑—É—î–º–æ –º–æ–¥–∞–ª—å–Ω–µ –≤—ñ–∫–Ω–æ
      const debugModal = document.getElementById('debugModal');
      if (debugModal) {
        debugModal.style.display = 'flex';
        
        // –Ø–∫—â–æ –ø–æ–ª–µ –≤–∂–µ –º–∞—î –≤–º—ñ—Å—Ç (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–∏–π —Ñ–∞–π–ª), –Ω–µ –æ—á–∏—â–∞—î–º–æ –π–æ–≥–æ
        // –ê–ª–µ –ø–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –ø—ñ—Å–ª—è –Ω–µ–≤–µ–ª–∏–∫–æ—ó –∑–∞—Ç—Ä–∏–º–∫–∏, —â–æ–± DOM –≤—Å—Ç–∏–≥ –æ–Ω–æ–≤–∏—Ç–∏—Å—è
        setTimeout(() => {
          const groundTruthTextarea = document.getElementById('groundTruthTextarea');
          if (groundTruthTextarea) {
            // –Ø–∫—â–æ –ø–æ–ª–µ –ø–æ—Ä–æ–∂–Ω—î, –∞–ª–µ —î –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–∏–π –¥—ñ–∞–ª–æ–≥, –∑–∞–ø–æ–≤–Ω—é—î–º–æ –π–æ–≥–æ
            if (!groundTruthTextarea.value && window.uploadedDialogueText) {
              groundTruthTextarea.value = window.uploadedDialogueText;
              console.log('‚úÖ [showDebugModal] Auto-filled groundTruthTextarea from window.uploadedDialogueText');
            }
          }
        }, 50);
      }
    }
    
    // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –¥–∂–µ—Ä–µ–ª–∞ —ñ—Å—Ç–∏–Ω–∏ (ground truth)
    async function loadGroundTruthFile(event) {
      const file = event.target.files[0];
      if (!file) {
        return;
      }
      
      // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª—É
      const fileName = file.name.toLowerCase();
      const validExtensions = ['.txt', '.md', '.json'];
      const isValidFormat = validExtensions.some(ext => fileName.endsWith(ext));
      
      if (!isValidFormat) {
        alert('‚ùå –ù–µ–ø—ñ–¥—Ç—Ä–∏–º—É–≤–∞–Ω–∏–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª—É. –ü—ñ–¥—Ç—Ä–∏–º—É—é—Ç—å—Å—è —Ç—ñ–ª—å–∫–∏: .txt, .md, .json');
        event.target.value = ''; // –û—á–∏—â–∞—î–º–æ input
        return;
      }
      
      const reader = new FileReader();
      
      reader.onload = async function(e) {
        try {
          const content = e.target.result;
          // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ —Å–∏—Ä–∏–π –≤–º—ñ—Å—Ç —Ñ–∞–π–ª—É –±–µ–∑ –±—É–¥—å-—è–∫–æ–≥–æ —Ñ–æ—Ä–º–∞—Ç—É–≤–∞–Ω–Ω—è
          const textContent = content;
          
          // –ó–∞–ø–æ–≤–Ω—é—î–º–æ –ø–æ–ª–µ –≤–≤–æ–¥—É –≤ –º–æ–¥–∞–ª—å–Ω–æ–º—É –≤—ñ–∫–Ω—ñ –≤–º—ñ—Å—Ç–æ–º –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ–≥–æ —Ñ–∞–π–ª—É
          const groundTruthTextarea = document.getElementById('groundTruthTextarea');
          if (groundTruthTextarea) {
            groundTruthTextarea.value = textContent;
            console.log('‚úÖ [loadGroundTruthFile] File content loaded into groundTruthTextarea:', {
              fileName: file.name,
              contentLength: textContent.length,
              lines: textContent.split('\n').length
            });
          }
          
          // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–∏–π —Ç–µ–∫—Å—Ç –≥–ª–æ–±–∞–ª—å–Ω–æ
          window.uploadedDialogueText = textContent;
          
          // –¢–∞–∫–æ–∂ –∑–±–µ—Ä—ñ–≥–∞—î–º–æ –≤ localStorage –¥–ª—è –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è –ø—ñ—Å–ª—è –ø–µ—Ä–µ–∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è
          try {
            localStorage.setItem('uploadedDialogueText', textContent);
            console.log('‚úÖ [loadGroundTruthFile] Saved dialogue to localStorage');
          } catch (e) {
            console.warn('‚ö†Ô∏è [loadGroundTruthFile] Failed to save to localStorage:', e);
          }
          
          // –í—ñ–¥–ø—Ä–∞–≤–ª—è—î–º–æ –Ω–∞ –±–µ–∫–µ–Ω–¥ –¥–ª—è –∑–±–µ—Ä—ñ–≥–∞–Ω–Ω—è
          try {
            const response = await fetch('/api/dialogue-scripts', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                text: textContent,
                lines: textContent.split('\n').map(line => line.trim()).filter(Boolean),
                meta: {
                  fileName: file.name,
                  uploadedAt: new Date().toISOString()
                }
              })
            });
            
            if (!response.ok) {
              throw new Error('Failed to save dialogue to server');
            }
            
            const result = await response.json();
            console.log('‚úÖ Ground truth saved to server:', result);
            
            // –Ø–∫—â–æ —î —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏ –¥—ñ–∞—Ä–∏–∑–∞—Ü—ñ—ó, –∑–∞–ø—É—Å–∫–∞—î–º–æ –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è
            if (currentAnalysisData) {
              console.log('üîÑ Triggering comparison with diarization results...');
              
              const compareResponse = await fetch('/api/compare-with-dialogue', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  groundTruthText: textContent,
                  diarizationData: currentAnalysisData
                })
              });
              
              if (compareResponse.ok) {
                const compareResult = await compareResponse.json();
                console.log('‚úÖ Comparison completed:', compareResult);
                
                // –û–Ω–æ–≤–ª—é—î–º–æ –¥–∞–Ω—ñ –∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏ –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è
                if (compareResult.groundTruthMetrics) {
                  currentAnalysisData.groundTruthMetrics = compareResult.groundTruthMetrics;
                }
                
                // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –ø–æ—Ç–æ—á–Ω–µ –∑–Ω–∞—á–µ–Ω–Ω—è groundTruthTextarea –ø–µ—Ä–µ–¥ –≤–∏–∫–ª–∏–∫–æ–º showResults
                const groundTruthTextarea = document.getElementById('groundTruthTextarea');
                const savedTextareaValue = groundTruthTextarea ? groundTruthTextarea.value : null;
                
                // –ü–µ—Ä–µ–º–∞–ª—å–æ–≤—É—î–º–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏ –∑ –Ω–æ–≤–∏–º–∏ –¥–∞–Ω–∏–º–∏ –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è
                showResults(currentAnalysisData);
                
                // –í—ñ–¥–Ω–æ–≤–ª—é—î–º–æ –∑–Ω–∞—á–µ–Ω–Ω—è groundTruthTextarea –ø—ñ—Å–ª—è showResults
                if (groundTruthTextarea && savedTextareaValue !== null) {
                  // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ setTimeout, —â–æ–± –ø–µ—Ä–µ–∫–æ–Ω–∞—Ç–∏—Å—è, —â–æ showResults –∑–∞–≤–µ—Ä—à–∏–≤—Å—è
                  setTimeout(() => {
                    groundTruthTextarea.value = savedTextareaValue;
                  }, 100);
                }
              }
            }
            
          } catch (error) {
            console.error('‚ùå Error saving ground truth:', error);
            alert('‚ö†Ô∏è Failed to save ground truth: ' + error.message);
          }
          
        } catch (error) {
          console.error('‚ùå Error reading file:', error);
          alert('‚ùå Error reading file: ' + error.message);
        }
      };
      
      reader.onerror = function(error) {
        console.error('‚ùå FileReader error:', error);
        alert('‚ùå Error reading file');
      };
      
      reader.readAsText(file);
    }
    
    // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –æ–±—á–∏—Å–ª–µ–Ω–Ω—è –º–µ—Ç—Ä–∏–∫ ground truth –Ω–∞ –æ—Å–Ω–æ–≤—ñ —Ç–∞–±–ª–∏—Ü—ñ –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è
    function calculateGroundTruthMetricsFromTable() {
      try {
        const comparisonContainer = document.getElementById('comparisonTableContainer');
        if (!comparisonContainer) {
          console.log('‚ÑπÔ∏è [calculateGroundTruthMetrics] Comparison table not found');
          return;
        }
        
        const table = comparisonContainer.querySelector('table.comparison-table') || 
                      comparisonContainer.querySelector('table');
        
        if (!table) {
          console.log('‚ÑπÔ∏è [calculateGroundTruthMetrics] Table not found');
          return;
        }
        
        // –ó–Ω–∞—Ö–æ–¥–∏–º–æ –≤—Å—ñ —Ä—è–¥–∫–∏ —Ç–∞–±–ª–∏—Ü—ñ
        const tbody = table.querySelector('tbody');
        const allRows = tbody ? tbody.querySelectorAll('tr') : table.querySelectorAll('tr');
        
        // –í–∏–∑–Ω–∞—á–∞—î–º–æ, —á–∏ –ø–µ—Ä—à–∏–π —Ä—è–¥–æ–∫ - —Ü–µ –∑–∞–≥–æ–ª–æ–≤–æ–∫
        let dataRowStartIndex = 0;
        if (allRows.length > 0) {
          const firstRow = allRows[0];
          if (firstRow.querySelector('th')) {
            dataRowStartIndex = 1;
          }
        }
        
        // –ó–±–∏—Ä–∞—î–º–æ –¥–∞–Ω—ñ –∑ —Ç–∞–±–ª–∏—Ü—ñ
        const tableRows = [];
        for (let i = dataRowStartIndex; i < allRows.length; i++) {
          const row = allRows[i];
          const cells = row.querySelectorAll('td');
          
          // –ü–æ—Ä—è–¥–æ–∫ –∫–æ–ª–æ–Ω–æ–∫: Segment ID (0) | Role Original (1) | Text Original (2) | Speaker (Standard) (3) | Text (Standard) (4) | Speaker (NextLevel) (5) | Text (NextLevel) (6) | Start Time (7) | End Time (8)
          if (cells.length >= 7) {
            const textOriginal = cells[2].textContent.trim();
            const textStandard = cells[4].textContent.trim();
            const textNextLevel = cells[6].textContent.trim();
            
            // –ü—Ä–æ–ø—É—Å–∫–∞—î–º–æ –ø–æ—Ä–æ–∂–Ω—ñ —Ä—è–¥–∫–∏ (–±–µ–∑ Text Original)
            if (textOriginal === '‚Äî' || textOriginal === '') {
              continue;
            }
            
            tableRows.push({
              textOriginal: textOriginal !== '‚Äî' ? textOriginal : '',
              textStandard: textStandard !== '‚Äî' ? textStandard : '',
              textNextLevel: textNextLevel !== '‚Äî' ? textNextLevel : ''
            });
          }
        }
        
        if (tableRows.length === 0) {
          console.log('‚ÑπÔ∏è [calculateGroundTruthMetrics] No data rows found');
          const metricsContent = document.getElementById('groundTruthMetricsContent');
          if (metricsContent) {
            metricsContent.innerHTML = '<div style="color: #aaa;">–ù–µ–º–∞—î –¥–∞–Ω–∏—Ö –¥–ª—è –æ–±—á–∏—Å–ª–µ–Ω–Ω—è –º–µ—Ç—Ä–∏–∫</div>';
          }
          return;
        }
        
        console.log(`üîÑ [calculateGroundTruthMetrics] Calculating metrics for ${tableRows.length} rows...`);
        
        // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è —Ç–µ–∫—Å—Ç—ñ–≤ –Ω–∞ —Ä—ñ–≤–Ω—ñ —Å–ª—ñ–≤
        const compareTexts = (original, compared) => {
          if (!original || !compared) {
            return { matched: 0, total: 0, unmatched: 0, extra: 0 };
          }
          
          const originalWords = original.toLowerCase().split(/\s+/).filter(w => w.length > 0);
          const comparedWords = compared.toLowerCase().split(/\s+/).filter(w => w.length > 0);
          
          const originalWordSet = new Set(originalWords);
          const comparedWordSet = new Set(comparedWords);
          
          let matched = 0;
          let unmatched = 0;
          let extra = 0;
          
          // –†–∞—Ö—É—î–º–æ –∑–±—ñ–≥–∏
          originalWordSet.forEach(word => {
            if (comparedWordSet.has(word)) {
              matched++;
      } else {
              unmatched++;
            }
          });
          
          // –†–∞—Ö—É—î–º–æ –∑–∞–π–≤—ñ —Å–ª–æ–≤–∞
          comparedWordSet.forEach(word => {
            if (!originalWordSet.has(word)) {
              extra++;
            }
          });
          
          const total = originalWords.length;
          
          return { matched, total, unmatched, extra };
        };
        
        // –û–±—á–∏—Å–ª—é—î–º–æ –º–µ—Ç—Ä–∏–∫–∏ –¥–ª—è Standard —Ç–∞ NextLevel
        let standardTotalMatched = 0;
        let standardTotalWords = 0;
        let standardTotalUnmatched = 0;
        let standardTotalExtra = 0;
        
        let nextLevelTotalMatched = 0;
        let nextLevelTotalWords = 0;
        let nextLevelTotalUnmatched = 0;
        let nextLevelTotalExtra = 0;
        
        tableRows.forEach(row => {
          if (row.textOriginal) {
            // –ü–æ—Ä—ñ–≤–Ω—é—î–º–æ –∑ Standard
            const standardMetrics = compareTexts(row.textOriginal, row.textStandard);
            standardTotalMatched += standardMetrics.matched;
            standardTotalWords += standardMetrics.total;
            standardTotalUnmatched += standardMetrics.unmatched;
            standardTotalExtra += standardMetrics.extra;
            
            // –ü–æ—Ä—ñ–≤–Ω—é—î–º–æ –∑ NextLevel
            const nextLevelMetrics = compareTexts(row.textOriginal, row.textNextLevel);
            nextLevelTotalMatched += nextLevelMetrics.matched;
            nextLevelTotalWords += nextLevelMetrics.total;
            nextLevelTotalUnmatched += nextLevelMetrics.unmatched;
            nextLevelTotalExtra += nextLevelMetrics.extra;
          }
        });
        
        // –û–±—á–∏—Å–ª—é—î–º–æ –≤—ñ–¥—Å–æ—Ç–∫–∏
        const standardMatchPercent = standardTotalWords > 0 
          ? ((standardTotalMatched / standardTotalWords) * 100).toFixed(1) 
          : 0;
        
        const nextLevelMatchPercent = nextLevelTotalWords > 0 
          ? ((nextLevelTotalMatched / nextLevelTotalWords) * 100).toFixed(1) 
          : 0;
        
        // –ü–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è
        const improvement = parseFloat(nextLevelMatchPercent) - parseFloat(standardMatchPercent);
        const isBetter = improvement > 0;
        
        // –û–Ω–æ–≤–ª—é—î–º–æ –≤—ñ–¥–æ–±—Ä–∞–∂–µ–Ω–Ω—è –º–µ—Ç—Ä–∏–∫
        const metricsContainer = document.getElementById('groundTruthMetricsContainer');
        const metricsContent = document.getElementById('groundTruthMetricsContent');
        
        if (metricsContainer && metricsContent) {
          const nextLevelColor = parseFloat(nextLevelMatchPercent) >= 90 ? '#10b981' : parseFloat(nextLevelMatchPercent) >= 70 ? '#f59e0b' : '#ef4444';
          const speechmaticsColor = parseFloat(standardMatchPercent) >= 90 ? '#10b981' : parseFloat(standardMatchPercent) >= 70 ? '#f59e0b' : '#ef4444';
          const comparisonColor = isBetter ? '#10b981' : '#ef4444';
          const comparisonIcon = isBetter ? '‚úÖ' : '‚ùå';
          
          let html = '';
          
          // NextLevel –º–µ—Ç—Ä–∏–∫–∏
          html += `
            <div style="margin-bottom: 16px;">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                <span style="color: #fff; font-weight: 600;">NextLevel Diarizator:</span>
                <span style="color: ${nextLevelColor}; font-weight: bold; font-size: 18px;">${nextLevelMatchPercent}%</span>
              </div>
              <div style="background: #2a2a2a; height: 8px; border-radius: 4px; overflow: hidden; margin-bottom: 8px;">
                <div style="background: ${nextLevelColor}; height: 100%; width: ${nextLevelMatchPercent}%; transition: width 0.3s;"></div>
              </div>
              <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; color: #aaa; font-size: 12px;">
                <div>Matched: ${nextLevelTotalMatched}/${nextLevelTotalWords}</div>
                <div>Unmatched: ${nextLevelTotalUnmatched}</div>
                <div>Extra: ${nextLevelTotalExtra}</div>
              </div>
            </div>
          `;
          
          // Speechmatics –º–µ—Ç—Ä–∏–∫–∏
          html += `
            <div style="margin-bottom: 16px;">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                <span style="color: #fff; font-weight: 600;">Speechmatics (Standard):</span>
                <span style="color: ${speechmaticsColor}; font-weight: bold; font-size: 18px;">${standardMatchPercent}%</span>
              </div>
              <div style="background: #2a2a2a; height: 8px; border-radius: 4px; overflow: hidden; margin-bottom: 8px;">
                <div style="background: ${speechmaticsColor}; height: 100%; width: ${standardMatchPercent}%; transition: width 0.3s;"></div>
              </div>
              <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; color: #aaa; font-size: 12px;">
                <div>Matched: ${standardTotalMatched}/${standardTotalWords}</div>
                <div>Unmatched: ${standardTotalUnmatched}</div>
                <div>Extra: ${standardTotalExtra}</div>
              </div>
            </div>
          `;
          
          // –ü–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è
          html += `
            <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid #333;">
              <div style="display: flex; justify-content: space-between; align-items: center;">
                <span style="color: #fff; font-weight: 600;">${comparisonIcon} Comparison:</span>
                <span style="color: ${comparisonColor}; font-weight: bold; font-size: 16px;">
                  NextLevel is ${isBetter ? 'BETTER' : 'WORSE'} by ${Math.abs(improvement).toFixed(1)}%
                </span>
              </div>
            </div>
          `;
          
          metricsContent.innerHTML = html;
          
          console.log('‚úÖ [calculateGroundTruthMetrics] Metrics calculated:', {
            nextLevel: { percent: nextLevelMatchPercent, matched: nextLevelTotalMatched, total: nextLevelTotalWords },
            standard: { percent: standardMatchPercent, matched: standardTotalMatched, total: standardTotalWords },
            improvement: improvement.toFixed(1)
          });
        }
        
      } catch (error) {
        console.error('‚ùå [calculateGroundTruthMetrics] Error:', error);
        const metricsContent = document.getElementById('groundTruthMetricsContent');
        if (metricsContent) {
          metricsContent.innerHTML = `<div style="color: #ef4444;">–ü–æ–º–∏–ª–∫–∞ –æ–±—á–∏—Å–ª–µ–Ω–Ω—è –º–µ—Ç—Ä–∏–∫: ${error.message}</div>`;
        }
      }
    }
    
    // ============================================
    // Color Marking Functions for Ground Truth Comparison
    // ============================================
    
    // Function to copy logs to clipboard
    function copyLogsToClipboard() {
      const textarea = document.getElementById('groundTruthTextarea');
      if (!textarea) {
        alert('Logs textarea not found');
        return;
      }
      
      const logs = textarea.value;
      if (!logs || logs.trim() === '') {
        alert('No logs to copy');
        return;
      }
      
      // Copy to clipboard
      navigator.clipboard.writeText(logs).then(() => {
        console.log('[Copy Logs] Logs copied to clipboard successfully');
        const btn = document.getElementById('copyLogsBtn');
        if (btn) {
          const originalText = btn.innerHTML;
          btn.innerHTML = '‚úÖ Copied!';
          btn.style.background = '#27ae60';
          setTimeout(() => {
            btn.innerHTML = originalText;
            btn.style.background = '#16a085';
          }, 2000);
        }
        alert(`Logs copied to clipboard (${logs.length} characters)`);
      }).catch(err => {
        console.error('[Copy Logs] Failed to copy logs:', err);
        alert('Failed to copy logs to clipboard. Please select and copy manually.');
      });
    }
    
    // Helper function to log to groundTruthTextarea
    function logToGroundTruthTextarea(message, data = null) {
      const textarea = document.getElementById('groundTruthTextarea');
      if (!textarea) {
        console.warn('groundTruthTextarea not found');
        return;
      }
      
      const timestamp = new Date().toISOString().substring(11, 23); // HH:MM:SS.mmm
      let logEntry = `[${timestamp}] ${message}\n`;
      
      if (data !== null) {
        try {
          logEntry += `[Data: ${JSON.stringify(data, null, 2)}]\n`;
        } catch (e) {
          logEntry += `[Data: ${String(data)}]\n`;
        }
      }
      
      logEntry += '\n';
      textarea.value += logEntry;
      // Auto-scroll to bottom
      textarea.scrollTop = textarea.scrollHeight;
    }
    
    // Normalize text to words (same logic as compareTexts and server.js normalizeTextToWords)
    // Removes punctuation and normalizes whitespace before splitting
    function normalizeTextToWords(text) {
      if (!text) return [];
      return text.toLowerCase()
        .replace(/[^\w\s]/g, ' ')  // Replace punctuation with spaces
        .replace(/\s+/g, ' ')      // Normalize whitespace
        .trim()
        .split(/\s+/)
        .filter(w => w.length > 0); // Filter out empty strings
    }
    
    // Compare texts word-by-word and return detailed comparison
    function compareTextsWordByWord(original, standard, nextLevel) {
      const originalWords = normalizeTextToWords(original);
      const standardWords = normalizeTextToWords(standard);
      const nextLevelWords = normalizeTextToWords(nextLevel);
      
      // Create sets for quick lookup
      const originalWordSet = new Set(originalWords);
      const standardWordSet = new Set(standardWords);
      const nextLevelWordSet = new Set(nextLevelWords);
      
      // Analyze original words
      const originalWordsAnalysis = originalWords.map(word => {
        const inStandard = standardWordSet.has(word);
        const inNextLevel = nextLevelWordSet.has(word);
        
        let type = 'matched';
        if (!inStandard && !inNextLevel) {
          type = 'missing-in-both';
        } else if (!inStandard) {
          type = 'missing-in-standard';
        } else if (!inNextLevel) {
          type = 'missing-in-nextlevel';
        }
        
        return { word, type };
      });
      
      // Analyze standard words
      const standardWordsAnalysis = standardWords.map(word => {
        if (originalWordSet.has(word)) {
          return { word, type: 'matched' };
        } else {
          return { word, type: 'extra' };
        }
      });
      
      // Analyze nextLevel words
      const nextLevelWordsAnalysis = nextLevelWords.map(word => {
        if (originalWordSet.has(word)) {
          return { word, type: 'matched' };
        } else {
          return { word, type: 'extra' };
        }
      });
      
      return {
        originalWords: originalWordsAnalysis,
        standardWords: standardWordsAnalysis,
        nextLevelWords: nextLevelWordsAnalysis
      };
    }
    
    // Highlight original text based on what's missing in Standard/NextLevel
    function highlightOriginalText(originalText, standardText, nextLevelText) {
      if (!originalText || originalText === '‚Äî' || originalText.trim() === '') {
        return escapeHtml(originalText || '‚Äî');
      }
      
      const comparison = compareTextsWordByWord(originalText, standardText || '', nextLevelText || '');
      const originalWordsNormalized = normalizeTextToWords(originalText);
      const words = originalText.split(/(\s+)/); // Split preserving whitespace
      let result = '';
      let wordIndex = 0;
      
      for (let i = 0; i < words.length; i++) {
        const token = words[i];
        if (/\s+/.test(token)) {
          // Whitespace - keep as is
          result += escapeHtml(token);
        } else {
          // Word - normalize to match with comparison (remove punctuation)
          const normalizedToken = token.toLowerCase().replace(/[^\w]/g, '');
          if (wordIndex < originalWordsNormalized.length && normalizedToken === originalWordsNormalized[wordIndex]) {
            const wordInfo = comparison.originalWords[wordIndex];
            const escapedWord = escapeHtml(token); // Use original token with original case and punctuation
            
            let style = '';
            if (wordInfo.type === 'missing-in-both') {
              style = 'background-color: #ffe0b2; color: #e65100; padding: 2px 4px; border-radius: 3px;'; // Orange
            } else if (wordInfo.type === 'missing-in-standard') {
              style = 'background-color: #fff9c4; color: #f57c00; padding: 2px 4px; border-radius: 3px;'; // Yellow
            } else if (wordInfo.type === 'missing-in-nextlevel') {
              style = 'background-color: #ffebee; color: #c62828; padding: 2px 4px; border-radius: 3px;'; // Red
            }
            
            if (style) {
              result += `<span style="${style}">${escapedWord}</span>`;
            } else {
              result += escapedWord;
            }
            wordIndex++;
          } else {
            // Word doesn't match - just escape it
            result += escapeHtml(token);
          }
        }
      }
      
      return result;
    }
    
    // Highlight standard text based on differences from original
    function highlightStandardText(originalText, standardText) {
      if (!standardText || standardText === '‚Äî' || standardText.trim() === '') {
        return escapeHtml(standardText || '‚Äî');
      }
      
      const comparison = compareTextsWordByWord(originalText || '', standardText, '');
      const standardWordsNormalized = normalizeTextToWords(standardText);
      const words = standardText.split(/(\s+)/); // Split preserving whitespace
      let result = '';
      let wordIndex = 0;
      
      for (let i = 0; i < words.length; i++) {
        const token = words[i];
        if (/\s+/.test(token)) {
          // Whitespace - keep as is
          result += escapeHtml(token);
        } else {
          // Word - normalize to match with comparison (remove punctuation)
          const normalizedToken = token.toLowerCase().replace(/[^\w]/g, '');
          
          // Skip empty tokens (only punctuation)
          if (normalizedToken.length === 0) {
            result += escapeHtml(token);
            continue;
          }
          
          // Try to match with current word index
          if (wordIndex < standardWordsNormalized.length && normalizedToken === standardWordsNormalized[wordIndex]) {
            const wordInfo = comparison.standardWords[wordIndex];
            const escapedWord = escapeHtml(token); // Use original token with original case and punctuation
            
            let style = '';
            if (wordInfo.type === 'extra') {
              style = 'background-color: #ffebee; color: #c62828; padding: 2px 4px; border-radius: 3px;'; // Red
            }
            
            if (style) {
              result += `<span style="${style}">${escapedWord}</span>`;
            } else {
              result += escapedWord;
            }
            wordIndex++;
          } else {
            // Token doesn't match at current index - try to find it in the remaining words
            let found = false;
            for (let j = wordIndex; j < standardWordsNormalized.length; j++) {
              if (normalizedToken === standardWordsNormalized[j]) {
                const wordInfo = comparison.standardWords[j];
                const escapedWord = escapeHtml(token);
                
                let style = '';
                if (wordInfo.type === 'extra') {
                  style = 'background-color: #ffebee; color: #c62828; padding: 2px 4px; border-radius: 3px;'; // Red
                }
                
                if (style) {
                  result += `<span style="${style}">${escapedWord}</span>`;
                } else {
                  result += escapedWord;
                }
                wordIndex = j + 1;
                found = true;
                break;
              }
            }
            
            if (!found) {
              // Word not found in normalized array - mark as extra if it's a valid word
              if (normalizedToken.length > 0) {
                result += `<span style="background-color: #ffebee; color: #c62828; padding: 2px 4px; border-radius: 3px;">${escapeHtml(token)}</span>`;
              } else {
                result += escapeHtml(token);
              }
            }
          }
        }
      }
      
      return result;
    }
    
    // Highlight nextLevel text based on differences from original
    function highlightNextLevelText(originalText, nextLevelText) {
      if (!nextLevelText || nextLevelText === '‚Äî' || nextLevelText.trim() === '') {
        return escapeHtml(nextLevelText || '‚Äî');
      }
      
      const comparison = compareTextsWordByWord(originalText || '', '', nextLevelText);
      const nextLevelWordsNormalized = normalizeTextToWords(nextLevelText);
      const words = nextLevelText.split(/(\s+)/); // Split preserving whitespace
      let result = '';
      let wordIndex = 0;
      
      for (let i = 0; i < words.length; i++) {
        const token = words[i];
        if (/\s+/.test(token)) {
          // Whitespace - keep as is
          result += escapeHtml(token);
        } else {
          // Word - normalize to match with comparison (remove punctuation)
          const normalizedToken = token.toLowerCase().replace(/[^\w]/g, '');
          
          // Skip empty tokens (only punctuation)
          if (normalizedToken.length === 0) {
            result += escapeHtml(token);
            continue;
          }
          
          // Try to match with current word index
          if (wordIndex < nextLevelWordsNormalized.length && normalizedToken === nextLevelWordsNormalized[wordIndex]) {
            const wordInfo = comparison.nextLevelWords[wordIndex];
            const escapedWord = escapeHtml(token); // Use original token with original case and punctuation
            
            let style = '';
            if (wordInfo.type === 'extra') {
              style = 'background-color: #ffebee; color: #c62828; padding: 2px 4px; border-radius: 3px;'; // Red
            }
            
            if (style) {
              result += `<span style="${style}">${escapedWord}</span>`;
            } else {
              result += escapedWord;
            }
            wordIndex++;
          } else {
            // Token doesn't match at current index - try to find it in the remaining words
            // This handles cases where punctuation or spacing causes misalignment
            let found = false;
            for (let j = wordIndex; j < nextLevelWordsNormalized.length; j++) {
              if (normalizedToken === nextLevelWordsNormalized[j]) {
                const wordInfo = comparison.nextLevelWords[j];
                const escapedWord = escapeHtml(token);
                
                let style = '';
                if (wordInfo.type === 'extra') {
                  style = 'background-color: #ffebee; color: #c62828; padding: 2px 4px; border-radius: 3px;'; // Red
                }
                
                if (style) {
                  result += `<span style="${style}">${escapedWord}</span>`;
                } else {
                  result += escapedWord;
                }
                wordIndex = j + 1;
                found = true;
                break;
              }
            }
            
            if (!found) {
              // Word not found in normalized array - might be extra punctuation or special case
              // Mark it as extra if it's a valid word
              if (normalizedToken.length > 0) {
                result += `<span style="background-color: #ffebee; color: #c62828; padding: 2px 4px; border-radius: 3px;">${escapeHtml(token)}</span>`;
              } else {
                result += escapeHtml(token);
              }
            }
          }
        }
      }
      
      return result;
    }
    
    // Call LLM to find phrases for highlighting
    async function callLLMForHighlighting(originalText, comparedText, color, iteration, rowIndex) {
      console.log(`[LLM Highlighting] Row ${rowIndex + 1}, Iteration ${iteration}: Calling LLM for ${color} highlighting`);
      
      logToGroundTruthTextarea(`Row ${rowIndex + 1}, Iteration ${iteration}: Calling LLM for ${color} highlighting`);
      
      const prompt = `You are analyzing text differences between an original transcript and a diarized version.

**Original Text:**
${originalText || '(empty)'}

**${iteration === 1 ? 'Standard' : 'NextLevel'} Text (Diarized):**
${comparedText || '(empty)'}

**Task:**
${iteration === 1 
  ? 'Find phrases that were NOT transcribed correctly or were MISSED by the diarizer in the Standard text. These should be highlighted in YELLOW color.'
  : 'Find phrases that were NOT transcribed correctly or were MISSED by the diarizer in the NextLevel text. These should be highlighted in RED color.'
}

**CRITICAL RULES - READ CAREFULLY:**
1. Return ONLY the EXACT words/phrases that differ, NOT the entire matching phrase
2. If a phrase has both matching and differing parts, return ONLY the differing part
3. **IMPORTANT**: When words repeat, identify and return ONLY the specific instance that differs
4. **CRITICAL**: Return ONLY WORDS, NO PUNCTUATION (commas, periods, semicolons, etc. should be excluded)

**SEMANTIC EQUIVALENCE RULES (DO NOT MARK AS ERRORS):**
- **Contractions**: "I'm" = "I am", "it's" = "it is", "don't" = "do not", "can't" = "cannot", "won't" = "will not", "I'll" = "I will", "you're" = "you are", "they're" = "they are", etc.
  - **CRITICAL**: If the SAME contraction appears in BOTH texts (e.g., "I'm" in both Original and Standard), do NOT expand it. Only expand if one has contraction and the other has the expanded form.
- **Pronouns in context**: "it" vs "that" when referring to the same thing (e.g., "it might be" = "that might be" if both refer to the same subject)
- **Stylistic variations**: "to [verb]" = "so I can [verb]" (e.g., "to look up" = "so I can look up")
- **Stylistic additions**: Extra words that don't change meaning (e.g., "that" as a connector, "will occur" vs just the verb, "estimates restoration" = "estimates that restoration will occur")
- **Spelling variants**: "Alright" = "All right", "OK" = "okay" = "Okay"
- **Case differences**: "Support" vs "support", "Thank" vs "thank" - these are the SAME word, only capitalization differs
- **Punctuation-only differences**: If texts differ ONLY in punctuation (periods, commas, semicolons, etc.), return empty array
- **Phone numbers and numeric sequences**: Treat phone numbers and numeric sequences as single units. If "742-859-3210" vs "742859327", mark the ENTIRE number as different, NOT individual digits.

**Examples:**
- Original "it might be" vs NextLevel "that might be" 
  ‚Üí Return: {"text": "that", "column": "nextlevel", "color": "${color}", "position": "first word, different from 'it' in Original"}
  ‚Üí **CRITICAL**: We evaluate word-by-word - "it" and "that" are different words, so mark "that" as different
  ‚Üí **CRITICAL**: Even if semantically equivalent, different words must be marked as errors

- Original "I'm having trouble" vs NextLevel "I am having trouble"
  ‚Üí Return empty array (do NOT mark - "I'm" = "I am" semantically)

- Original "to look up" vs NextLevel "so I can look up"
  ‚Üí Return: {"text": "so I can", "column": "nextlevel", "color": "${color}", "position": "extra words before 'look up'"}
  ‚Üí **CRITICAL**: Even if semantically equivalent, extra words that are NOT in Original must be marked as errors
  ‚Üí **CRITICAL**: We evaluate word-by-word - if words are missing or extra, they are errors regardless of semantic equivalence

- Original "estimates restoration" vs NextLevel "estimates that restoration will occur"
  ‚Üí Return: {"text": "that", "column": "nextlevel", "color": "${color}", "position": "extra connector after 'estimates'"}, {"text": "will occur", "column": "nextlevel", "color": "${color}", "position": "extra words after 'restoration'"}
  ‚Üí **CRITICAL**: Extra words that are NOT in Original must be marked as errors, even if they are stylistic additions
  ‚Üí **CRITICAL**: We evaluate word-by-word - missing or extra words are errors regardless of semantic meaning

- Original "742-859-3210" vs NextLevel "742859327"
  ‚Üí Return: {"text": "742-859-3210", "column": "original", "color": "${color}", "position": "phone number, different in NextLevel"}
  ‚Üí OR: {"text": "742859327", "column": "nextlevel", "color": "${color}", "position": "phone number, different from Original"}
  ‚Üí NOT individual digits like "1 0" or "7"

- Original "Alright" vs NextLevel "All right"
  ‚Üí Return empty array (do NOT mark - these are spelling variants of the same word)

- Original "I'll do that" vs Standard "I do that" (missing "will")
  ‚Üí Return: {"text": "will", "column": "original", "color": "${color}", "position": "after 'I', missing in Standard"}
  ‚Üí Note: "I'll" = "I will", so if Standard has only "I", mark "will" as missing

- Original "I'll do that" vs Standard "I'll do that"
  ‚Üí Return empty array (do NOT mark - same contraction in both, no expansion needed)
  ‚Üí **CRITICAL**: If both texts have the SAME contraction (e.g., both have "I'll"), do NOT expand it and do NOT mark anything

- Original "I'm having trouble" vs Standard "I'm having trouble"
  ‚Üí Return empty array (do NOT mark - same contraction in both, no expansion needed)

- Original "it's 742-859-3210" vs Standard "It's 74285932"
  ‚Üí Return: {"text": "742-859-3210", "column": "original", "color": "${color}", "position": "phone number, different in Standard"}
  ‚Üí NOT "is" (contraction is the same in both), NOT individual digits

- Original "Support" vs Standard "support"
  ‚Üí Return empty array (do NOT mark - only capitalization differs, same word)

- Original "Hello, world test" vs NextLevel "Hello test" 
  ‚Üí Return: {"text": "world", "column": "original", "color": "${color}", "position": "second word, missing in NextLevel"}
  ‚Üí NOT "world," (no punctuation)

- Original "test" vs NextLevel "test, extra word" 
  ‚Üí Return: {"text": "extra word", "column": "nextlevel", "color": "${color}", "position": "after 'test', extra words"}
  ‚Üí NOT "extra word," (no comma)

- Original "Hi, I'm here." vs NextLevel "Hi I'm here"
  ‚Üí Return empty array (only punctuation differs - comma and period)

- Original "I'm sorry to hear that. May I have..." vs Standard "I'm sorry to hear that May I have..."
  ‚Üí Return empty array (do NOT mark "that" - it exists in both texts, only punctuation differs)
  ‚Üí **CRITICAL**: If a word appears in BOTH texts but punctuation differs around it, do NOT mark that word as missing or different

5. For phrases MISSING in ${iteration === 1 ? 'Standard' : 'NextLevel'} (present in Original but not in ${iteration === 1 ? 'Standard' : 'NextLevel'}): 
   - Set column: "original"
   - Set color: "${color}"
   - Return ONLY the EXACT missing WORDS (no punctuation) as they appear in Original text
   - In "position", specify which word(s) and where (e.g., "second word", "after comma", "at the end")
   - **IMPORTANT**: Only expand contractions if they differ between texts:
     - If Original has "I'll" and Standard has "I will" ‚Üí mark nothing (semantically equivalent, both have the same words)
     - If Original has "I'll" and Standard has only "I" ‚Üí mark "will" as missing (Standard is missing "will")
     - If Original has "I'll" and Standard also has "I'll" ‚Üí mark nothing (same contraction, no expansion needed)
     - If Original has "I'm" and Standard also has "I'm" ‚Üí mark nothing (same contraction)
     - **CRITICAL**: If both texts have the SAME contraction, do NOT expand it and do NOT mark anything
   - **IMPORTANT**: For phone numbers and numeric sequences, treat them as single units. Do NOT break them into individual digits.
   - **CRITICAL**: If a word appears in BOTH texts (even if punctuation differs around it), do NOT mark it as missing. Only mark words that are truly absent from one text.

6. For phrases that are DIFFERENT or EXTRA in ${iteration === 1 ? 'Standard' : 'NextLevel'} (not matching Original):
   - Set column: "${iteration === 1 ? 'standard' : 'nextlevel'}"
   - Set color: "${color}"
   - Return ONLY the EXACT differing WORDS (no punctuation) as they appear in ${iteration === 1 ? 'Standard' : 'NextLevel'} text
   - In "position", specify which specific word(s) and where (e.g., "first word 'that' replaces 'it'", "extra word after 'test'")
   - **IMPORTANT**: Mark ALL extra words that are NOT in Original, even if they are semantically equivalent
   - **CRITICAL**: We evaluate word-by-word - if words are extra or missing, they are errors regardless of semantic meaning
   - **CRITICAL**: Mark stylistic additions as errors:
     - "that" as a connector (e.g., "estimates restoration" vs "estimates that restoration") ‚Üí mark "that" as extra
     - "will occur" vs just the verb (e.g., "restoration" vs "restoration will occur") ‚Üí mark "will occur" as extra
     - "so I can" vs "to" (e.g., "to look up" vs "so I can look up") ‚Üí mark "so I can" as extra
   - **EXCEPTION**: Only ignore if the difference is a contraction expansion (e.g., "I'll" vs "I will" - both have same words)

7. **PUNCTUATION RULE**: Strip all punctuation (commas, periods, semicolons, colons, exclamation marks, question marks, etc.) from the returned text. Return only the words themselves.
8. **CAPITALIZATION RULE**: Ignore case differences - "Support" = "support", "Thank" = "thank". Do NOT mark these as differences.
9. Preserve exact capitalization and word spacing of the returned phrase (but remove punctuation)
10. If texts are identical or very similar (only punctuation or capitalization differs), return empty array
11. Be precise - only mark actual semantic word differences, not punctuation variations, capitalization, or semantic equivalents

**Output Format (JSON only, no markdown, no code blocks):**
{
  "phrases": [
    {
      "text": "exact differing words/phrase only (not the full matching phrase)",
      "column": "original" or "${iteration === 1 ? 'standard' : 'nextlevel'}",
      "color": "${color}",
      "position": "description of where this phrase appears (e.g., 'first word', 'after comma', 'at the end')"
    }
  ]
}

Return ONLY valid JSON. No explanations, no markdown formatting.`;

      try {
        // Log input data for LLM
        logToGroundTruthTextarea(`Row ${rowIndex + 1}, Iteration ${iteration}: ===== LLM INPUT =====`);
        logToGroundTruthTextarea(`Row ${rowIndex + 1}, Iteration ${iteration}: Original Text`, { text: originalText });
        logToGroundTruthTextarea(`Row ${rowIndex + 1}, Iteration ${iteration}: ${iteration === 1 ? 'Standard' : 'NextLevel'} Text`, { text: comparedText });
        logToGroundTruthTextarea(`Row ${rowIndex + 1}, Iteration ${iteration}: Expected Color`, { color: color });
        
        const response = await fetch('/api/debug-llm-query', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            prompt: prompt
          })
        });
        
        if (!response.ok) {
          throw new Error(`LLM request failed: ${response.status}`);
        }
        
        const result = await response.json();
        if (!result.success) {
          throw new Error(result.error || 'LLM query failed');
        }
        
        let llmOutput = result.result.trim();
        
        // Log raw LLM output
        logToGroundTruthTextarea(`Row ${rowIndex + 1}, Iteration ${iteration}: ===== LLM RAW OUTPUT =====`);
        logToGroundTruthTextarea(`Row ${rowIndex + 1}, Iteration ${iteration}: Raw Response`, { 
          response: llmOutput,
          length: llmOutput.length 
        });
        
        // Extract JSON from response
        let jsonText = llmOutput;
        
        // Remove special tokens
        jsonText = jsonText.replace(/<\|[^|]+\|>/g, '');
        
        // Try to extract JSON from markdown code blocks
        const jsonMatch = jsonText.match(/```(?:json)?\s*(\{[\s\S]*?\})\s*```/);
        if (jsonMatch) {
          jsonText = jsonMatch[1];
          logToGroundTruthTextarea(`Row ${rowIndex + 1}, Iteration ${iteration}: Extracted JSON from markdown code block`);
        } else {
          // Try to find JSON object
          const jsonObjectMatch = jsonText.match(/\{[\s\S]*\}/);
          if (jsonObjectMatch) {
            jsonText = jsonObjectMatch[0];
            logToGroundTruthTextarea(`Row ${rowIndex + 1}, Iteration ${iteration}: Extracted JSON object from response`);
          }
        }
        
        // Log extracted JSON
        logToGroundTruthTextarea(`Row ${rowIndex + 1}, Iteration ${iteration}: ===== EXTRACTED JSON =====`);
        logToGroundTruthTextarea(`Row ${rowIndex + 1}, Iteration ${iteration}: JSON Text`, { json: jsonText });
        
        const parsed = JSON.parse(jsonText);
        const phrases = parsed.phrases || [];
        
        // Log parsed result
        logToGroundTruthTextarea(`Row ${rowIndex + 1}, Iteration ${iteration}: ===== PARSED RESULT =====`);
        logToGroundTruthTextarea(`Row ${rowIndex + 1}, Iteration ${iteration}: Phrases Count`, { count: phrases.length });
        logToGroundTruthTextarea(`Row ${rowIndex + 1}, Iteration ${iteration}: Phrases Array`, { phrases: phrases });
        
        if (phrases.length > 0) {
          console.log(`[LLM Highlighting] Row ${rowIndex + 1}, Iteration ${iteration}: Found ${phrases.length} phrase(s) for ${color} highlighting:`, 
            phrases.map(p => `"${p.text}" in ${p.column}`).join(', '));
          logToGroundTruthTextarea(`Row ${rowIndex + 1}, Iteration ${iteration}: Summary - Found ${phrases.length} phrase(s)`, 
            phrases.map(p => ({ text: p.text, column: p.column, color: p.color, position: p.position })));
        } else {
          console.log(`[LLM Highlighting] Row ${rowIndex + 1}, Iteration ${iteration}: No phrases found (texts match)`);
          logToGroundTruthTextarea(`Row ${rowIndex + 1}, Iteration ${iteration}: Summary - No phrases found (texts match)`);
        }
        
        logToGroundTruthTextarea(`Row ${rowIndex + 1}, Iteration ${iteration}: ===== END LLM RESULT =====`);
        
        return phrases;
      } catch (error) {
        console.error(`[LLM Highlighting] Row ${rowIndex + 1}, Iteration ${iteration}: ERROR:`, error.message);
        logToGroundTruthTextarea(`Row ${rowIndex + 1}, Iteration ${iteration}: ERROR - ${error.message}`);
        return [];
      }
    }
    
    // Apply highlighting based on LLM phrases
    function applyLLMHighlighting(text, phrases, columnName) {
      if (!text || text === '‚Äî' || text.trim() === '') {
        return escapeHtml(text || '‚Äî');
      }
      
      if (!phrases || phrases.length === 0) {
        return escapeHtml(text);
      }
      
      // Filter phrases for this column
      const columnPhrases = phrases.filter(p => 
        p.column.toLowerCase() === columnName.toLowerCase()
      );
      
      if (columnPhrases.length === 0) {
        return escapeHtml(text);
      }
      
      // Separate phrases by color priority (orange has highest priority)
      const orangePhrases = columnPhrases.filter(p => p.color === 'orange');
      const otherPhrases = columnPhrases.filter(p => p.color !== 'orange');
      
      // Process phrases: first apply yellow/red, then orange (which will override)
      const allPhrasesByPriority = [...otherPhrases, ...orangePhrases];
      
      // Sort phrases by position in text (longest first to handle overlaps)
      const sortedPhrases = allPhrasesByPriority
        .map(phrase => {
          const index = text.indexOf(phrase.text);
          return {
            ...phrase,
            index: index,
            length: phrase.text.length
          };
        })
        .filter(p => p.index !== -1)
        .sort((a, b) => {
          // Sort by index, but longer phrases first if same index
          // Orange phrases should come after others at same position
          if (a.index !== b.index) return a.index - b.index;
          if (a.color === 'orange' && b.color !== 'orange') return 1; // Orange after
          if (b.color === 'orange' && a.color !== 'orange') return -1; // Orange after
          return b.length - a.length;
        });
      
      // Track which parts of text are already highlighted
      const highlightedRanges = [];
      
      let result = '';
      let lastIndex = 0;
      
      for (const phrase of sortedPhrases) {
        // Check if this phrase overlaps with already highlighted ranges
        const phraseStart = phrase.index;
        const phraseEnd = phrase.index + phrase.length;
        
        // Check for overlaps with existing highlights
        let hasOverlap = false;
        for (const range of highlightedRanges) {
          if (!(phraseEnd <= range.start || phraseStart >= range.end)) {
            hasOverlap = true;
            // If current phrase is orange and range is not, override it
            if (phrase.color === 'orange' && range.color !== 'orange') {
              // Remove the old range and add new one
              const rangeIndex = highlightedRanges.indexOf(range);
              highlightedRanges.splice(rangeIndex, 1);
              hasOverlap = false; // Allow this phrase to be added
              break;
            }
          }
        }
        
        if (hasOverlap && phrase.color !== 'orange') {
          // Skip this phrase if it overlaps and is not orange (orange has priority)
          continue;
        }
        
        // Add text before phrase
        if (phrase.index > lastIndex) {
          result += escapeHtml(text.substring(lastIndex, phrase.index));
        }
        
        // Add highlighted phrase
        const color = phrase.color || 'yellow';
        let style = '';
        if (color === 'yellow') {
          style = 'background-color: #fff9c4; color: #f57c00; padding: 2px 4px; border-radius: 3px;';
        } else if (color === 'red') {
          style = 'background-color: #ffebee; color: #c62828; padding: 2px 4px; border-radius: 3px;';
        } else if (color === 'orange') {
          style = 'background-color: #ffe0b2; color: #e65100; padding: 2px 4px; border-radius: 3px;';
        }
        
        result += `<span style="${style}">${escapeHtml(phrase.text)}</span>`;
        
        // Track this highlighted range
        highlightedRanges.push({
          start: phraseStart,
          end: phraseEnd,
          color: phrase.color
        });
        
        lastIndex = Math.max(lastIndex, phraseEnd);
      }
      
      // Add remaining text
      if (lastIndex < text.length) {
        result += escapeHtml(text.substring(lastIndex));
      }
      
      return result;
    }
    
    // Check for overlaps in Text Original and mark with orange
    function checkAndMarkOverlaps(originalText, allPhrases) {
      if (!originalText || originalText === '‚Äî' || originalText.trim() === '') {
        return null;
      }
      
      // Get all phrases for original column
      const originalPhrases = allPhrases.filter(p => 
        p.column.toLowerCase() === 'original'
      );
      
      if (originalPhrases.length < 2) {
        // No overlaps possible with less than 2 phrases
        return null;
      }
      
      // Find overlapping phrases
      const overlaps = [];
      for (let i = 0; i < originalPhrases.length; i++) {
        for (let j = i + 1; j < originalPhrases.length; j++) {
          const phrase1 = originalPhrases[i];
          const phrase2 = originalPhrases[j];
          const index1 = originalText.indexOf(phrase1.text);
          const index2 = originalText.indexOf(phrase2.text);
          
          if (index1 === -1 || index2 === -1) continue;
          
          const end1 = index1 + phrase1.text.length;
          const end2 = index2 + phrase2.text.length;
          
          // Check if phrases overlap
          if (!(end1 <= index2 || end2 <= index1)) {
            const overlapStart = Math.max(index1, index2);
            const overlapEnd = Math.min(end1, end2);
            const overlapText = originalText.substring(overlapStart, overlapEnd);
            
            if (overlapText.length > 0) {
              overlaps.push({
                text: overlapText,
                start: overlapStart,
                end: overlapEnd,
                column: 'original',
                color: 'orange'
              });
            }
          }
        }
      }
      
      return overlaps.length > 0 ? overlaps : null;
    }
    
    // Main function to mark table with colors using LLM
    async function markWithColor() {
      console.log('[LLM Highlighting] Starting color marking process...');
      logToGroundTruthTextarea('Starting color marking process...');
      
      const comparisonContainer = document.getElementById('comparisonTableContainer');
      if (!comparisonContainer) {
        console.error('[LLM Highlighting] ERROR: comparisonTableContainer not found');
        logToGroundTruthTextarea('ERROR: comparisonTableContainer not found');
        alert('Comparison table container not found. Please load ground truth and run the analysis first.');
        return;
      }
      
      logToGroundTruthTextarea('Waiting for comparison table to be rendered...');
      
      // Wait for table to be rendered (it's rendered asynchronously)
      try {
        await waitForComparisonTable(30, 200);
      } catch (error) {
        // Continue anyway
      }
      
      // Try to find the table with multiple selectors
      let table = comparisonContainer.querySelector('table.comparison-table');
      if (!table) {
        table = comparisonContainer.querySelector('table');
      }
      
      if (!table) {
        logToGroundTruthTextarea('ERROR: comparison table not found');
        alert('Comparison table not found. Please wait for the analysis to complete and try again.');
        return;
      }
      
      const tbody = table.querySelector('tbody');
      if (!tbody) {
        logToGroundTruthTextarea('ERROR: tbody not found');
        alert('Table body not found. The table may not be fully rendered yet.');
        return;
      }
      
      const rows = tbody.querySelectorAll('tr');
      if (rows.length === 0) {
        logToGroundTruthTextarea('WARNING: No rows found');
        alert('No data rows found in the comparison table.');
        return;
      }
      
      console.log(`[LLM Highlighting] Processing ${rows.length} rows...`);
      logToGroundTruthTextarea(`Processing ${rows.length} rows...`);
      
      let processedRows = 0;
      let highlightedWordsCount = 0;
      
      // Process rows sequentially (for...of supports await)
      for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
        const row = rows[rowIndex];
        const cells = row.querySelectorAll('td');
        if (cells.length < 7) {
          continue;
        }
        
        // Column indices: 0=Segment ID, 1=Role Original, 2=Text Original, 3=Speaker Standard, 4=Text Standard, 5=Speaker NextLevel, 6=Text NextLevel
        const textOriginal = cells[2].textContent.trim();
        const textStandard = cells[4].textContent.trim();
        const textNextLevel = cells[6].textContent.trim();
        
        console.log(`[LLM Highlighting] Row ${rowIndex + 1}: Processing`);
        
        // Store original HTML content for potential toggle (future feature)
        if (!row.dataset.originalHtml) {
          row.dataset.originalHtml = row.innerHTML;
        }
        
        // Handle missing original phrase
        if ((textOriginal === '‚Äî' || textOriginal === '') && (textStandard !== '‚Äî' || textNextLevel !== '‚Äî')) {
          const hasStandard = textStandard !== '‚Äî' && textStandard !== '';
          const hasNextLevel = textNextLevel !== '‚Äî' && textNextLevel !== '';
          
          // Determine color based on what's missing
          if (hasStandard && hasNextLevel) {
            cells[4].style.backgroundColor = '#ffe0b2';
            cells[6].style.backgroundColor = '#ffe0b2';
            cells[4].style.minHeight = '30px';
            cells[6].style.minHeight = '30px';
            cells[4].style.padding = '8px';
            cells[6].style.padding = '8px';
            cells[4].innerHTML = '';
            cells[6].innerHTML = '';
            console.log(`[LLM Highlighting] Row ${rowIndex + 1}: Missing original (orange)`);
            logToGroundTruthTextarea(`Row ${rowIndex + 1}: Missing original (orange)`);
          } else if (hasStandard) {
            cells[4].style.backgroundColor = '#fff9c4';
            cells[4].style.minHeight = '30px';
            cells[4].style.padding = '8px';
            cells[4].innerHTML = '';
            console.log(`[LLM Highlighting] Row ${rowIndex + 1}: Missing original (yellow)`);
            logToGroundTruthTextarea(`Row ${rowIndex + 1}: Missing original (yellow)`);
          } else if (hasNextLevel) {
            cells[6].style.backgroundColor = '#ffebee';
            cells[6].style.minHeight = '30px';
            cells[6].style.padding = '8px';
            cells[6].innerHTML = '';
            console.log(`[LLM Highlighting] Row ${rowIndex + 1}: Missing original (red)`);
            logToGroundTruthTextarea(`Row ${rowIndex + 1}: Missing original (red)`);
          }
          
          processedRows++;
          continue;
        }
        
        // Skip if no original text
        if (textOriginal === '‚Äî' || textOriginal === '') {
          continue;
        }
        
        // LLM-based highlighting: Two iterations per row
        console.log(`[LLM Highlighting] Row ${rowIndex + 1}: Starting highlighting`);
        logToGroundTruthTextarea(`Row ${rowIndex + 1}: Starting highlighting`);
        
        let allPhrases = [];
        
        // Iteration 1: Find phrases for YELLOW highlighting (Standard comparison)
        const yellowPhrases = await callLLMForHighlighting(textOriginal, textStandard, 'yellow', 1, rowIndex);
        yellowPhrases.forEach(p => allPhrases.push(p));
        
        // Iteration 2: Find phrases for RED highlighting (NextLevel comparison)
        const redPhrases = await callLLMForHighlighting(textOriginal, textNextLevel, 'red', 2, rowIndex);
        redPhrases.forEach(p => allPhrases.push(p));
        
        // Check for overlaps in Text Original (mark with orange)
        const overlaps = checkAndMarkOverlaps(textOriginal, allPhrases);
        if (overlaps && overlaps.length > 0) {
          console.log(`[LLM Highlighting] Row ${rowIndex + 1}: Found ${overlaps.length} overlap(s) in Original (orange)`);
          logToGroundTruthTextarea(`Row ${rowIndex + 1}: Found ${overlaps.length} overlap(s) in Original`);
          overlaps.forEach(o => allPhrases.push(o));
        }
        
        // Apply highlighting to each column
        // Note: applyLLMHighlighting processes phrases in order, so orange (added last) will override yellow/red
        const highlightedOriginal = applyLLMHighlighting(textOriginal, allPhrases, 'original');
        const highlightedStandard = applyLLMHighlighting(textStandard, allPhrases, 'standard');
        const highlightedNextLevel = applyLLMHighlighting(textNextLevel, allPhrases, 'nextlevel');
        
        // Log applied highlights
        const originalPhrases = allPhrases.filter(p => p.column === 'original');
        const standardPhrases = allPhrases.filter(p => p.column === 'standard');
        const nextlevelPhrases = allPhrases.filter(p => p.column === 'nextlevel');
        
        const highlightsSummary = [];
        if (originalPhrases.length > 0) {
          highlightsSummary.push(`Original: ${originalPhrases.map(p => `"${p.text}" (${p.color})`).join(', ')}`);
        }
        if (standardPhrases.length > 0) {
          highlightsSummary.push(`Standard: ${standardPhrases.map(p => `"${p.text}" (${p.color})`).join(', ')}`);
        }
        if (nextlevelPhrases.length > 0) {
          highlightsSummary.push(`NextLevel: ${nextlevelPhrases.map(p => `"${p.text}" (${p.color})`).join(', ')}`);
        }
        
        if (highlightsSummary.length > 0) {
          console.log(`[LLM Highlighting] Row ${rowIndex + 1}: Applied highlights - ${highlightsSummary.join(' | ')}`);
          logToGroundTruthTextarea(`Row ${rowIndex + 1}: Applied highlights`, highlightsSummary);
        } else {
          console.log(`[LLM Highlighting] Row ${rowIndex + 1}: No highlights applied`);
          logToGroundTruthTextarea(`Row ${rowIndex + 1}: No highlights applied`);
        }
        
        // Update cells
        cells[2].innerHTML = highlightedOriginal;
        cells[4].innerHTML = highlightedStandard;
        cells[6].innerHTML = highlightedNextLevel;
        
        highlightedWordsCount += allPhrases.length;
        
        processedRows++;
        
        // Move to next row (iteration 2 already processed this row's NextLevel)
      }
      
      console.log(`[LLM Highlighting] Completed: ${processedRows} rows, ${highlightedWordsCount} phrases highlighted`);
      logToGroundTruthTextarea(`Completed: ${processedRows} rows, ${highlightedWordsCount} phrases highlighted`);
      
      // Recalculate metrics based on highlighting results
      recalculateMetricsFromHighlighting();
    }
    
    // Recalculate ground truth metrics based on highlighting results
    function recalculateMetricsFromHighlighting() {
      console.log('[Metrics Recalculation] Starting recalculation based on highlighting results...');
      logToGroundTruthTextarea('Recalculating metrics based on highlighting results...');
      
      const comparisonContainer = document.getElementById('comparisonTableContainer');
      if (!comparisonContainer) {
        console.warn('[Metrics Recalculation] Comparison table container not found');
        return;
      }
      
      const table = comparisonContainer.querySelector('table.comparison-table') || comparisonContainer.querySelector('table');
      if (!table) {
        console.warn('[Metrics Recalculation] Comparison table not found');
        return;
      }
      
      const tbody = table.querySelector('tbody');
      if (!tbody) {
        console.warn('[Metrics Recalculation] Table body not found');
        return;
      }
      
      const rows = tbody.querySelectorAll('tr');
      if (rows.length === 0) {
        console.warn('[Metrics Recalculation] No rows found');
        return;
      }
      
      let standardTotalWords = 0;
      let standardHighlightedWords = 0;
      let nextLevelTotalWords = 0;
      let nextLevelHighlightedWords = 0;
      
      // Count words in highlighted spans
      rows.forEach((row, rowIndex) => {
        const cells = row.querySelectorAll('td');
        if (cells.length < 7) return;
        
        const textOriginal = cells[2]?.textContent?.trim() || '';
        const textStandard = cells[4]?.textContent?.trim() || '';
        const textNextLevel = cells[6]?.textContent?.trim() || '';
        
        if (!textOriginal || textOriginal === '‚Äî' || textOriginal === '') return;
        
        // Count total words in original (this is our baseline)
        const originalWords = normalizeTextToWords(textOriginal);
        const totalWords = originalWords.length;
        
        // Count highlighted words in Original column
        const originalHighlights = cells[2].querySelectorAll('span[style*="background-color"]');
        let originalYellowCount = 0; // Missing in Standard
        let originalRedCount = 0; // Missing in NextLevel
        let originalOrangeCount = 0; // Missing in both
        
        originalHighlights.forEach(span => {
          const style = span.getAttribute('style') || '';
          const highlightedText = span.textContent.trim();
          const highlightedWords = normalizeTextToWords(highlightedText);
          const wordCount = highlightedWords.length;
          
          if (style.includes('#fff9c4') || style.includes('yellow')) {
            originalYellowCount += wordCount; // Missing in Standard
          } else if (style.includes('#ffebee') || style.includes('red')) {
            originalRedCount += wordCount; // Missing in NextLevel
          } else if (style.includes('#ffe0b2') || style.includes('orange')) {
            originalOrangeCount += wordCount; // Missing in both
          }
        });
        
        // Count highlighted words in Standard column (yellow = extra/different in Standard)
        const standardHighlights = cells[4].querySelectorAll('span[style*="background-color"]');
        let standardHighlightedCount = 0;
        standardHighlights.forEach(span => {
          const highlightedText = span.textContent.trim();
          const highlightedWords = normalizeTextToWords(highlightedText);
          standardHighlightedCount += highlightedWords.length;
        });
        
        // Count highlighted words in NextLevel column (red = extra/different in NextLevel)
        const nextLevelHighlights = cells[6].querySelectorAll('span[style*="background-color"]');
        let nextLevelHighlightedCount = 0;
        nextLevelHighlights.forEach(span => {
          const highlightedText = span.textContent.trim();
          const highlightedWords = normalizeTextToWords(highlightedText);
          nextLevelHighlightedCount += highlightedWords.length;
        });
        
        // For Standard: missing words (yellow/orange in Original) + extra/different words (yellow in Standard)
        standardTotalWords += totalWords;
        standardHighlightedWords += originalYellowCount + originalOrangeCount + standardHighlightedCount;
        
        // For NextLevel: missing words (red/orange in Original) + extra/different words (red in NextLevel)
        nextLevelTotalWords += totalWords;
        nextLevelHighlightedWords += originalRedCount + originalOrangeCount + nextLevelHighlightedCount;
      });
      
      // Calculate percentages
      const standardMatchPercent = standardTotalWords > 0
        ? ((standardTotalWords - standardHighlightedWords) / standardTotalWords * 100).toFixed(1)
        : 0;
      
      const nextLevelMatchPercent = nextLevelTotalWords > 0
        ? ((nextLevelTotalWords - nextLevelHighlightedWords) / nextLevelTotalWords * 100).toFixed(1)
        : 0;
      
      // Calculate matched, unmatched, and extra
      const standardMatched = standardTotalWords - standardHighlightedWords;
      const standardUnmatched = standardHighlightedWords; // Highlighted words are unmatched/extra
      const standardExtra = 0; // We don't track extra separately in highlighting
      
      const nextLevelMatched = nextLevelTotalWords - nextLevelHighlightedWords;
      const nextLevelUnmatched = nextLevelHighlightedWords;
      const nextLevelExtra = 0;
      
      // Comparison
      const improvement = parseFloat(nextLevelMatchPercent) - parseFloat(standardMatchPercent);
      const isBetter = improvement > 0;
      
      // Update metrics display
      const metricsContainer = document.getElementById('groundTruthMetricsContainer');
      const metricsContent = document.getElementById('groundTruthMetricsContent');
      
      if (metricsContainer && metricsContent) {
        const nextLevelColor = parseFloat(nextLevelMatchPercent) >= 90 ? '#10b981' : parseFloat(nextLevelMatchPercent) >= 70 ? '#f59e0b' : '#ef4444';
        const speechmaticsColor = parseFloat(standardMatchPercent) >= 90 ? '#10b981' : parseFloat(standardMatchPercent) >= 70 ? '#f59e0b' : '#ef4444';
        const comparisonColor = isBetter ? '#10b981' : '#ef4444';
        const comparisonIcon = isBetter ? '‚úÖ' : '‚ùå';
        
        let html = '';
        
        // NextLevel metrics
        html += `
          <div style="margin-bottom: 16px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
              <span style="color: #fff; font-weight: 600;">NextLevel Diarizator:</span>
              <span style="color: ${nextLevelColor}; font-weight: bold; font-size: 18px;">${nextLevelMatchPercent}%</span>
            </div>
            <div style="background: #2a2a2a; height: 8px; border-radius: 4px; overflow: hidden; margin-bottom: 8px;">
              <div style="background: ${nextLevelColor}; height: 100%; width: ${nextLevelMatchPercent}%; transition: width 0.3s;"></div>
            </div>
            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; color: #aaa; font-size: 12px;">
              <div>Matched: ${nextLevelMatched}/${nextLevelTotalWords}</div>
              <div>Unmatched: ${nextLevelUnmatched}</div>
              <div>Extra: ${nextLevelExtra}</div>
            </div>
          </div>
        `;
        
        // Speechmatics metrics
        html += `
          <div style="margin-bottom: 16px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
              <span style="color: #fff; font-weight: 600;">Speechmatics (Standard):</span>
              <span style="color: ${speechmaticsColor}; font-weight: bold; font-size: 18px;">${standardMatchPercent}%</span>
            </div>
            <div style="background: #2a2a2a; height: 8px; border-radius: 4px; overflow: hidden; margin-bottom: 8px;">
              <div style="background: ${speechmaticsColor}; height: 100%; width: ${standardMatchPercent}%; transition: width 0.3s;"></div>
            </div>
            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; color: #aaa; font-size: 12px;">
              <div>Matched: ${standardMatched}/${standardTotalWords}</div>
              <div>Unmatched: ${standardUnmatched}</div>
              <div>Extra: ${standardExtra}</div>
            </div>
          </div>
        `;
        
        // Comparison
        html += `
          <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid #333;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <span style="color: #fff; font-weight: 600;">${comparisonIcon} Comparison:</span>
              <span style="color: ${comparisonColor}; font-weight: bold; font-size: 16px;">
                NextLevel is ${isBetter ? 'BETTER' : 'WORSE'} by ${Math.abs(improvement).toFixed(1)}%
              </span>
            </div>
          </div>
        `;
        
        metricsContent.innerHTML = html;
        
        console.log('[Metrics Recalculation] Metrics recalculated:', {
          standard: {
            percent: standardMatchPercent,
            matched: standardMatched,
            total: standardTotalWords,
            highlighted: standardHighlightedWords
          },
          nextLevel: {
            percent: nextLevelMatchPercent,
            matched: nextLevelMatched,
            total: nextLevelTotalWords,
            highlighted: nextLevelHighlightedWords
          },
          improvement: improvement
        });
        
        logToGroundTruthTextarea('Metrics recalculated based on highlighting', {
          standardPercent: standardMatchPercent,
          nextLevelPercent: nextLevelMatchPercent,
          improvement: improvement.toFixed(1)
        });
      }
    }
    
    // ============================================
    // End of Color Marking Functions
    // ============================================
    
    // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –∑–∞—Å—Ç–æ—Å—É–≤–∞–Ω–Ω—è –æ—Ä–∏–≥—ñ–Ω–∞–ª—å–Ω–∏—Ö —Ä–µ–ø–ª—ñ–∫ –∑ JSON –¥–æ —Ç–∞–±–ª–∏—Ü—ñ –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è
    async function applyOriginalReplicas() {
      const startTime = Date.now();
      console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
      console.log('üöÄ [applyOriginalReplicas] STARTING');
      console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
      
      const btn = document.getElementById('applyBtn');
      const groundTruthTextarea = document.getElementById('groundTruthTextarea');
      
      console.log('üìã [applyOriginalReplicas] STEP 1: Checking inputs...');
      console.log('üìã [applyOriginalReplicas] Elements found:', {
        btn: !!btn,
        groundTruthTextarea: !!groundTruthTextarea,
        textareaValue: groundTruthTextarea ? {
          hasValue: !!groundTruthTextarea.value,
          length: groundTruthTextarea.value?.length || 0,
          preview: groundTruthTextarea.value?.substring(0, 50) || 'empty'
        } : 'not found'
      });
      
      if (!groundTruthTextarea || !groundTruthTextarea.value.trim()) {
        console.error('‚ùå [applyOriginalReplicas] Textarea is empty or not found');
        alert('‚ö†Ô∏è –ü–æ–ª–µ Ground Truth –ø–æ—Ä–æ–∂–Ω—î. –°–ø–æ—á–∞—Ç–∫—É –∑–∞–≤–∞–Ω—Ç–∞–∂—Ç–µ —Ñ–∞–π–ª —Ç–∞ –Ω–∞—Ç–∏—Å–Ω—ñ—Ç—å "Run".');
        return;
      }
      
      try {
        if (btn) {
          console.log('üìã [applyOriginalReplicas] STEP 2: Updating button state...');
          btn.disabled = true;
          btn.style.opacity = '0.6';
          btn.style.cursor = 'not-allowed';
          btn.innerHTML = '‚è≥ Applying...';
        }
        
        // –ü–∞—Ä—Å–∏–º–æ JSON –∑ textarea
        console.log('üìã [applyOriginalReplicas] STEP 3: Parsing JSON...');
        let jsonText = groundTruthTextarea.value.trim();
        
        console.log('üìã [applyOriginalReplicas] Initial JSON text:', {
          length: jsonText.length,
          startsWithBrace: jsonText.startsWith('{'),
          preview: jsonText.substring(0, 100)
        });
        
        // –Ø–∫—â–æ textarea –ø–æ—Ä–æ–∂–Ω—ñ–π –∞–±–æ –º—ñ—Å—Ç–∏—Ç—å –Ω–µ JSON, —Å–ø—Ä–æ–±—É—î–º–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞—Ç–∏ –∑–±–µ—Ä–µ–∂–µ–Ω–∏–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç
        if (!jsonText || !jsonText.startsWith('{')) {
          console.log('‚ö†Ô∏è [applyOriginalReplicas] Textarea does not contain JSON, checking window.lastGroundTruthResult...');
          if (window.lastGroundTruthResult) {
            jsonText = window.lastGroundTruthResult;
            console.log('‚úÖ [applyOriginalReplicas] Using saved JSON result from window.lastGroundTruthResult', {
              length: jsonText.length,
              preview: jsonText.substring(0, 100)
            });
          } else {
            console.error('‚ùå [applyOriginalReplicas] No JSON found in textarea and no saved result');
          }
        }
        
        let data;
        try {
          console.log('üìã [applyOriginalReplicas] Attempting to parse JSON...');
          data = JSON.parse(jsonText);
          console.log('‚úÖ [applyOriginalReplicas] JSON parsed successfully', {
            hasOriginalReplicas: !!data.originalReplicas,
            originalReplicasCount: data.originalReplicas?.length || 0,
            hasNextLevelReplicas: !!data.nextLevelReplicas,
            nextLevelReplicasCount: data.nextLevelReplicas?.length || 0
          });
        } catch (error) {
          console.error('‚ùå [applyOriginalReplicas] JSON parsing error:', error);
          console.error('‚ùå [applyOriginalReplicas] JSON text (first 500 chars):', jsonText.substring(0, 500));
          throw new Error('–ù–µ –≤–¥–∞–ª–æ—Å—è —Ä–æ–∑–ø–∞—Ä—Å–∏—Ç–∏ JSON. –ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–∏—Ö: ' + error.message);
        }
        
        // –û—Ç—Ä–∏–º—É—î–º–æ –º–∞—Å–∏–≤ originalReplicas
        const originalReplicas = data.originalReplicas || [];
        
        if (originalReplicas.length === 0) {
          throw new Error('–ù–µ –∑–Ω–∞–π–¥–µ–Ω–æ originalReplicas –≤ JSON. –ü–µ—Ä–µ–∫–æ–Ω–∞–π—Ç–µ—Å—è, —â–æ –≤–∏ –Ω–∞—Ç–∏—Å–Ω—É–ª–∏ "Run" –ø—ñ—Å–ª—è –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —Ñ–∞–π–ª—É.');
        }
        
        console.log('üìã [applyOriginalReplicas] STEP 4: Finding comparison table...');
        console.log(`üîÑ [applyOriginalReplicas] Applying ${originalReplicas.length} replicas to comparison table...`);
        
        // –ó–Ω–∞—Ö–æ–¥–∏–º–æ —Ç–∞–±–ª–∏—Ü—é –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è
        const comparisonContainer = document.getElementById('comparisonTableContainer');
        console.log('üìã [applyOriginalReplicas] Comparison container:', {
          found: !!comparisonContainer,
          innerHTML: comparisonContainer ? comparisonContainer.innerHTML.substring(0, 200) : 'not found'
        });
        
        if (!comparisonContainer) {
          throw new Error('–¢–∞–±–ª–∏—Ü—è –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∞. –ü–µ—Ä–µ–∫–æ–Ω–∞–π—Ç–µ—Å—è, —â–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏ –¥—ñ–∞—Ä–∏–∑–∞—Ü—ñ—ó –≤—ñ–¥–æ–±—Ä–∞–∂–µ–Ω—ñ.');
        }
        
        const table = comparisonContainer.querySelector('table.comparison-table') || 
                      comparisonContainer.querySelector('table');
        
        console.log('üìã [applyOriginalReplicas] Table found:', {
          found: !!table,
          className: table?.className,
          rowCount: table ? table.querySelectorAll('tbody tr, tr').length : 0
        });
        
        if (!table) {
          throw new Error('–¢–∞–±–ª–∏—Ü—è –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∞ –≤ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—ñ –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è.');
        }
        
        // –ó–Ω–∞—Ö–æ–¥–∏–º–æ –≤—Å—ñ —Ä—è–¥–∫–∏ —Ç–∞–±–ª–∏—Ü—ñ
        const tbody = table.querySelector('tbody');
        const allRows = tbody ? tbody.querySelectorAll('tr') : table.querySelectorAll('tr');
        
        // –í–∏–∑–Ω–∞—á–∞—î–º–æ, —á–∏ –ø–µ—Ä—à–∏–π —Ä—è–¥–æ–∫ - —Ü–µ –∑–∞–≥–æ–ª–æ–≤–æ–∫
        let dataRowStartIndex = 0;
        if (allRows.length > 0) {
          const firstRow = allRows[0];
          if (firstRow.querySelector('th')) {
            dataRowStartIndex = 1; // –ü—Ä–æ–ø—É—Å–∫–∞—î–º–æ –∑–∞–≥–æ–ª–æ–≤–æ–∫
          }
        }
        
        let appliedCount = 0;
        
        // –ü—Ä–æ—Ö–æ–¥–∏–º–æ –ø–æ —Ä—è–¥–∫–∞—Ö –¥–∞–Ω–∏—Ö —Ç–∞–±–ª–∏—Ü—ñ
        for (let i = dataRowStartIndex; i < allRows.length; i++) {
          const row = allRows[i];
          const cells = row.querySelectorAll('td');
          
          // –ü–æ—Ä—è–¥–æ–∫ –∫–æ–ª–æ–Ω–æ–∫: Segment ID (0) | Role Original (1) | Text Original (2) | ...
          if (cells.length > 2) {
            // –ù–æ–º–µ—Ä —Ä—è–¥–∫–∞ –≤ —Ç–∞–±–ª–∏—Ü—ñ (–ø–æ—á–∏–Ω–∞—î—Ç—å—Å—è –∑ 1, –Ω–µ –≤—Ä–∞—Ö–æ–≤—É—é—á–∏ –∑–∞–≥–æ–ª–æ–≤–æ–∫)
            const tableRowNumber = i - dataRowStartIndex + 1;
            
            // –ó–Ω–∞—Ö–æ–¥–∏–º–æ –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω—É —Ä–µ–ø–ª—ñ–∫—É –∑ JSON –∑–∞ replicaNumber
            const replica = originalReplicas.find(r => r.replicaNumber === tableRowNumber);
            
            if (replica) {
              // –û–Ω–æ–≤–ª—é—î–º–æ –∫–æ–º—ñ—Ä–∫—É Role Original (—ñ–Ω–¥–µ–∫—Å 1)
              const roleCell = cells[1];
              if (roleCell) {
                roleCell.innerHTML = replica.role ? escapeHtml(replica.role) : '<span class="comparison-empty">‚Äî</span>';
              }
              
              // –û–Ω–æ–≤–ª—é—î–º–æ –∫–æ–º—ñ—Ä–∫—É Text Original (—ñ–Ω–¥–µ–∫—Å 2)
              const textCell = cells[2];
              if (textCell) {
                textCell.innerHTML = replica.text ? escapeHtml(replica.text) : '<span class="comparison-empty">‚Äî</span>';
              }
              
              appliedCount++;
              console.log(`‚úÖ [applyOriginalReplicas] Applied replica ${replica.replicaNumber} to table row ${tableRowNumber}:`, {
                role: replica.role,
                text: replica.text.substring(0, 50)
              });
            }
          }
        }
        
        // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –∑–∞—Å—Ç–æ—Å–æ–≤–∞–Ω—ñ —Ä–µ–ø–ª—ñ–∫–∏ –≤ –≥–ª–æ–±–∞–ª—å–Ω—É –∑–º—ñ–Ω–Ω—É –¥–ª—è –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è –ø—Ä–∏ –ø–æ–≤—Ç–æ—Ä–Ω–æ–º—É —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥—É
        if (appliedCount > 0) {
          window.appliedOriginalReplicas = originalReplicas;
          console.log(`‚úÖ [applyOriginalReplicas] Saved ${appliedCount} replicas to window.appliedOriginalReplicas for future renders`);
        }
        
        const elapsed = Date.now() - startTime;
        console.log(`‚úÖ [applyOriginalReplicas] STEP 5: Applied ${appliedCount} replicas (${elapsed}ms)`);
        
        if (appliedCount === 0) {
          console.error('‚ùå [applyOriginalReplicas] No replicas were applied!');
          alert('‚ö†Ô∏è –ù–µ –∑–Ω–∞–π–¥–µ–Ω–æ –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–∏—Ö —Ä—è–¥–∫—ñ–≤ –¥–ª—è –æ–Ω–æ–≤–ª–µ–Ω–Ω—è. –ü–µ—Ä–µ–∫–æ–Ω–∞–π—Ç–µ—Å—è, —â–æ –Ω–æ–º–µ—Ä–∏ —Ä—è–¥–∫—ñ–≤ —É JSON –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—é—Ç—å –Ω–æ–º–µ—Ä–∞–º —Ä—è–¥–∫—ñ–≤ —É —Ç–∞–±–ª–∏—Ü—ñ.');
        } else {
          // –ü–æ–∫–∞–∑—É—î–º–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –ø—Ä–æ —É—Å–ø—ñ—Ö
          const successMsg = document.createElement('div');
          successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #27ae60; color: white; padding: 12px 20px; border-radius: 8px; z-index: 10000; box-shadow: 0 4px 6px rgba(0,0,0,0.1);';
          successMsg.innerHTML = `‚úÖ –ó–∞—Å—Ç–æ—Å–æ–≤–∞–Ω–æ ${appliedCount} —Ä–µ–ø–ª—ñ–∫ –¥–æ —Ç–∞–±–ª–∏—Ü—ñ –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è`;
          document.body.appendChild(successMsg);
          setTimeout(() => successMsg.remove(), 3000);
          
          // –ü–µ—Ä–µ—Ä–∞—Ö–æ–≤—É—î–º–æ –º–µ—Ç—Ä–∏–∫–∏ –ø—ñ—Å–ª—è –∑–∞—Å—Ç–æ—Å—É–≤–∞–Ω–Ω—è —Ä–µ–ø–ª—ñ–∫
          console.log('üìã [applyOriginalReplicas] STEP 6: Calculating metrics...');
          try {
            await waitForComparisonTable(10, 200);
            calculateGroundTruthMetricsFromTable();
            console.log('‚úÖ [applyOriginalReplicas] Metrics calculated successfully');
          } catch (error) {
            console.warn('‚ö†Ô∏è [applyOriginalReplicas] Could not wait for table, calculating metrics anyway:', error);
            calculateGroundTruthMetricsFromTable();
          }
        }
        
        const totalElapsed = Date.now() - startTime;
        console.log(`‚úÖ [applyOriginalReplicas] COMPLETED in ${totalElapsed}ms`);
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        
      } catch (error) {
        console.error('‚ùå [applyOriginalReplicas] Error:', error);
        alert(`‚ùå –ü–æ–º–∏–ª–∫–∞: ${error.message}`);
      } finally {
        if (btn) {
          btn.disabled = false;
          btn.style.opacity = '1';
          btn.style.cursor = 'pointer';
          btn.innerHTML = '‚úÖ Apply';
        }
      }
    }
    
    // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –∑–±–æ—Ä—É –≤–∏–¥—ñ–ª–µ–Ω–∏—Ö —Ñ—Ä–∞–≥–º–µ–Ω—Ç—ñ–≤ –∑ —Ç–∞–±–ª–∏—Ü—ñ –∑ –≥—Ä—É–ø—É–≤–∞–Ω–Ω—è–º —Å—É—Å—ñ–¥–Ω—ñ—Ö
    function collectHighlightedFragments() {
      const fragments = {
        blue: [],
        green: [],
        red: []
      };
      
      // –ó–Ω–∞—Ö–æ–¥–∏–º–æ –≤—Å—ñ –≤–∏–¥—ñ–ª–µ–Ω—ñ –µ–ª–µ–º–µ–Ω—Ç–∏ –≤ —Ç–∞–±–ª–∏—Ü—ñ
      const markdownContainer = document.getElementById('markdownTableContainer');
      if (!markdownContainer) {
        return fragments;
      }
      
      // –ó–Ω–∞—Ö–æ–¥–∏–º–æ –≤—Å—ñ –∫–æ–º—ñ—Ä–∫–∏ —Ç–∞–±–ª–∏—Ü—ñ –∑ —Ç–µ–∫—Å—Ç–æ–º
      const tableCells = markdownContainer.querySelectorAll('td');
      
      // –ü—Ä–æ—Ö–æ–¥–∏–º–æ –ø–æ –∫–æ–∂–Ω—ñ–π –∫–æ–º—ñ—Ä—Ü—ñ —ñ –∑–±–∏—Ä–∞—î–º–æ –≤–∏–¥—ñ–ª–µ–Ω—ñ —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∏
      tableCells.forEach(cell => {
        // –ó–Ω–∞—Ö–æ–¥–∏–º–æ –≤—Å—ñ –≤–∏–¥—ñ–ª–µ–Ω—ñ –µ–ª–µ–º–µ–Ω—Ç–∏ –≤ –∫–æ–º—ñ—Ä—Ü—ñ
        const highlightedSpans = Array.from(cell.querySelectorAll('.text-highlight-blue, .text-highlight-green, .text-highlight-red'));
        
        if (highlightedSpans.length === 0) {
          return; // –ù–µ–º–∞—î –≤–∏–¥—ñ–ª–µ–Ω–∏—Ö –µ–ª–µ–º–µ–Ω—Ç—ñ–≤
        }
        
        // –°—Ç–≤–æ—Ä—é—î–º–æ TreeWalker –¥–ª—è –æ–±—Ö–æ–¥—É –≤—Å—ñ—Ö –≤—É–∑–ª—ñ–≤ —É –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º—É –ø–æ—Ä—è–¥–∫—É
        const walker = document.createTreeWalker(
          cell,
          NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT,
          null
        );
        
        // –ó–±–∏—Ä–∞—î–º–æ –≤—Å—ñ –≤—É–∑–ª–∏ –≤ –ø–æ—Ä—è–¥–∫—É —ó—Ö –ø–æ—è–≤–∏
        const allNodes = [];
        let node;
        while (node = walker.nextNode()) {
          allNodes.push(node);
        }
        
        // –¢–µ–ø–µ—Ä –ø—Ä–æ—Ö–æ–¥–∏–º–æ –ø–æ –≤—É–∑–ª–∞—Ö —ñ –≥—Ä—É–ø—É—î–º–æ —Å—É—Å—ñ–¥–Ω—ñ –µ–ª–µ–º–µ–Ω—Ç–∏ –æ–¥–Ω–æ–≥–æ –∫–æ–ª—å–æ—Ä—É
        let currentGroup = null; // { color: 'blue'|'green'|'red', text: '...' }
        
        for (let i = 0; i < allNodes.length; i++) {
          const node = allNodes[i];
          let nodeColor = null;
          let isHighlighted = false;
          let nodeText = '';
          
          if (node.nodeType === Node.ELEMENT_NODE) {
            if (node.classList.contains('text-highlight-blue')) {
              nodeColor = 'blue';
              isHighlighted = true;
              nodeText = node.textContent || '';
            } else if (node.classList.contains('text-highlight-green')) {
              nodeColor = 'green';
              isHighlighted = true;
              nodeText = node.textContent || '';
            } else if (node.classList.contains('text-highlight-red')) {
              nodeColor = 'red';
              isHighlighted = true;
              nodeText = node.textContent || '';
            }
          } else if (node.nodeType === Node.TEXT_NODE) {
            nodeText = node.textContent || '';
          }
          
          // –Ø–∫—â–æ –∑–Ω–∞–π—à–ª–∏ –≤–∏–¥—ñ–ª–µ–Ω–∏–π –µ–ª–µ–º–µ–Ω—Ç
          if (isHighlighted && nodeColor && nodeText.trim()) {
            if (currentGroup && currentGroup.color === nodeColor) {
              // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ –º—ñ–∂ –ø–æ–ø–µ—Ä–µ–¥–Ω—ñ–º –≤–∏–¥—ñ–ª–µ–Ω–∏–º –µ–ª–µ–º–µ–Ω—Ç–æ–º —ñ —Ü–∏–º —î —Ç—ñ–ª—å–∫–∏ –ø—Ä–æ–±—ñ–ª–∏
              let canContinue = false;
              let betweenText = '';
              
              // –ó–Ω–∞—Ö–æ–¥–∏–º–æ –ø–æ–ø–µ—Ä–µ–¥–Ω—ñ–π –≤–∏–¥—ñ–ª–µ–Ω–∏–π –µ–ª–µ–º–µ–Ω—Ç —Ç–æ–≥–æ –∂ –∫–æ–ª—å–æ—Ä—É
              let prevHighlightedIndex = -1;
              for (let j = i - 1; j >= 0; j--) {
                const prevNode = allNodes[j];
                if (prevNode.nodeType === Node.ELEMENT_NODE) {
                  let prevColor = null;
                  if (prevNode.classList.contains('text-highlight-blue')) {
                    prevColor = 'blue';
                  } else if (prevNode.classList.contains('text-highlight-green')) {
                    prevColor = 'green';
                  } else if (prevNode.classList.contains('text-highlight-red')) {
                    prevColor = 'red';
                  }
                  
                  if (prevColor === nodeColor) {
                    prevHighlightedIndex = j;
                    break;
                  } else if (prevColor !== null) {
                    // –Ü–Ω—à–∏–π –∫–æ–ª—ñ—Ä - –Ω–µ –º–æ–∂–µ–º–æ –ø—Ä–æ–¥–æ–≤–∂–∏—Ç–∏
                    break;
                  }
                }
              }
              
              if (prevHighlightedIndex >= 0) {
                // –ó–±–∏—Ä–∞—î–º–æ –≤–µ—Å—å —Ç–µ–∫—Å—Ç –º—ñ–∂ –ø–æ–ø–µ—Ä–µ–¥–Ω—ñ–º –≤–∏–¥—ñ–ª–µ–Ω–∏–º –µ–ª–µ–º–µ–Ω—Ç–æ–º —ñ —Ü–∏–º
                for (let j = prevHighlightedIndex + 1; j < i; j++) {
                  const betweenNode = allNodes[j];
                  if (betweenNode.nodeType === Node.TEXT_NODE) {
                    betweenText += betweenNode.textContent || '';
                  } else if (betweenNode.nodeType === Node.ELEMENT_NODE) {
                    // –Ø–∫—â–æ –º—ñ–∂ –Ω–∏–º–∏ —î –Ω–µ–≤–∏–¥—ñ–ª–µ–Ω–∏–π –µ–ª–µ–º–µ–Ω—Ç - –Ω–µ –º–æ–∂–µ–º–æ –ø—Ä–æ–¥–æ–≤–∂–∏—Ç–∏
                    if (!betweenNode.classList.contains('text-highlight-blue') &&
                        !betweenNode.classList.contains('text-highlight-green') &&
                        !betweenNode.classList.contains('text-highlight-red')) {
                      betweenText = null; // –°–∏–≥–Ω–∞–ª, —â–æ –Ω–µ –º–æ–∂–µ–º–æ –ø—Ä–æ–¥–æ–≤–∂–∏—Ç–∏
                      break;
                    }
                  }
                }
                
                // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ –º—ñ–∂ –Ω–∏–º–∏ —î —Ç—ñ–ª—å–∫–∏ –ø—Ä–æ–±—ñ–ª–∏
                if (betweenText !== null) {
                  // –Ø–∫—â–æ –º—ñ–∂ –Ω–∏–º–∏ —Ç—ñ–ª—å–∫–∏ –ø—Ä–æ–±—ñ–ª–∏ –∞–±–æ –ø–æ—Ä–æ–∂–Ω—å–æ - –º–æ–∂–µ–º–æ –ø—Ä–æ–¥–æ–≤–∂–∏—Ç–∏
                  // –¢–∞–∫–æ–∂ –¥–æ–∑–≤–æ–ª—è—î–º–æ –ø—Ä–æ–¥–æ–≤–∂–∏—Ç–∏, —è–∫—â–æ –º—ñ–∂ –Ω–∏–º–∏ –Ω–µ–º–∞—î –≤—É–∑–ª—ñ–≤ –≤–∑–∞–≥–∞–ª—ñ (–µ–ª–µ–º–µ–Ω—Ç–∏ –π–¥—É—Ç—å –ø—ñ–¥—Ä—è–¥)
                  if (betweenText === '' || betweenText.trim() === '' || /^\s+$/.test(betweenText)) {
                    canContinue = true;
                  }
                } else if (prevHighlightedIndex + 1 === i) {
                  // –Ø–∫—â–æ –º—ñ–∂ –Ω–∏–º–∏ –Ω–µ–º–∞—î –≤—É–∑–ª—ñ–≤ –≤–∑–∞–≥–∞–ª—ñ (–µ–ª–µ–º–µ–Ω—Ç–∏ –π–¥—É—Ç—å –ø—ñ–¥—Ä—è–¥) - –º–æ–∂–µ–º–æ –ø—Ä–æ–¥–æ–≤–∂–∏—Ç–∏
                  canContinue = true;
                }
              }
              
              if (canContinue) {
                // –ú–æ–∂–µ–º–æ –ø—Ä–æ–¥–æ–≤–∂–∏—Ç–∏ –≥—Ä—É–ø—É - –¥–æ–¥–∞—î–º–æ —Ç–µ–∫—Å—Ç –º—ñ–∂ –µ–ª–µ–º–µ–Ω—Ç–∞–º–∏ —Ç–∞ –ø–æ—Ç–æ—á–Ω–∏–π —Ç–µ–∫—Å—Ç
                if (betweenText) {
                  currentGroup.text += betweenText + nodeText.trim();
                } else {
                  currentGroup.text += ' ' + nodeText.trim();
                }
              } else {
                // –ù–µ –º–æ–∂–µ–º–æ –ø—Ä–æ–¥–æ–≤–∂–∏—Ç–∏ - –∑–±–µ—Ä—ñ–≥–∞—î–º–æ –ø–æ–ø–µ—Ä–µ–¥–Ω—é –≥—Ä—É–ø—É
                if (currentGroup.text.trim()) {
                  const text = currentGroup.text.trim();
                  if (text && !fragments[currentGroup.color].includes(text)) {
                    fragments[currentGroup.color].push(text);
                  }
                }
                // –ü–æ—á–∏–Ω–∞—î–º–æ –Ω–æ–≤—É –≥—Ä—É–ø—É
                currentGroup = {
                  color: nodeColor,
                  text: nodeText.trim()
                };
              }
            } else {
              // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –ø–æ–ø–µ—Ä–µ–¥–Ω—é –≥—Ä—É–ø—É, —è–∫—â–æ –≤–æ–Ω–∞ –±—É–ª–∞
              if (currentGroup && currentGroup.text.trim()) {
                const text = currentGroup.text.trim();
                if (text && !fragments[currentGroup.color].includes(text)) {
                  fragments[currentGroup.color].push(text);
                }
              }
              // –ü–æ—á–∏–Ω–∞—î–º–æ –Ω–æ–≤—É –≥—Ä—É–ø—É
              currentGroup = {
                color: nodeColor,
                text: nodeText.trim()
              };
            }
          } else if (node.nodeType === Node.TEXT_NODE && nodeText) {
            // –¢–µ–∫—Å—Ç–æ–≤–∏–π –≤—É–∑–æ–ª
            const hasNonWhitespace = /[^\s]/.test(nodeText);
            
            if (hasNonWhitespace && currentGroup) {
              // –ù–µ–≤–∏–¥—ñ–ª–µ–Ω–∏–π —Ç–µ–∫—Å—Ç (–Ω–µ —Ç—ñ–ª—å–∫–∏ –ø—Ä–æ–±—ñ–ª–∏) - –∑–∞–≤–µ—Ä—à—É—î–º–æ –ø–æ—Ç–æ—á–Ω—É –≥—Ä—É–ø—É
              if (currentGroup.text.trim()) {
                const text = currentGroup.text.trim();
                if (text && !fragments[currentGroup.color].includes(text)) {
                  fragments[currentGroup.color].push(text);
                }
              }
              currentGroup = null;
            }
          } else if (!isHighlighted && node.nodeType === Node.ELEMENT_NODE) {
            // –ù–µ –≤–∏–¥—ñ–ª–µ–Ω–∏–π –µ–ª–µ–º–µ–Ω—Ç - –∑–∞–≤–µ—Ä—à—É—î–º–æ –ø–æ—Ç–æ—á–Ω—É –≥—Ä—É–ø—É
            if (currentGroup && currentGroup.text.trim()) {
              const text = currentGroup.text.trim();
              if (text && !fragments[currentGroup.color].includes(text)) {
                fragments[currentGroup.color].push(text);
              }
              currentGroup = null;
            }
          }
        }
        
        // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –æ—Å—Ç–∞–Ω–Ω—é –≥—Ä—É–ø—É, —è–∫—â–æ –≤–æ–Ω–∞ –∑–∞–ª–∏—à–∏–ª–∞—Å—è
        if (currentGroup && currentGroup.text.trim()) {
          const text = currentGroup.text.trim();
          if (text && !fragments[currentGroup.color].includes(text)) {
            fragments[currentGroup.color].push(text);
          }
        }
      });
      
      return fragments;
    }
    
    // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –∑–∞–∫—Ä–∏—Ç—Ç—è –º–æ–¥–∞–ª—å–Ω–æ–≥–æ –≤—ñ–∫–Ω–∞
    function closeDebugModal() {
      document.getElementById('debugModal').style.display = 'none';
    }
    
    // –§—É–Ω–∫—Ü—ñ—ó –¥–ª—è —Ä–æ–±–æ—Ç–∏ –∑ Speechmatics Recognition Modal
    function showSpeechmaticsRecognitionModal() {
      const modal = document.getElementById('speechmaticsModal');
      const statusEl = document.getElementById('speechmaticsStatus');
      const resultEl = document.getElementById('speechmaticsResult');
      const fileInput = document.getElementById('speechmaticsAudioFile');
      const fileInfo = document.getElementById('speechmaticsFileInfo');
      
      // –°–∫–∏–¥–∞—î–º–æ —Ñ–æ—Ä–º—É
      if (fileInput) {
        fileInput.value = '';
      }
      fileInfo.textContent = 'No file selected';
      statusEl.textContent = 'Please select an audio file';
      resultEl.value = '';
      
      // –î–æ–¥–∞—î–º–æ –æ–±—Ä–æ–±–Ω–∏–∫ –ø–æ–¥—ñ—ó –¥–ª—è –≤–∏–±–æ—Ä—É —Ñ–∞–π–ª—É
      if (fileInput) {
        fileInput.onchange = function(e) {
          const file = e.target.files[0];
          if (file) {
            const fileSizeMB = (file.size / (1024 * 1024)).toFixed(2);
            fileInfo.textContent = `Selected: ${file.name} (${fileSizeMB} MB)`;
            statusEl.textContent = 'File selected. Ready to start Speechmatics recognition.';
            statusEl.style.color = '#333';
          } else {
            fileInfo.textContent = 'No file selected';
            statusEl.textContent = 'Please select an audio file';
          }
        };
      }
      
      modal.style.display = 'flex';
    }
    
    function closeSpeechmaticsModal() {
      document.getElementById('speechmaticsModal').style.display = 'none';
    }
    
    async function runSpeechmaticsRecognition() {
      const btn = document.getElementById('runSpeechmaticsBtn');
      const statusEl = document.getElementById('speechmaticsStatus');
      const resultEl = document.getElementById('speechmaticsResult');
      const fileInput = document.getElementById('speechmaticsAudioFile');
      const originalText = btn.innerHTML;
      
      // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –Ω–∞—è–≤–Ω—ñ—Å—Ç—å –∞—É–¥—ñ–æ —Ñ–∞–π–ª—É
      if (!fileInput || !fileInput.files || fileInput.files.length === 0) {
        alert('‚ö†Ô∏è Please select an audio file first.');
        return;
      }
      
      const audioFile = fileInput.files[0];
      
      // –û–Ω–æ–≤–ª—é—î–º–æ UI
      btn.disabled = true;
      btn.style.opacity = '0.6';
      btn.style.cursor = 'not-allowed';
      btn.innerHTML = '‚è≥ Processing...';
      statusEl.textContent = 'Uploading file and starting Speechmatics recognition...';
      statusEl.style.color = '#333';
      resultEl.value = 'Processing...';
      
      try {
        // –§–æ—Ä–º—É—î–º–æ FormData –¥–ª—è –≤—ñ–¥–ø—Ä–∞–≤–∫–∏ —Ñ–∞–π–ª—É
        const formData = new FormData();
        formData.append('audio', audioFile);
        formData.append('language', document.getElementById('language')?.value || 'en');
        const speakerCount = document.getElementById('audioSpeakerCount')?.value || 
                            document.getElementById('combinedSpeakerCount')?.value || 
                            document.getElementById('overlapSpeakerCount')?.value || 
                            '2';
        formData.append('speakerCount', speakerCount);
        formData.append('engine', 'speechmatics');
        
        // –í—ñ–¥–ø—Ä–∞–≤–ª—è—î–º–æ –∑–∞–ø–∏—Ç –Ω–∞ —Å–µ—Ä–≤–µ—Ä
        const response = await fetch('/api/diarize-audio', {
          method: 'POST',
          body: formData
        });
        
        if (!response.ok) {
          const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
          throw new Error(errorData.error || `HTTP ${response.status}`);
        }
        
        const result = await response.json();
        
        // –í—ñ–¥–æ–±—Ä–∞–∂–∞—î–º–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç
        resultEl.value = JSON.stringify(result, null, 2);
        statusEl.textContent = '‚úÖ Speechmatics recognition completed successfully!';
        statusEl.style.color = '#27ae60';
        
        console.log('‚úÖ [SPEECHMATICS] Recognition completed:', result);
        
      } catch (error) {
        console.error('‚ùå [SPEECHMATICS] Recognition error:', error);
        statusEl.textContent = `‚ùå Error: ${error.message}`;
        statusEl.style.color = '#e74c3c';
        resultEl.value = `Error: ${error.message}\n\n${error.stack || ''}`;
      } finally {
        // –í—ñ–¥–Ω–æ–≤–ª—é—î–º–æ UI
        btn.disabled = false;
        btn.style.opacity = '1';
        btn.style.cursor = 'pointer';
        btn.innerHTML = originalText;
      }
    }
    
    // –§—É–Ω–∫—Ü—ñ—ó –¥–ª—è —Ä–æ–±–æ—Ç–∏ –∑ Audio Upload Modal
    function showAudioUploadModal(onSuccess) {
      const modal = document.getElementById('audioUploadModal');
      const statusEl = document.getElementById('audioUploadStatus');
      const fileInput = document.getElementById('audioUploadFileInput');
      const fileInfo = document.getElementById('audioUploadFileInfo');
      
      // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ callback –¥–ª—è –≤–∏–∫–ª–∏–∫—É –ø—ñ—Å–ª—è –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è
      modal._onSuccess = onSuccess;
      
      // –°–∫–∏–¥–∞—î–º–æ —Ñ–æ—Ä–º—É
      if (fileInput) {
        fileInput.value = '';
      }
      fileInfo.textContent = 'No file selected';
      statusEl.textContent = 'Please select an audio file to continue multimodal processing';
      
      // –î–æ–¥–∞—î–º–æ –æ–±—Ä–æ–±–Ω–∏–∫ –ø–æ–¥—ñ—ó –¥–ª—è –≤–∏–±–æ—Ä—É —Ñ–∞–π–ª—É
      if (fileInput) {
        fileInput.onchange = function(e) {
          const file = e.target.files[0];
          if (file) {
            const fileSizeMB = (file.size / (1024 * 1024)).toFixed(2);
            fileInfo.textContent = `Selected: ${file.name} (${fileSizeMB} MB)`;
            statusEl.textContent = 'File selected. Click "Save & Continue" to proceed.';
            statusEl.style.color = '#333';
          } else {
            fileInfo.textContent = 'No file selected';
            statusEl.textContent = 'Please select an audio file';
          }
        };
      }
      
      modal.style.display = 'flex';
    }
    
    function closeAudioUploadModal() {
      document.getElementById('audioUploadModal').style.display = 'none';
    }
    
    async function saveAudioFileForMultimodal() {
      const fileInput = document.getElementById('audioUploadFileInput');
      const statusEl = document.getElementById('audioUploadStatus');
      const btn = document.getElementById('saveAudioFileBtn');
      const modal = document.getElementById('audioUploadModal');
      
      if (!fileInput || !fileInput.files || fileInput.files.length === 0) {
        alert('‚ö†Ô∏è Please select an audio file first.');
        return;
      }
      
      const audioFile = fileInput.files[0];
      const originalText = btn.innerHTML;
      
      // –û–Ω–æ–≤–ª—é—î–º–æ UI
      btn.disabled = true;
      btn.style.opacity = '0.6';
      btn.style.cursor = 'not-allowed';
      btn.innerHTML = '‚è≥ Saving...';
      statusEl.textContent = 'Saving audio file...';
      statusEl.style.color = '#333';
      
      try {
        // –ö–æ–Ω–≤–µ—Ä—Ç—É—î–º–æ —Ñ–∞–π–ª –≤ base64 –¥–ª—è –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è –≤ localStorage
        const reader = new FileReader();
        
        reader.onload = function(e) {
          try {
            const base64Data = e.target.result; // data:audio/...;base64,...
            
            // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ —Ñ–∞–π–ª –≤ localStorage
            const fileData = {
              name: audioFile.name,
              type: audioFile.type,
              size: audioFile.size,
              data: base64Data,
              timestamp: Date.now()
            };
            
            localStorage.setItem('multimodalAudioFile', JSON.stringify(fileData));
            console.log('üíæ [AUDIO UPLOAD] Audio file saved to localStorage:', {
              name: audioFile.name,
              size: audioFile.size,
              type: audioFile.type
            });
            
            // –¢–∞–∫–æ–∂ –≤—Å—Ç–∞–Ω–æ–≤–ª—é—î–º–æ —Ñ–∞–π–ª –≤ input –¥–ª—è –ø–æ–¥–∞–ª—å—à–æ–≥–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
            const audioFileInput = document.getElementById('audioFile');
            if (audioFileInput) {
              const dataTransfer = new DataTransfer();
              dataTransfer.items.add(audioFile);
              audioFileInput.files = dataTransfer.files;
              console.log('‚úÖ [AUDIO UPLOAD] File set in audioFile input');
            }
            
            statusEl.textContent = '‚úÖ File saved successfully!';
            statusEl.style.color = '#27ae60';
            
            // –ó–∞–∫—Ä–∏–≤–∞—î–º–æ –º–æ–¥–∞–ª—å–Ω–µ –≤—ñ–∫–Ω–æ
            setTimeout(() => {
              closeAudioUploadModal();
              
              // –í–∏–∫–ª–∏–∫–∞—î–º–æ callback —è–∫—â–æ –≤—ñ–Ω —î
              if (modal._onSuccess) {
                modal._onSuccess();
              }
            }, 500);
            
          } catch (error) {
            console.error('‚ùå [AUDIO UPLOAD] Error saving file:', error);
            statusEl.textContent = `‚ùå Error: ${error.message}`;
            statusEl.style.color = '#e74c3c';
            btn.disabled = false;
            btn.style.opacity = '1';
            btn.style.cursor = 'pointer';
            btn.innerHTML = originalText;
          }
        };
        
        reader.onerror = function(error) {
          console.error('‚ùå [AUDIO UPLOAD] FileReader error:', error);
          statusEl.textContent = '‚ùå Error reading file';
          statusEl.style.color = '#e74c3c';
          btn.disabled = false;
          btn.style.opacity = '1';
          btn.style.cursor = 'pointer';
          btn.innerHTML = originalText;
        };
        
        // –ß–∏—Ç–∞—î–º–æ —Ñ–∞–π–ª —è–∫ data URL (base64)
        reader.readAsDataURL(audioFile);
        
      } catch (error) {
        console.error('‚ùå [AUDIO UPLOAD] Error:', error);
        statusEl.textContent = `‚ùå Error: ${error.message}`;
        statusEl.style.color = '#e74c3c';
        btn.disabled = false;
        btn.style.opacity = '1';
        btn.style.cursor = 'pointer';
        btn.innerHTML = originalText;
      }
    }
    
    function loadAudioFileFromStorage() {
      try {
        const savedFileData = localStorage.getItem('multimodalAudioFile');
        if (!savedFileData) {
          return null;
        }
        
        const fileData = JSON.parse(savedFileData);
        
        // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ —Ñ–∞–π–ª –Ω–µ –∑–∞—Å—Ç–∞—Ä—ñ–≤ (–±—ñ–ª—å—à–µ 7 –¥–Ω—ñ–≤)
        const daysSinceSave = (Date.now() - fileData.timestamp) / (1000 * 60 * 60 * 24);
        if (daysSinceSave > 7) {
          console.log('‚ÑπÔ∏è [AUDIO UPLOAD] Saved file is older than 7 days, removing from storage');
          localStorage.removeItem('multimodalAudioFile');
          return null;
        }
        
        // –ö–æ–Ω–≤–µ—Ä—Ç—É—î–º–æ base64 –Ω–∞–∑–∞–¥ –≤ File
        const base64Data = fileData.data.includes(',') 
          ? fileData.data.split(',')[1] 
          : fileData.data;
        
        const byteCharacters = atob(base64Data);
        const byteNumbers = new Array(byteCharacters.length);
        for (let i = 0; i < byteCharacters.length; i++) {
          byteNumbers[i] = byteCharacters.charCodeAt(i);
        }
        const byteArray = new Uint8Array(byteNumbers);
        const blob = new Blob([byteArray], { type: fileData.type || 'audio/wav' });
        const file = new File([blob], fileData.name, { type: fileData.type || 'audio/wav' });
        
        console.log('‚úÖ [AUDIO UPLOAD] Loaded audio file from storage:', {
          name: fileData.name,
          size: fileData.size,
          type: fileData.type
        });
        
        return file;
      } catch (error) {
        console.error('‚ùå [AUDIO UPLOAD] Error loading file from storage:', error);
        return null;
      }
    }
    
    // –§—É–Ω–∫—Ü—ñ—ó –¥–ª—è —Ä–æ–±–æ—Ç–∏ –∑ Multimodal Diarization Modal
    function showMultimodalDiarizationModal() {
      const modal = document.getElementById('multimodalModal');
      const statusEl = document.getElementById('multimodalStatus');
      const resultEl = document.getElementById('multimodalResult');
      const fileInput = document.getElementById('multimodalAudioFile');
      const fileInfo = document.getElementById('multimodalFileInfo');
      
      // –°–∫–∏–¥–∞—î–º–æ —Ñ–æ—Ä–º—É
      if (fileInput) {
        fileInput.value = '';
      }
      fileInfo.textContent = 'No file selected';
      statusEl.textContent = 'Please select an audio file';
      resultEl.value = '';
      const dialogueEl = document.getElementById('multimodalDialogue');
      if (dialogueEl) {
        dialogueEl.value = '';
      }
      
      // –î–æ–¥–∞—î–º–æ –æ–±—Ä–æ–±–Ω–∏–∫ –ø–æ–¥—ñ—ó –¥–ª—è –≤–∏–±–æ—Ä—É —Ñ–∞–π–ª—É
      if (fileInput) {
        fileInput.onchange = function(e) {
          const file = e.target.files[0];
          if (file) {
            const fileSizeMB = (file.size / (1024 * 1024)).toFixed(2);
            fileInfo.textContent = `Selected: ${file.name} (${fileSizeMB} MB)`;
            statusEl.textContent = 'File selected. Ready to start multimodal diarization.';
            statusEl.style.color = '#333';
          } else {
            fileInfo.textContent = 'No file selected';
            statusEl.textContent = 'Please select an audio file';
          }
        };
      }
      
      modal.style.display = 'flex';
    }
    
    function closeMultimodalModal() {
      document.getElementById('multimodalModal').style.display = 'none';
    }
    
    // Separation Debug Modal Functions
    function showSeparationDebugModal() {
      const modal = document.getElementById('separationDebugModal');
      const fileInput = document.getElementById('separationDebugAudioFile');
      const fileInfo = document.getElementById('separationDebugFileInfo');
      const statusEl = document.getElementById('separationDebugStatus');
      const logEl = document.getElementById('separationDebugLog');
      const originalSection = document.getElementById('separationDebugOriginalSection');
      const tracksSection = document.getElementById('separationDebugTracksSection');
      
      // Reset form
      if (fileInput) {
        fileInput.value = '';
      }
      fileInfo.textContent = '–§–∞–π–ª –Ω–µ –≤–∏–±—Ä–∞–Ω–æ';
      statusEl.textContent = '–û—á—ñ–∫—É–≤–∞–Ω–Ω—è –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —Ñ–∞–π–ª—É...';
      logEl.value = '';
      originalSection.style.display = 'none';
      tracksSection.style.display = 'none';
      
      // Load saved settings or use defaults
      loadSeparationSettings();
      
      // Add file change handler
      if (fileInput) {
        fileInput.onchange = function(e) {
          const file = e.target.files[0];
          if (file) {
            const fileSizeMB = (file.size / (1024 * 1024)).toFixed(2);
            fileInfo.textContent = `–í–∏–±—Ä–∞–Ω–æ: ${file.name} (${fileSizeMB} MB)`;
            statusEl.textContent = '–§–∞–π–ª –≤–∏–±—Ä–∞–Ω–æ. –ì–æ—Ç–æ–≤–æ –¥–æ —Ä–æ–∑–¥—ñ–ª–µ–Ω–Ω—è.';
            statusEl.style.color = '#333';
            addLog(`–§–∞–π–ª –≤–∏–±—Ä–∞–Ω–æ: ${file.name} (${fileSizeMB} MB)`);
          } else {
            fileInfo.textContent = '–§–∞–π–ª –Ω–µ –≤–∏–±—Ä–∞–Ω–æ';
            statusEl.textContent = '–û—á—ñ–∫—É–≤–∞–Ω–Ω—è –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —Ñ–∞–π–ª—É...';
          }
        };
      }
      
      modal.style.display = 'flex';
    }
    
    function toggleSeparationSettings() {
      const panel = document.getElementById('separationSettingsPanel');
      const toggle = document.getElementById('separationSettingsToggle');
      if (panel.style.display === 'none') {
        panel.style.display = 'block';
        toggle.textContent = '‚ñ≤';
      } else {
        panel.style.display = 'none';
        toggle.textContent = '‚ñº';
      }
    }
    
    function toggleQualitySettings() {
      const panel = document.getElementById('qualitySettingsPanel');
      const toggle = document.getElementById('qualitySettingsToggle');
      if (panel.style.display === 'none') {
        panel.style.display = 'block';
        toggle.textContent = '‚ñ≤';
      } else {
        panel.style.display = 'none';
        toggle.textContent = '‚ñº';
      }
    }
    
    function toggleAdvancedSettings() {
      const panel = document.getElementById('advancedSettingsPanel');
      const toggle = document.getElementById('advancedSettingsToggle');
      if (panel.style.display === 'none') {
        panel.style.display = 'block';
        toggle.textContent = '‚ñ≤';
      } else {
        panel.style.display = 'none';
        toggle.textContent = '‚ñº';
      }
    }
    
    function resetSeparationSettings() {
      // Basic settings (–æ–ø—Ç–∏–º—ñ–∑–æ–≤–∞–Ω—ñ –¥–ª—è —è–∫–æ—Å—Ç—ñ)
      // ‚úÖ –ú–æ–¥–µ–ª—å –Ω–∞–≤—á–∞–ª–∞—Å—è –Ω–∞ 16kHz - –æ–ø—Ç–∏–º–∞–ª—å–Ω–∞ —è–∫—ñ—Å—Ç—å –¥–ª—è —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü—ñ—ó Whisper
      document.getElementById('separationChunkSeconds').value = '10';  // –û–ø—Ç–∏–º–∞–ª—å–Ω–∏–π —Ä–æ–∑–º—ñ—Ä –¥–ª—è –±–µ–∑–ø–µ—á–Ω–æ—ó –æ–±—Ä–æ–±–∫–∏ (sliding window)
      document.getElementById('separationSampleRate').value = '16000';   // 16kHz - –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ –¥–ª—è –Ω–æ–≤–æ—ó –º–æ–¥–µ–ª—ñ sepformer-whamr16k
      document.getElementById('separationDevice').value = 'auto';
      document.getElementById('separationNumSpeakers').value = '2';
      
      // Quality settings (–æ–ø—Ç–∏–º—ñ–∑–æ–≤–∞–Ω—ñ –¥–ª—è –º—ñ–Ω—ñ–º—ñ–∑–∞—Ü—ñ—ó –∑–∞–ª–∏—à–∫—ñ–≤ —Å–ø—ñ–∫–µ—Ä—ñ–≤)
      document.getElementById('separationSegmentOverlap').value = '0.5';  // –ë—ñ–ª—å—à–∏–π overlap –¥–ª—è –∫—Ä–∞—â–æ–≥–æ –∑—à–∏–≤–∞–Ω–Ω—è
      document.getElementById('separationMinIntersegmentGap').value = '0.1';  // –ë—ñ–ª—å—à–∏–π gap –¥–ª—è –∫—Ä–∞—â–æ–≥–æ —Ä–æ–∑–¥—ñ–ª–µ–Ω–Ω—è
      document.getElementById('separationStrictMode').value = 'true';
      document.getElementById('separationVadThreshold').value = '0.7';
      document.getElementById('separationMaxSpeechDuration').value = '30';  // –ù–µ –æ–±–º–µ–∂—É—î–º–æ, –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ chunk size
      
      // Advanced settings
      document.getElementById('separationBatchSize').value = '4';
      document.getElementById('separationDynamicBatching').value = 'false';
      document.getElementById('separationVadModel').value = 'speechbrain/vad-crdnn-libriparty';
      document.getElementById('separationDiarizationModel').value = 'speechbrain/diarization-mfa';
      
      saveSeparationSettings();
    }
    
    // –ó–∞—Ö–∞—Ä–¥–∫–æ–¥–∂–µ–Ω—ñ –æ–ø—Ç–∏–º–∞–ª—å–Ω—ñ –∑–Ω–∞—á–µ–Ω–Ω—è (–≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—é—Ç—å—Å—è –∫–æ–ª–∏ –∫–∞—Å—Ç–æ–º–Ω—ñ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –≤–∏–º–∫–Ω–µ–Ω—ñ)
    function getHardcodedOptimalSettings() {
      return {
        // Basic settings
        chunkSeconds: 10.0,
        overlapSeconds: 2.0,
        sampleRate: 16000,
        device: 'mps',
        numSpeakers: 2,
        
        // Quality settings (–æ–ø—Ç–∏–º—ñ–∑–æ–≤–∞–Ω—ñ –¥–ª—è —Ä–æ–∑–¥—ñ–ª–µ–Ω–Ω—è –æ–¥–Ω–æ—á–∞—Å–Ω–∏—Ö –≥–æ–ª–æ—Å—ñ–≤)
        segmentOverlap: 0.5,
        minIntersegmentGap: 0.1,
        strictMode: true,
        vadThreshold: 0.7,
        maxSpeechDuration: 30.0,
        
        // Normalization settings (–∞–≥—Ä–µ—Å–∏–≤–Ω–∞ –Ω–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—è –¥–ª—è –≤–∏—Ä—ñ–≤–Ω—é–≤–∞–Ω–Ω—è –≥—É—á–Ω–æ—Å—Ç—ñ)
        normalizationMethod: 'peak',
        normalizationLevel: 0.80,
        
        // Post-processing settings (–¥–ª—è –ø–æ–∫—Ä–∞—â–µ–Ω–Ω—è —Ä–æ–∑–¥—ñ–ª–µ–Ω–Ω—è –æ–¥–Ω–æ—á–∞—Å–Ω–∏—Ö –≥–æ–ª–æ—Å—ñ–≤)
        enableSpectralGating: true,
        spectralGateThreshold: 0.15,
        spectralGateAlpha: 0.4,
        enableSpeakerEnhancement: true,
        speakerEnhancementStrength: 0.4,
        
        // Adaptive processing (–¥–ª—è –∑–∞–ø–æ–±—ñ–≥–∞–Ω–Ω—è —Å–≤—ñ—Ç—á—É –≥–æ–ª–æ—Å—ñ–≤ –ø—Ä–∏ –∑–º—ñ–Ω—ñ –≥—É—á–Ω–æ—Å—Ç—ñ)
        enableAdaptiveVolumeTracking: true,
        adaptiveVolumeAlpha: 0.85,
        enableDynamicSpeakerGating: true,
        dynamicGateMinEnergyRatio: 0.25,
        dynamicGateStrength: 0.5,
        
        // Advanced settings
        batchSize: 4,
        dynamicBatching: false,
        vadModel: 'speechbrain/vad-crdnn-libriparty',
        diarizationModel: 'speechbrain/diarization-mfa'
      };
    }
    
    function getSeparationSettings() {
      const useCustom = document.getElementById('useCustomSettings')?.checked || false;
      
      // –Ø–∫—â–æ –∫–∞—Å—Ç–æ–º–Ω—ñ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –≤–∏–º–∫–Ω–µ–Ω—ñ, –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –∑–∞—Ö–∞—Ä–¥–∫–æ–¥–∂–µ–Ω—ñ –æ–ø—Ç–∏–º–∞–ª—å–Ω—ñ –∑–Ω–∞—á–µ–Ω–Ω—è
      if (!useCustom) {
        return getHardcodedOptimalSettings();
      }
      
      // –Ü–Ω–∞–∫—à–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –∑–Ω–∞—á–µ–Ω–Ω—è –∑ UI
      return {
        // Basic settings
        chunkSeconds: parseFloat(document.getElementById('separationChunkSeconds').value) || 10,
        overlapSeconds: parseFloat(document.getElementById('separationOverlapSeconds')?.value) || 2.0,
        sampleRate: parseInt(document.getElementById('separationSampleRate').value) || 16000,
        device: document.getElementById('separationDevice').value || 'auto',
        numSpeakers: parseInt(document.getElementById('separationNumSpeakers').value) || 2,
        
        // Quality settings (critical for separation quality)
        segmentOverlap: parseFloat(document.getElementById('separationSegmentOverlap').value) || 0.03,
        minIntersegmentGap: parseFloat(document.getElementById('separationMinIntersegmentGap').value) || 0.05,
        strictMode: document.getElementById('separationStrictMode').value === 'true',
        vadThreshold: parseFloat(document.getElementById('separationVadThreshold').value) || 0.7,
        maxSpeechDuration: parseFloat(document.getElementById('separationMaxSpeechDuration').value) || 5,
        
        // Normalization settings
        normalizationMethod: document.getElementById('separationNormalizationMethod').value || 'peak',
        normalizationLevel: parseFloat(document.getElementById('separationNormalizationLevel').value) || 0.80,
        
        // Post-processing settings (—è–∫—â–æ —î –≤ UI, —ñ–Ω–∞–∫—à–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –∑–∞—Ö–∞—Ä–¥–∫–æ–¥–∂–µ–Ω—ñ)
        enableSpectralGating: document.getElementById('separationEnableSpectralGating')?.checked !== false,
        spectralGateThreshold: parseFloat(document.getElementById('separationSpectralGateThreshold')?.value) || 0.15,
        spectralGateAlpha: parseFloat(document.getElementById('separationSpectralGateAlpha')?.value) || 0.4,
        enableSpeakerEnhancement: document.getElementById('separationEnableSpeakerEnhancement')?.checked !== false,
        speakerEnhancementStrength: parseFloat(document.getElementById('separationSpeakerEnhancementStrength')?.value) || 0.4,
        
        // Advanced settings
        batchSize: parseInt(document.getElementById('separationBatchSize').value) || 4,
        dynamicBatching: document.getElementById('separationDynamicBatching').value === 'true',
        vadModel: document.getElementById('separationVadModel').value || 'speechbrain/vad-crdnn-libriparty',
        diarizationModel: document.getElementById('separationDiarizationModel').value || 'speechbrain/diarization-mfa'
      };
    }
    
    function toggleCustomSettings() {
      const useCustom = document.getElementById('useCustomSettings')?.checked || false;
      const settingsInputs = [
        'separationChunkSeconds', 'separationSampleRate', 'separationDevice', 'separationNumSpeakers',
        'separationSegmentOverlap', 'separationMinIntersegmentGap', 'separationStrictMode',
        'separationVadThreshold', 'separationMaxSpeechDuration',
        'separationNormalizationMethod', 'separationNormalizationLevel',
        'separationBatchSize', 'separationDynamicBatching', 'separationVadModel', 'separationDiarizationModel'
      ];
      
      settingsInputs.forEach(id => {
        const el = document.getElementById(id);
        if (el) {
          el.disabled = !useCustom;
          el.style.opacity = useCustom ? '1' : '0.6';
          el.style.cursor = useCustom ? 'default' : 'not-allowed';
        }
      });
      
      // –û–Ω–æ–≤–ª—é—î–º–æ –≤—ñ–¥–æ–±—Ä–∞–∂–µ–Ω–Ω—è —Å—Ç–∞—Ç—É—Å—É
      const statusEl = document.getElementById('customSettingsStatus');
      if (statusEl) {
        if (useCustom) {
          statusEl.textContent = '‚úÖ –ö–∞—Å—Ç–æ–º–Ω—ñ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –∞–∫—Ç–∏–≤–Ω—ñ';
          statusEl.style.color = '#28a745';
        } else {
          statusEl.textContent = 'üîí –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—é—Ç—å—Å—è –æ–ø—Ç–∏–º–∞–ª—å–Ω—ñ –∑–∞—Ö–∞—Ä–¥–∫–æ–¥–∂–µ–Ω—ñ –∑–Ω–∞—á–µ–Ω–Ω—è';
          statusEl.style.color = '#6c757d';
        }
      }
    }
    
    function saveSeparationSettings() {
      try {
        const settings = getSeparationSettings();
        localStorage.setItem('separationDebugSettings', JSON.stringify(settings));
      } catch (e) {
        console.warn('Failed to save separation settings:', e);
      }
    }
    
    function loadSeparationSettings() {
      try {
        const saved = localStorage.getItem('separationDebugSettings');
        if (saved) {
          const settings = JSON.parse(saved);
          if (settings.chunkSeconds) {
            document.getElementById('separationChunkSeconds').value = settings.chunkSeconds;
          }
          if (settings.sampleRate) {
            document.getElementById('separationSampleRate').value = settings.sampleRate;
          }
          if (settings.device) {
            document.getElementById('separationDevice').value = settings.device;
          }
          if (settings.numSpeakers) {
            document.getElementById('separationNumSpeakers').value = settings.numSpeakers;
          }
          if (settings.normalizationMethod) {
            document.getElementById('separationNormalizationMethod').value = settings.normalizationMethod;
          }
          if (settings.normalizationLevel !== undefined) {
            document.getElementById('separationNormalizationLevel').value = settings.normalizationLevel;
          }
          // –û–Ω–æ–≤–ª—é—î–º–æ –≤—ñ–¥–æ–±—Ä–∞–∂–µ–Ω–Ω—è —Å—Ç–∞—Ç—É—Å—É –Ω–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—ó
          updateNormalizationStatus();
        }
      } catch (e) {
        console.warn('Failed to load separation settings:', e);
      }
    }
    
    // Update normalization status display
    function updateNormalizationStatus() {
      const method = document.getElementById('separationNormalizationMethod').value;
      const level = parseFloat(document.getElementById('separationNormalizationLevel').value) || 0.80;
      const methodDisplay = method === 'peak' ? 'Peak' : 'RMS';
      const levelDisplay = Math.round(level * 100);
      
      document.getElementById('normalizationMethodDisplay').textContent = methodDisplay;
      document.getElementById('normalizationLevelDisplay').textContent = levelDisplay;
    }
    
    // Auto-save settings on change
    document.addEventListener('DOMContentLoaded', function() {
      const settingsInputs = [
        'separationChunkSeconds', 'separationSampleRate', 'separationDevice', 'separationNumSpeakers',
        'separationSegmentOverlap', 'separationMinIntersegmentGap', 'separationStrictMode',
        'separationVadThreshold', 'separationMaxSpeechDuration',
        'separationNormalizationMethod', 'separationNormalizationLevel',
        'separationBatchSize', 'separationDynamicBatching', 'separationVadModel', 'separationDiarizationModel'
      ];
      settingsInputs.forEach(id => {
        const el = document.getElementById(id);
        if (el) {
          el.addEventListener('change', function() {
            saveSeparationSettings();
            if (id === 'separationNormalizationMethod' || id === 'separationNormalizationLevel') {
              updateNormalizationStatus();
            }
          });
        }
      });
      
      // Initialize normalization status display
      updateNormalizationStatus();
      
      // Initialize custom settings toggle
      if (document.getElementById('useCustomSettings')) {
        toggleCustomSettings();
      }
      
      // Load saved settings when modal opens
      const modal = document.getElementById('separationDebugModal');
      if (modal) {
        const observer = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
            if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
              const modal = document.getElementById('separationDebugModal');
              if (modal && modal.style.display === 'flex') {
                loadSeparationSettings();
              }
            }
          });
        });
        observer.observe(modal, { attributes: true });
      }
    });
    
    // ============================================================================
    // Parameter Optimization Functions
    // ============================================================================
    
    let currentOptimizationSession = null;
    
    function toggleOptimizationPanel() {
      const panel = document.getElementById('optimizationPanel');
      const toggle = document.getElementById('optimizationToggle');
      if (panel.style.display === 'none') {
        panel.style.display = 'block';
        toggle.textContent = '‚ñ≤';
      } else {
        panel.style.display = 'none';
        toggle.textContent = '‚ñº';
      }
    }
    
    async function startOptimizationSession() {
      try {
        const fileInput = document.getElementById('separationDebugAudioFile');
        const audioFile = fileInput?.files[0]?.name || null;
        
        const response = await fetch('/api/optimization/start', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ audioFile })
        });
        
        const data = await response.json();
        
        if (data.success) {
          currentOptimizationSession = data.sessionId;
          document.getElementById('optimizationSessionInfo').style.display = 'block';
          document.getElementById('optimizationIteration').textContent = `–Ü—Ç–µ—Ä–∞—Ü—ñ—è: ${data.iteration}`;
          updateOptimizationStats();
          displayOptimizationConfig(data.config);
          showMessage('‚úÖ –°–µ—Å—ñ—è –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—ó —Ä–æ–∑–ø–æ—á–∞—Ç–∞!', 'success');
        } else {
          showMessage('‚ùå –ü–æ–º–∏–ª–∫–∞: ' + (data.error || data.message), 'error');
        }
      } catch (error) {
        console.error('Error starting optimization session:', error);
        showMessage('‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫—É —Å–µ—Å—ñ—ó: ' + error.message, 'error');
      }
    }
    
    async function getCurrentOptimizationConfig() {
      try {
        const response = await fetch('/api/optimization/current');
        const data = await response.json();
        
        if (data.success) {
          currentOptimizationSession = data.sessionId;
          document.getElementById('optimizationSessionInfo').style.display = 'block';
          document.getElementById('optimizationIteration').textContent = `–Ü—Ç–µ—Ä–∞—Ü—ñ—è: ${data.iteration}`;
          displayOptimizationConfig(data.config, data.generationMethod);
          showMessage('‚úÖ –ö–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—è –æ—Ç—Ä–∏–º–∞–Ω–∞!', 'success');
        } else if (data.action === 'start') {
          showMessage('‚ÑπÔ∏è –ü–æ—á–∞—Ç—ñ—Ç—å –Ω–æ–≤—É —Å–µ—Å—ñ—é –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—ó', 'info');
        } else {
          showMessage('‚ùå –ü–æ–º–∏–ª–∫–∞: ' + (data.error || data.message), 'error');
        }
      } catch (error) {
        console.error('Error getting current config:', error);
        showMessage('‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ—Ç—Ä–∏–º–∞–Ω–Ω—ñ –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—ó: ' + error.message, 'error');
      }
    }
    
    let previousOptimizationConfig = null;
    
    function displayOptimizationConfig(config, generationMethod = null, previousConfig = null) {
      const configEl = document.getElementById('optimizationCurrentConfig');
      const jsonEl = document.getElementById('optimizationConfigJson');
      const methodEl = document.getElementById('optimizationGenerationMethod');
      const changesEl = document.getElementById('optimizationConfigChanges');
      
      configEl.style.display = 'block';
      jsonEl.textContent = JSON.stringify(config, null, 2);
      
      // –ü–æ–∫–∞–∑—É—î–º–æ –º–µ—Ç–æ–¥ –≥–µ–Ω–µ—Ä–∞—Ü—ñ—ó
      if (generationMethod) {
        methodEl.style.display = 'inline-block';
        if (generationMethod === 'llm') {
          methodEl.textContent = 'ü§ñ –ó–≥–µ–Ω–µ—Ä–æ–≤–∞–Ω–æ LLM';
          methodEl.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
          methodEl.style.color = 'white';
          configEl.style.border = '2px solid #667eea';
          configEl.style.boxShadow = '0 0 10px rgba(102, 126, 234, 0.3)';
          
          // –ê–Ω—ñ–º–∞—Ü—ñ—è –ø–æ—è–≤–∏
          configEl.style.animation = 'fadeInScale 0.5s ease-out';
        } else if (generationMethod === 'hill-climbing') {
          methodEl.textContent = 'üìä Hill Climbing';
          methodEl.style.background = '#FF9800';
          methodEl.style.color = 'white';
          configEl.style.border = '2px solid #FF9800';
          configEl.style.boxShadow = '0 0 10px rgba(255, 152, 0, 0.3)';
        } else {
          methodEl.textContent = 'üé≤ –ü–æ—á–∞—Ç–∫–æ–≤–∞';
          methodEl.style.background = '#9E9E9E';
          methodEl.style.color = 'white';
          configEl.style.border = '1px solid #ddd';
          configEl.style.boxShadow = 'none';
        }
      } else {
        methodEl.style.display = 'none';
        configEl.style.border = '1px solid #ddd';
        configEl.style.boxShadow = 'none';
      }
      
      // –ü–æ–∫–∞–∑—É—î–º–æ –∑–º—ñ–Ω–∏ –ø–æ—Ä—ñ–≤–Ω—è–Ω–æ –∑ –ø–æ–ø–µ—Ä–µ–¥–Ω—å–æ—é –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—î—é
      if (previousConfig && previousOptimizationConfig) {
        const changes = [];
        for (const key in config) {
          if (previousOptimizationConfig[key] !== undefined && 
              previousOptimizationConfig[key] !== config[key] &&
              key !== 'device' && key !== 'sampleRate') { // –ü—Ä–æ–ø—É—Å–∫–∞—î–º–æ —Ñ—ñ–∫—Å–æ–≤–∞–Ω—ñ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏
            const oldVal = previousOptimizationConfig[key];
            const newVal = config[key];
            const change = newVal > oldVal ? '‚Üë' : '‚Üì';
            changes.push(`<strong>${key}:</strong> ${oldVal} ${change} ${newVal}`);
          }
        }
        
        if (changes.length > 0) {
          changesEl.style.display = 'block';
          changesEl.innerHTML = '<strong>üîÑ –ó–º—ñ–Ω–∏:</strong> ' + changes.join(' | ');
        } else {
          changesEl.style.display = 'none';
        }
      } else {
        changesEl.style.display = 'none';
      }
      
      // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –ø–æ—Ç–æ—á–Ω—É –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—é –¥–ª—è –Ω–∞—Å—Ç—É–ø–Ω–æ–≥–æ –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è
      previousOptimizationConfig = { ...config };
    }
    
    function applyOptimizationConfig() {
      const jsonEl = document.getElementById('optimizationConfigJson');
      try {
        const config = JSON.parse(jsonEl.textContent);
        
        // –ó–∞—Å—Ç–æ—Å–æ–≤—É—î–º–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ –¥–æ UI
        if (config.chunkSeconds !== undefined) {
          document.getElementById('separationChunkSeconds').value = config.chunkSeconds;
        }
        if (config.sampleRate !== undefined) {
          document.getElementById('separationSampleRate').value = config.sampleRate;
        }
        if (config.device !== undefined) {
          document.getElementById('separationDevice').value = config.device;
        }
        if (config.numSpeakers !== undefined) {
          document.getElementById('separationNumSpeakers').value = config.numSpeakers;
        }
        if (config.segmentOverlap !== undefined) {
          document.getElementById('separationSegmentOverlap').value = config.segmentOverlap;
        }
        if (config.minIntersegmentGap !== undefined) {
          document.getElementById('separationMinIntersegmentGap').value = config.minIntersegmentGap;
        }
        if (config.strictMode !== undefined) {
          document.getElementById('separationStrictMode').value = config.strictMode ? 'true' : 'false';
        }
        if (config.vadThreshold !== undefined) {
          document.getElementById('separationVadThreshold').value = config.vadThreshold;
        }
        if (config.maxSpeechDuration !== undefined) {
          document.getElementById('separationMaxSpeechDuration').value = config.maxSpeechDuration;
        }
        if (config.batchSize !== undefined) {
          document.getElementById('separationBatchSize').value = config.batchSize;
        }
        if (config.dynamicBatching !== undefined) {
          document.getElementById('separationDynamicBatching').value = config.dynamicBatching ? 'true' : 'false';
        }
        if (config.normalizationMethod !== undefined) {
          document.getElementById('separationNormalizationMethod').value = config.normalizationMethod;
        }
        if (config.normalizationLevel !== undefined) {
          document.getElementById('separationNormalizationLevel').value = config.normalizationLevel;
        }
        
        updateNormalizationStatus();
        saveSeparationSettings();
        showMessage('‚úÖ –ü–∞—Ä–∞–º–µ—Ç—Ä–∏ –∑–∞—Å—Ç–æ—Å–æ–≤–∞–Ω–æ! –¢–µ–ø–µ—Ä –º–æ–∂–Ω–∞ –∑–∞–ø—É—Å—Ç–∏—Ç–∏ —Ç–µ—Å—Ç.', 'success');
      } catch (error) {
        console.error('Error applying config:', error);
        showMessage('‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –∑–∞—Å—Ç–æ—Å—É–≤–∞–Ω–Ω—ñ –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—ó: ' + error.message, 'error');
      }
    }
    
    async function sendOptimizationFeedback(feedback) {
      if (!currentOptimizationSession) {
        showMessage('‚ÑπÔ∏è –°–ø–æ—á–∞—Ç–∫—É –ø–æ—á–∞—Ç—ñ—Ç—å —Å–µ—Å—ñ—é –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—ó', 'info');
        return;
      }
      
      // –ü–æ–∫–∞–∑—É—î–º–æ –º–æ–¥–∞–ª—å–Ω–µ –≤—ñ–∫–Ω–æ –¥–ª—è –Ω–æ—Ç–∞—Ç–æ–∫
      const notes = await showNotesModal(feedback);
      
      try {
        const response = await fetch('/api/optimization/feedback', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ feedback, notes: notes || '' })
        });
        
        const data = await response.json();
        
        if (data.success) {
          document.getElementById('optimizationIteration').textContent = `–Ü—Ç–µ—Ä–∞—Ü—ñ—è: ${data.iteration}`;
          updateOptimizationStats();
          displayOptimizationConfig(data.nextConfig, data.generationMethod, data.previousConfig);
          const methodText = data.generationMethod === 'llm' ? ' (–∑–≥–µ–Ω–µ—Ä–æ–≤–∞–Ω–æ LLM ü§ñ)' : '';
          let messageType = 'info';
          if (feedback === 'better') {
            messageType = 'success';
          } else if (feedback === 'worse') {
            messageType = 'warning';
          } else if (feedback === 'same') {
            messageType = 'info';
          }
          showMessage(data.message + methodText, messageType);
          
          // –û–Ω–æ–≤–ª—é—î–º–æ —ñ—Å—Ç–æ—Ä—ñ—é
          if (data.recentHistory && data.recentHistory.length > 0) {
            displayOptimizationHistory(data.recentHistory);
          }
        } else {
          showMessage('‚ùå –ü–æ–º–∏–ª–∫–∞: ' + (data.error || data.message), 'error');
        }
      } catch (error) {
        console.error('Error sending feedback:', error);
        showMessage('‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –≤—ñ–¥–ø—Ä–∞–≤—Ü—ñ —Ñ—ñ–¥–±–µ–∫—É: ' + error.message, 'error');
      }
    }
    
    async function updateOptimizationStats() {
      try {
        const response = await fetch('/api/optimization/stats');
        const data = await response.json();
        
        if (data.success) {
          document.getElementById('optimizationBetterCount').textContent = data.betterCount || 0;
          document.getElementById('optimizationWorseCount').textContent = data.worseCount || 0;
          document.getElementById('optimizationSameCount').textContent = data.sameCount || 0;
        }
      } catch (error) {
        console.error('Error updating stats:', error);
      }
    }
    
    async function displayOptimizationHistory(history) {
      const historyEl = document.getElementById('optimizationHistory');
      const listEl = document.getElementById('optimizationHistoryList');
      
      if (!history || history.length === 0) {
        historyEl.style.display = 'none';
        return;
      }
      
      historyEl.style.display = 'block';
      listEl.innerHTML = history.slice().reverse().map((test, idx) => {
        const feedbackIcon = test.feedback === 'better' ? '‚úÖ' : '‚ùå';
        return `
          <div style="margin-bottom: 8px; padding: 8px; background: #f5f5f5; border-radius: 4px; border-left: 3px solid ${test.feedback === 'better' ? '#4caf50' : '#f44336'};">
            <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
              <strong>${feedbackIcon} –Ü—Ç–µ—Ä–∞—Ü—ñ—è ${test.iteration}</strong>
              <span style="font-size: 10px; color: #666;">${new Date(test.timestamp).toLocaleTimeString()}</span>
            </div>
            ${test.notes ? `<div style="font-size: 10px; color: #666; margin-bottom: 4px;">${test.notes}</div>` : ''}
            <details style="font-size: 10px;">
              <summary style="cursor: pointer; color: #2196F3;">–ü–æ–∫–∞–∑–∞—Ç–∏ –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—é</summary>
              <pre style="margin-top: 4px; padding: 4px; background: #fff; border-radius: 2px; overflow-x: auto;">${JSON.stringify(test.config, null, 2)}</pre>
            </details>
          </div>
        `;
      }).join('');
    }
    
    async function exportBestConfig() {
      try {
        const response = await fetch('/api/optimization/export');
        const data = await response.json();
        
        if (data.success && data.config) {
          const configJson = JSON.stringify(data.config, null, 2);
          const blob = new Blob([configJson], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `best_separation_config_${Date.now()}.json`;
          a.click();
          URL.revokeObjectURL(url);
          showMessage('‚úÖ –ù–∞–π–∫—Ä–∞—â–∞ –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—è –µ–∫—Å–ø–æ—Ä—Ç–æ–≤–∞–Ω–∞!', 'success');
        } else {
          showMessage('‚ÑπÔ∏è ' + (data.message || '–ù–∞–π–∫—Ä–∞—â–∞ –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—è —â–µ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∞'), 'info');
        }
      } catch (error) {
        console.error('Error exporting config:', error);
        showMessage('‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –µ–∫—Å–ø–æ—Ä—Ç—ñ: ' + error.message, 'error');
      }
    }
    
    async function resetOptimizationSession() {
      if (!confirm('–í–∏ –≤–ø–µ–≤–Ω–µ–Ω—ñ, —â–æ —Ö–æ—á–µ—Ç–µ —Å–∫–∏–Ω—É—Ç–∏ –ø–æ—Ç–æ—á–Ω—É —Å–µ—Å—ñ—é –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—ó?')) {
        return;
      }
      
      try {
        const response = await fetch('/api/optimization/reset', {
          method: 'POST'
        });
        
        const data = await response.json();
        
        if (data.success) {
          currentOptimizationSession = null;
          document.getElementById('optimizationSessionInfo').style.display = 'none';
          document.getElementById('optimizationCurrentConfig').style.display = 'none';
          document.getElementById('optimizationHistory').style.display = 'none';
          showMessage('‚úÖ –°–µ—Å—ñ—è —Å–∫–∏–Ω—É—Ç–∞', 'success');
        } else {
          showMessage('‚ùå –ü–æ–º–∏–ª–∫–∞: ' + (data.error || data.message), 'error');
        }
      } catch (error) {
        console.error('Error resetting session:', error);
        showMessage('‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ —Å–∫–∏–¥–∞–Ω–Ω—ñ: ' + error.message, 'error');
      }
    }
    
    // Notes Modal Functions
    let notesModalResolve = null;
    let currentFeedbackType = null;
    
    function showNotesModal(feedbackType) {
      return new Promise((resolve) => {
        currentFeedbackType = feedbackType;
        notesModalResolve = resolve;
        document.getElementById('optimizationNotesModal').style.display = 'flex';
        document.getElementById('optimizationNotesText').value = '';
        document.getElementById('optimizationNotesText').focus();
      });
    }
    
    function closeNotesModal() {
      document.getElementById('optimizationNotesModal').style.display = 'none';
      if (notesModalResolve) {
        notesModalResolve('');
        notesModalResolve = null;
      }
    }
    
    function submitNotesModal() {
      const notes = document.getElementById('optimizationNotesText').value.trim();
      document.getElementById('optimizationNotesModal').style.display = 'none';
      if (notesModalResolve) {
        notesModalResolve(notes);
        notesModalResolve = null;
      }
    }
    
    // Close modal on Escape key
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape') {
        const modal = document.getElementById('optimizationNotesModal');
        if (modal && modal.style.display === 'flex') {
          closeNotesModal();
        }
      }
    });
    
    function showMessage(message, type = 'info') {
      // –ü—Ä–æ—Å—Ç–∏–π —Å–ø–æ—Å—ñ–± –ø–æ–∫–∞–∑–∞—Ç–∏ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è (–º–æ–∂–Ω–∞ –∑–∞–º—ñ–Ω–∏—Ç–∏ –Ω–∞ –±—ñ–ª—å—à —Å–∫–ª–∞–¥–Ω–∏–π)
      const statusEl = document.getElementById('separationDebugStatus');
      if (statusEl) {
        const color = type === 'success' ? '#4caf50' : type === 'error' ? '#f44336' : '#2196F3';
        statusEl.innerHTML = `<div style="color: ${color}; font-weight: 600;">${message}</div>`;
      }
      console.log(`[${type.toUpperCase()}] ${message}`);
    }
    
    function closeSeparationDebugModal() {
      document.getElementById('separationDebugModal').style.display = 'none';
    }
    
    function addLog(message) {
      const logEl = document.getElementById('separationDebugLog');
      const timestamp = new Date().toLocaleTimeString();
      logEl.value += `[${timestamp}] ${message}\n`;
      logEl.scrollTop = logEl.scrollHeight;
    }
    
    async function runSeparationDebug() {
      const btn = document.getElementById('runSeparationDebugBtn');
      const statusEl = document.getElementById('separationDebugStatus');
      const fileInput = document.getElementById('separationDebugAudioFile');
      const originalSection = document.getElementById('separationDebugOriginalSection');
      const tracksSection = document.getElementById('separationDebugTracksSection');
      const originalAudioContainer = document.getElementById('separationDebugOriginalAudio');
      const originalInfo = document.getElementById('separationDebugOriginalInfo');
      const tracksContainer = document.getElementById('separationDebugTracksContainer');
      const originalText = btn.innerHTML;
      const startTime = Date.now();
      
      // Check if file is selected
      if (!fileInput || !fileInput.files || fileInput.files.length === 0) {
        alert('‚ö†Ô∏è –ë—É–¥—å –ª–∞—Å–∫–∞, –≤–∏–±–µ—Ä—ñ—Ç—å –∞—É–¥—ñ–æ —Ñ–∞–π–ª —Å–ø–æ—á–∞—Ç–∫—É.');
        return;
      }
      
      const audioFile = fileInput.files[0];
      
      // 1. –õ–æ–≥—É–≤–∞–Ω–Ω—è –ø—Ä–∏ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—ñ —Ñ–∞–π–ª—É
      const fileExtension = audioFile.name.split('.').pop()?.toUpperCase() || 'UNKNOWN';
      const fileSizeMB = (audioFile.size / (1024 * 1024)).toFixed(2);
      const fileSizeBytes = audioFile.size;
      const fileType = audioFile.type || 'audio/unknown';
      
      addLog('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
      addLog('üöÄ –ü–û–ß–ê–¢–û–ö –ü–†–û–¶–ï–°–£ –†–û–ó–î–Ü–õ–ï–ù–ù–Ø –¢–†–ï–ö–Ü–í');
      addLog('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
      addLog('');
      addLog('üìÅ –ï–¢–ê–ü 1: –ó–ê–í–ê–ù–¢–ê–ñ–ï–ù–ù–Ø –§–ê–ô–õ–£');
      addLog(`   –ù–∞–∑–≤–∞ —Ñ–∞–π–ª—É: ${audioFile.name}`);
      addLog(`   –†–æ–∑–º—ñ—Ä: ${fileSizeMB} MB (${fileSizeBytes} –±–∞–π—Ç)`);
      addLog(`   –§–æ—Ä–º–∞—Ç: ${fileExtension}`);
      addLog(`   MIME —Ç–∏–ø: ${fileType}`);
      addLog(`   –û—Å—Ç–∞–Ω–Ω—è –∑–º—ñ–Ω–∞: ${new Date(audioFile.lastModified).toLocaleString()}`);
      addLog('');
      
      // Update UI
      btn.disabled = true;
      btn.style.opacity = '0.6';
      btn.style.cursor = 'not-allowed';
      btn.innerHTML = '‚è≥ –û–±—Ä–æ–±–∫–∞...';
      statusEl.textContent = '–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —Ñ–∞–π–ª—É –Ω–∞ —Å–µ—Ä–≤–µ—Ä...';
      statusEl.style.color = '#333';
      
      // Hide previous results
      originalSection.style.display = 'none';
      tracksSection.style.display = 'none';
      
      try {
        // Upload file to server
        const formData = new FormData();
        formData.append('audio', audioFile);
        
        addLog('üì§ –í—ñ–¥–ø—Ä–∞–≤–∫–∞ —Ñ–∞–π–ª—É –Ω–∞ —Å–µ—Ä–≤–µ—Ä...');
        const uploadStartTime = Date.now();
        statusEl.textContent = '–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —Ñ–∞–π–ª—É...';
        
        const uploadResponse = await fetch('/api/upload-audio', {
          method: 'POST',
          body: formData
        });
        
        const uploadTime = ((Date.now() - uploadStartTime) / 1000).toFixed(2);
        
        if (!uploadResponse.ok) {
          const errorText = await uploadResponse.text();
          addLog(`‚ùå –ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è: ${uploadResponse.status} ${uploadResponse.statusText}`);
          addLog(`   –î–µ—Ç–∞–ª—ñ: ${errorText}`);
          throw new Error(`Upload failed: ${uploadResponse.statusText}`);
        }
        
        const uploadResult = await uploadResponse.json();
        const uploadedFilePath = uploadResult.filePath || uploadResult.path;
        
        if (!uploadedFilePath) {
          throw new Error('Server did not return file path');
        }
        
        addLog(`‚úÖ –§–∞–π–ª —É—Å–ø—ñ—à–Ω–æ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ –∑–∞ ${uploadTime} —Å–µ–∫`);
        addLog(`   –®–ª—è—Ö –Ω–∞ —Å–µ—Ä–≤–µ—Ä—ñ: ${uploadedFilePath}`);
        addLog(`   –†–æ–∑–º—ñ—Ä –Ω–∞ —Å–µ—Ä–≤–µ—Ä—ñ: ${uploadResult.size ? (uploadResult.size / (1024 * 1024)).toFixed(2) + ' MB' : 'N/A'}`);
        addLog('');
        
        // 2. –ü–µ—Ä–µ–¥ –ø–æ—á–∞—Ç–∫–æ–º —Ä–æ–∑–¥—ñ–ª–µ–Ω–Ω—è
        addLog('üîÄ –ï–¢–ê–ü 2: –ü–Ü–î–ì–û–¢–û–í–ö–ê –î–û –†–û–ó–î–Ü–õ–ï–ù–ù–Ø');
        addLog(`   –°—Ç–∞—Ä—Ç–æ–≤–∞ —Ç–æ—á–∫–∞: ${new Date().toISOString()}`);
        addLog(`   –®–ª—è—Ö –¥–æ –∞—É–¥—ñ–æ: ${uploadedFilePath}`);
        // Get settings FIRST before using them
        const settings = getSeparationSettings();
        
        addLog('   –ü–∞—Ä–∞–º–µ—Ç—Ä–∏ –∞–ª–≥–æ—Ä–∏—Ç–º—É:');
        addLog('     - –ú–æ–¥–µ–ª—å: SpeechBrain SepFormer WHAMR16k (16kHz)');
        addLog('     - –û—á—ñ–∫—É–≤–∞–Ω–∞ –∫—ñ–ª—å–∫—ñ—Å—Ç—å —Å–ø—ñ–∫–µ—Ä—ñ–≤: 2 (–∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º)');
        addLog(`     - Sample rate: ${settings.sampleRate || 16000} Hz`);
        addLog('     - Device: –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–∏–π –≤–∏–±—ñ—Ä (CPU/MPS/CUDA)');
        addLog('');
        statusEl.textContent = '–ó–∞–ø—É—Å–∫ —Ä–æ–∑–¥—ñ–ª–µ–Ω–Ω—è —á–µ—Ä–µ–∑ SpeechBrain...';
        addLog('');
        addLog('‚öôÔ∏è  –ù–ê–õ–ê–®–¢–£–í–ê–ù–ù–Ø –†–û–ó–î–Ü–õ–ï–ù–ù–Ø:');
        addLog('   –ë–∞–∑–æ–≤—ñ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏:');
        addLog(`     - –†–æ–∑–º—ñ—Ä —Å–µ–≥–º–µ–Ω—Ç–∞: ${settings.chunkSeconds} —Å–µ–∫`);
        addLog(`     - Sample rate: ${settings.sampleRate} Hz`);
        addLog(`     - –ü—Ä–∏—Å—Ç—Ä—ñ–π: ${settings.device}`);
        addLog(`     - –û—á—ñ–∫—É–≤–∞–Ω–∞ –∫—ñ–ª—å–∫—ñ—Å—Ç—å —Å–ø—ñ–∫–µ—Ä—ñ–≤: ${settings.numSpeakers}`);
        addLog('   üéØ –ö—Ä–∏—Ç–∏—á–Ω—ñ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ —è–∫–æ—Å—Ç—ñ:');
        addLog(`     - Segment Overlap: ${settings.segmentOverlap} —Å–µ–∫ (–≤–ø–ª–∏–≤–∞—î –Ω–∞ –∑–∞–ª–∏—à–∫–∏ —Å–ø—ñ–∫–µ—Ä—ñ–≤)`);
        addLog(`     - Min Intersegment Gap: ${settings.minIntersegmentGap} —Å–µ–∫ (–≤–ø–ª–∏–≤–∞—î –Ω–∞ "—Å–ª–∏–ø–∞–Ω–Ω—è" –≥–æ–ª–æ—Å—ñ–≤)`);
        addLog(`     - Strict Mode: ${settings.strictMode} (–∫—Ä–∏—Ç–∏—á–Ω–æ –¥–ª—è —è–∫–æ—Å—Ç—ñ!)`);
        addLog(`     - VAD Threshold: ${settings.vadThreshold} (—á—É—Ç–ª–∏–≤—ñ—Å—Ç—å –¥–æ –≥–æ–ª–æ—Å—É)`);
        addLog(`     - Max Speech Duration: ${settings.maxSpeechDuration} —Å–µ–∫ (–º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞ —Ç—Ä–∏–≤–∞–ª—ñ—Å—Ç—å —Å–µ–≥–º–µ–Ω—Ç—É)`);
        addLog('   –î–æ–¥–∞—Ç–∫–æ–≤—ñ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏:');
        addLog(`     - Batch Size: ${settings.batchSize}`);
        addLog(`     - Dynamic Batching: ${settings.dynamicBatching}`);
        addLog(`     - VAD Model: ${settings.vadModel}`);
        addLog(`     - Diarization Model: ${settings.diarizationModel}`);
        addLog('');
        
        // Call separation endpoint
        addLog('üì° –í–∏–∫–ª–∏–∫ API —Ä–æ–∑–¥—ñ–ª–µ–Ω–Ω—è...');
        const separationStartTime = Date.now();
        
        const separationResponse = await fetch('/api/debug-separation', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            audioPath: uploadedFilePath,
            settings: settings
          })
        });
        
        if (!separationResponse.ok) {
          const errorText = await separationResponse.text();
          addLog(`‚ùå –ü–æ–º–∏–ª–∫–∞ API —Ä–æ–∑–¥—ñ–ª–µ–Ω–Ω—è: ${separationResponse.status} ${separationResponse.statusText}`);
          addLog(`   –î–µ—Ç–∞–ª—ñ: ${errorText}`);
          throw new Error(`Separation failed: ${errorText}`);
        }
        
        const separationResult = await separationResponse.json();
        const separationTime = ((Date.now() - separationStartTime) / 1000).toFixed(2);
        
        // –î–æ–¥–∞—î–º–æ –ª–æ–≥–∏ –∑ —Å–µ—Ä–≤–µ—Ä–∞, —è–∫—â–æ –≤–æ–Ω–∏ —î
        if (separationResult.logs && Array.isArray(separationResult.logs)) {
          addLog('');
          addLog('üìã –õ–û–ì–ò –ó –°–ï–†–í–ï–†–ê:');
          separationResult.logs.forEach(logEntry => {
            const level = logEntry.level || 'info';
            const prefix = level === 'error' ? '‚ùå' : level === 'warning' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è';
            addLog(`${prefix} ${logEntry.message}`);
          });
          addLog('');
        }
        
        // 4. –ü—ñ—Å–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è —Ä–æ–∑–¥—ñ–ª–µ–Ω–Ω—è
        addLog('');
        addLog('‚úÖ –ï–¢–ê–ü 3: –†–û–ó–î–Ü–õ–ï–ù–ù–Ø –ó–ê–í–ï–†–®–ï–ù–û');
        addLog(`   –ß–∞—Å –æ–±—Ä–æ–±–∫–∏: ${separationTime} —Å–µ–∫`);
        if (separationResult.timing) {
          addLog(`   –ß–∞—Å —Ä–æ–∑–¥—ñ–ª–µ–Ω–Ω—è (—Å–µ—Ä–≤–µ—Ä): ${separationResult.timing.separation} —Å–µ–∫`);
          if (separationResult.timing.save) {
            addLog(`   –ß–∞—Å –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è (—Å–µ—Ä–≤–µ—Ä): ${separationResult.timing.save} —Å–µ–∫`);
          }
        }
        addLog(`   –ö—ñ–ª—å–∫—ñ—Å—Ç—å –æ—Ç—Ä–∏–º–∞–Ω–∏—Ö —Ñ—Ä–∞–≥–º–µ–Ω—Ç—ñ–≤: ${separationResult.speakers?.length || 0}`);
        addLog(`   –°—Ç–∞—Ç—É—Å: ${separationResult.success ? '–£—Å–ø—ñ—à–Ω–æ' : '–ü–æ–º–∏–ª–∫–∞'}`);
        addLog('');
        
        if (separationResult.speakers && separationResult.speakers.length > 0) {
          addLog('üìã –°–ü–ò–°–û–ö –†–û–ó–î–Ü–õ–ï–ù–ò–• –§–†–ê–ì–ú–ï–ù–¢–Ü–í:');
          separationResult.speakers.forEach((speaker, index) => {
            addLog(`   ${index + 1}. ${speaker.name || `SPEAKER_${index.toString().padStart(2, '0')}`}`);
            if (speaker.timeline) {
              addLog(`      –¢—Ä–∏–≤–∞–ª—ñ—Å—Ç—å: ${speaker.timeline.duration || 'N/A'} —Å–µ–∫`);
              addLog(`      –î—ñ–∞–ø–∞–∑–æ–Ω: ${speaker.timeline.start || 0} - ${speaker.timeline.end || 'N/A'} —Å–µ–∫`);
            }
            if (speaker.local_path) {
              addLog(`      –®–ª—è—Ö: ${speaker.local_path}`);
            }
          });
          addLog('');
        }
        
        statusEl.textContent = `‚úÖ –†–æ–∑–¥—ñ–ª–µ–Ω–Ω—è –∑–∞–≤–µ—Ä—à–µ–Ω–æ. –ó–Ω–∞–π–¥–µ–Ω–æ ${separationResult.speakers?.length || 0} —Å–ø—ñ–∫–µ—Ä—ñ–≤ –∑–∞ ${separationTime} —Å–µ–∫`;
        statusEl.style.color = '#27ae60';
        
        // Display original audio
        const originalFileName = uploadedFilePath.split('/').pop() || uploadedFilePath;
        const originalAudioUrl = `/uploads/${encodeURIComponent(originalFileName)}`;
        originalAudioContainer.innerHTML = `
          <audio controls preload="metadata" style="width: 100%;">
            <source src="${originalAudioUrl}" type="audio/wav">
            –í–∞—à –±—Ä–∞—É–∑–µ—Ä –Ω–µ –ø—ñ–¥—Ç—Ä–∏–º—É—î –∞—É–¥—ñ–æ –µ–ª–µ–º–µ–Ω—Ç.
          </audio>
        `;
        originalInfo.textContent = `–§–∞–π–ª: ${audioFile.name} | –†–æ–∑–º—ñ—Ä: ${fileSizeMB} MB | –§–æ—Ä–º–∞—Ç: ${fileExtension}`;
        originalSection.style.display = 'block';
        addLog('üéµ –û—Ä–∏–≥—ñ–Ω–∞–ª—å–Ω–∞ –¥–æ—Ä—ñ–∂–∫–∞ –≤—ñ–¥–æ–±—Ä–∞–∂–µ–Ω–∞');
        addLog('');
        
        // 5. –ü—Ä–∏ –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—ñ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤
        addLog('üíæ –ï–¢–ê–ü 4: –ó–ë–ï–†–ï–ñ–ï–ù–ù–Ø –†–ï–ó–£–õ–¨–¢–ê–¢–Ü–í');
        
        // Display separated tracks
        if (separationResult.speakers && separationResult.speakers.length > 0) {
          tracksContainer.innerHTML = '';
          
          separationResult.speakers.forEach((speaker, index) => {
            // Try different URL sources
            let speakerUrl = speaker.url || speaker.downloadUrl;
            
            // If URL is a full URL (http/https), use it directly
            // If it's a relative path starting with /uploads/, use it directly
            // Otherwise, try to construct from local_path
            if (!speakerUrl && speaker.local_path) {
              const fileName = speaker.local_path.split('/').pop() || speaker.local_path.split('\\').pop();
              // Use /uploads/ directly instead of /api/speechbrain-stems/
              speakerUrl = `/uploads/${encodeURIComponent(fileName)}`;
            }
            
            // Fallback to constructing from speaker name
            if (!speakerUrl) {
              const speakerName = speaker.name || `SPEAKER_${index.toString().padStart(2, '0')}`;
              const fileName = `${speakerName}.wav`;
              // Use /uploads/ directly
              speakerUrl = `/uploads/${encodeURIComponent(fileName)}`;
            }
            
            // If URL is a full URL, extract filename and use relative path instead
            // This helps when localtunnel URL doesn't work reliably
            if (speakerUrl && speakerUrl.startsWith('http')) {
              // Extract filename from URL
              const urlParts = speakerUrl.split('/');
              const extractedFileName = urlParts[urlParts.length - 1];
              // Use relative path for better compatibility
              const relativeUrl = `/uploads/${encodeURIComponent(extractedFileName)}`;
              console.log(`[DEBUG] Speaker ${index + 1}: Converting full URL to relative: ${speakerUrl} -> ${relativeUrl}`);
              speakerUrl = relativeUrl; // Use relative URL instead of full URL
            }
            
            const trackDiv = document.createElement('div');
            trackDiv.style.cssText = 'padding: 15px; background: #fff; border-radius: 6px; border: 2px solid #27ae60;';
            
            // Extract filename for fallback URL (in case primary URL fails)
            let fallbackUrl = speakerUrl;
            if (speaker.local_path) {
              // Use filename from local_path as most reliable fallback
              const fileName = speaker.local_path.split('/').pop() || speaker.local_path.split('\\').pop();
              fallbackUrl = `/uploads/${encodeURIComponent(fileName)}`;
            } else if (speakerUrl && speakerUrl.includes('/')) {
              // Extract filename from current URL
              const urlParts = speakerUrl.split('/');
              const fileName = urlParts[urlParts.length - 1];
              fallbackUrl = `/uploads/${encodeURIComponent(fileName)}`;
            }
            
            trackDiv.innerHTML = `
              <h4 style="margin-top: 0; margin-bottom: 10px; color: #27ae60; font-size: 16px;">${speaker.name || `SPEAKER_${index.toString().padStart(2, '0')}`}</h4>
              <audio controls preload="metadata" style="width: 100%; margin-bottom: 10px;" onerror="this.onerror=null; this.src='${fallbackUrl}';">
                <source src="${speakerUrl || fallbackUrl}" type="audio/wav">
                <source src="${fallbackUrl}" type="audio/wav">
                –í–∞—à –±—Ä–∞—É–∑–µ—Ä –Ω–µ –ø—ñ–¥—Ç—Ä–∏–º—É—î –∞—É–¥—ñ–æ –µ–ª–µ–º–µ–Ω—Ç.
              </audio>
              <div style="font-size: 12px; color: #666; margin-top: 5px;">
                ${speaker.timeline ? `–¢—Ä–∏–≤–∞–ª—ñ—Å—Ç—å: ${speaker.timeline.duration || 'N/A'} —Å–µ–∫` : ''}
                ${speakerUrl ? `<br>URL: ${speakerUrl}` : ''}
                ${fallbackUrl && fallbackUrl !== speakerUrl ? `<br>Fallback URL: ${fallbackUrl}` : ''}
                ${speaker.local_path ? `<br>–®–ª—è—Ö: ${speaker.local_path}` : ''}
              </div>
            `;
            tracksContainer.appendChild(trackDiv);
            
            // Log file save status
            const fileStatus = speakerUrl ? '‚úÖ –î–æ—Å—Ç—É–ø–Ω–∏–π' : '‚ö†Ô∏è URL –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ';
            addLog(`   ${index + 1}. ${speaker.name}: ${fileStatus}`);
            if (speaker.local_path) {
              addLog(`      –®–ª—è—Ö: ${speaker.local_path}`);
            }
            if (speakerUrl) {
              addLog(`      URL: ${speakerUrl}`);
            }
            if (speaker.timeline) {
              addLog(`      –¢—Ä–∏–≤–∞–ª—ñ—Å—Ç—å: ${speaker.timeline.duration || 'N/A'} —Å–µ–∫`);
            }
          });
          
          tracksSection.style.display = 'block';
          addLog('');
        } else {
          addLog('‚ö†Ô∏è –†–æ–∑–¥—ñ–ª–µ–Ω—ñ —Ç—Ä–µ–∫–∏ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ');
          addLog('');
        }
        
        // Final summary
        const totalTime = ((Date.now() - startTime) / 1000).toFixed(2);
        addLog('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        addLog('üìä –ü–Ü–î–°–£–ú–û–ö –ü–†–û–¶–ï–°–£');
        addLog('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        addLog(`   –ó–∞–≥–∞–ª—å–Ω–∏–π —á–∞—Å –æ–±—Ä–æ–±–∫–∏: ${totalTime} —Å–µ–∫`);
        addLog(`   –ß–∞—Å –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è: ${uploadTime} —Å–µ–∫`);
        addLog(`   –ß–∞—Å —Ä–æ–∑–¥—ñ–ª–µ–Ω–Ω—è: ${separationTime} —Å–µ–∫`);
        addLog(`   –ö—ñ–ª—å–∫—ñ—Å—Ç—å —Ñ—Ä–∞–≥–º–µ–Ω—Ç—ñ–≤: ${separationResult.speakers?.length || 0}`);
        addLog(`   –°—Ç–∞—Ç—É—Å: ‚úÖ –£—Å–ø—ñ—à–Ω–æ –∑–∞–≤–µ—Ä—à–µ–Ω–æ`);
        addLog('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        
      } catch (error) {
        // 6. –£ –≤–∏–ø–∞–¥–∫—É –ø–æ–º–∏–ª–æ–∫
        const errorTime = ((Date.now() - startTime) / 1000).toFixed(2);
        addLog('');
        addLog('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        addLog('‚ùå –ü–û–ú–ò–õ–ö–ê –ü–†–û–¶–ï–°–£');
        addLog('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        addLog(`   –ö–æ–¥ –ø–æ–º–∏–ª–∫–∏: ${error.name || 'Unknown'}`);
        addLog(`   –û–ø–∏—Å: ${error.message || 'Unknown error'}`);
        addLog(`   –ß–∞—Å –¥–æ –ø–æ–º–∏–ª–∫–∏: ${errorTime} —Å–µ–∫`);
        if (error.stack) {
          addLog('   –°—Ç–µ–∫ —Ç—Ä–∞—Å—É–≤–∞–Ω–Ω—è:');
          const stackLines = error.stack.split('\n').slice(0, 5); // –ü–µ—Ä—à—ñ 5 —Ä—è–¥–∫—ñ–≤
          stackLines.forEach(line => {
            addLog(`      ${line.trim()}`);
          });
        }
        if (error.response) {
          addLog(`   HTTP —Å—Ç–∞—Ç—É—Å: ${error.response.status}`);
          addLog(`   HTTP —Å—Ç–∞—Ç—É—Å —Ç–µ–∫—Å—Ç: ${error.response.statusText}`);
        }
        addLog('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        
        console.error('Separation debug error:', error);
        statusEl.textContent = `‚ùå –ü–æ–º–∏–ª–∫–∞: ${error.message}`;
        statusEl.style.color = '#e74c3c';
        alert(`–ü–æ–º–∏–ª–∫–∞ —Ä–æ–∑–¥—ñ–ª–µ–Ω–Ω—è: ${error.message}`);
      } finally {
        btn.disabled = false;
        btn.style.opacity = '1';
        btn.style.cursor = 'pointer';
        btn.innerHTML = originalText;
      }
    }
    
    async function runMultimodalDiarization() {
      const btn = document.getElementById('runMultimodalBtn');
      const statusEl = document.getElementById('multimodalStatus');
      const resultEl = document.getElementById('multimodalResult');
      const fileInput = document.getElementById('multimodalAudioFile');
      const originalText = btn.innerHTML;
      
      // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –Ω–∞—è–≤–Ω—ñ—Å—Ç—å –∞—É–¥—ñ–æ —Ñ–∞–π–ª—É
      if (!fileInput || !fileInput.files || fileInput.files.length === 0) {
        alert('‚ö†Ô∏è Please select an audio file first.');
        return;
      }
      
      const audioFile = fileInput.files[0];
      
      // –û–Ω–æ–≤–ª—é—î–º–æ UI
      btn.disabled = true;
      btn.style.opacity = '0.6';
      btn.style.cursor = 'not-allowed';
      btn.innerHTML = '‚è≥ Processing...';
      statusEl.textContent = 'Preparing transcript...';
      statusEl.style.color = '#333';
      resultEl.value = 'Processing...';
      
      try {
        // Try to get transcript from window.currentTable if available
        let transcript = '';
        
        if (window.currentTable && Array.isArray(window.currentTable) && window.currentTable.length > 0) {
          console.log('‚úÖ [MULTIMODAL] Using transcript from window.currentTable');
          statusEl.textContent = 'Converting currentTable to transcript format...';
          
          // Convert currentTable JSON to transcript format
          // Format: SPEAKER_XX: text
          const transcriptLines = [];
          window.currentTable.forEach(track => {
            const dialogueType = track.dialogueType || 'unknown';
            const dialogueNumber = track.dialogueNumber || 0;
            const speakerLabel = dialogueType === 'agent' ? `SPEAKER_${dialogueNumber}` : 
                                 dialogueType === 'client' ? `SPEAKER_${dialogueNumber}` : 
                                 `SPEAKER_${dialogueNumber}`;
            
            if (track.dialogueAnalysis && Array.isArray(track.dialogueAnalysis)) {
              track.dialogueAnalysis.forEach(fragment => {
                const text = fragment.fragment || '';
                if (text.trim()) {
                  transcriptLines.push(`${speakerLabel}: ${text}`);
                }
              });
            }
          });
          
          transcript = transcriptLines.join('\n');
          console.log(`‚úÖ [MULTIMODAL] Converted currentTable to transcript (${transcriptLines.length} lines)`);
        } else {
          // Fallback to old logic: get transcript from current analysis
          console.log('‚ÑπÔ∏è [MULTIMODAL] window.currentTable not available, using fallback method');
          const generalJson = getGeneralJSON();
          if (generalJson) {
            if (generalJson.recordings && generalJson.recordings[0] && generalJson.recordings[0].results) {
              const segments = generalJson.recordings[0].results['text-service']?.segments || [];
              transcript = segments.map(seg => {
                const speaker = seg.speaker || 'SPEAKER_00';
                const text = seg.text || '';
                return `${speaker}: ${text}`;
              }).join('\n');
            }
          }
          
          if (!transcript.trim()) {
            console.warn('‚ö†Ô∏è [MULTIMODAL] No transcript found. Multimodal diarization will work with audio only.');
          }
        }
        
        statusEl.textContent = 'Uploading file and starting multimodal diarization...';
        
        // –§–æ—Ä–º—É—î–º–æ FormData –¥–ª—è –≤—ñ–¥–ø—Ä–∞–≤–∫–∏ —Ñ–∞–π–ª—É
        // –°–µ—Ä–≤–µ—Ä –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –∑–±–µ—Ä—ñ–≥–∞—î —Ñ–∞–π–ª —É —Ç–∏–º—á–∞—Å–æ–≤–µ —Å—Ö–æ–≤–∏—â–µ —á–µ—Ä–µ–∑ multer
        const formData = new FormData();
        formData.append('audio', audioFile);
        formData.append('pipelineMode', 'multimodal');
        formData.append('language', document.getElementById('language')?.value || 'en');
        
        // Add transcript if available
        if (transcript.trim()) {
          formData.append('plainTranscript', transcript);
          console.log(`‚úÖ [MULTIMODAL] Added transcript (${transcript.length} chars) to request`);
        }
        
        // –í—ñ–¥–ø—Ä–∞–≤–ª—è—î–º–æ –∑–∞–ø–∏—Ç –Ω–∞ —Å–µ—Ä–≤–µ—Ä
        // –°–µ—Ä–≤–µ—Ä –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –∑–±–µ—Ä—ñ–≥–∞—î —Ñ–∞–π–ª —É —Ç–∏–º—á–∞—Å–æ–≤–µ —Å—Ö–æ–≤–∏—â–µ (temp_uploads)
        const response = await fetch('/api/diarize-combined', {
          method: 'POST',
          body: formData
        });
        
        if (!response.ok) {
          const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
          throw new Error(errorData.error || `HTTP ${response.status}`);
        }
        
        statusEl.textContent = 'Processing response...';
        const result = await response.json();
        
        console.log('‚úÖ [MULTIMODAL] Raw result received:', result);
        
        // –í–∏—Ç—è–≥—É—î–º–æ —Ä–µ–ø–ª—ñ–∫–∏ —Ç–∞ —Ç–∞–π–º—Å—Ç–µ–º–ø–∏ –∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—É
        let replicasData = [];
        
        try {
          // –®—É–∫–∞—î–º–æ —Å–µ–≥–º–µ–Ω—Ç–∏ –≤ —Ä—ñ–∑–Ω–∏—Ö –º–æ–∂–ª–∏–≤–∏—Ö –º—ñ—Å—Ü—è—Ö
          let segments = [];
          
          // –°–ø—Ä–æ–±—É—î–º–æ –∑–Ω–∞–π—Ç–∏ —Å–µ–≥–º–µ–Ω—Ç–∏ –≤ —Ä—ñ–∑–Ω–∏—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä–∞—Ö
          if (result?.recordings?.[0]?.results?.['text-service']?.segments) {
            segments = result.recordings[0].results['text-service'].segments;
            console.log('‚úÖ [MULTIMODAL] Found segments in text-service');
          } else if (result?.recordings?.[0]?.results?.speechmatics?.segments) {
            segments = result.recordings[0].results.speechmatics.segments;
            console.log('‚úÖ [MULTIMODAL] Found segments in speechmatics');
          } else if (result?.recordings?.[0]?.results?.combined?.segments) {
            segments = result.recordings[0].results.combined.segments;
            console.log('‚úÖ [MULTIMODAL] Found segments in combined');
          } else if (result?.segments && Array.isArray(result.segments)) {
            segments = result.segments;
            console.log('‚úÖ [MULTIMODAL] Found segments at top level');
          } else {
            // –°–ø—Ä–æ–±—É—î–º–æ –∑–Ω–∞–π—Ç–∏ –±—É–¥—å-—è–∫—ñ —Å–µ–≥–º–µ–Ω—Ç–∏ –≤ —Å—Ç—Ä—É–∫—Ç—É—Ä—ñ
            console.log('üîç [MULTIMODAL] Searching for segments in result structure...');
            console.log('üîç [MULTIMODAL] Result keys:', Object.keys(result));
            
            // –†–µ–∫—É—Ä—Å–∏–≤–Ω–∏–π –ø–æ—à—É–∫ —Å–µ–≥–º–µ–Ω—Ç—ñ–≤
            function findSegments(obj, path = '') {
              if (Array.isArray(obj) && obj.length > 0) {
                // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ —Ü–µ –º–∞—Å–∏–≤ —Å–µ–≥–º–µ–Ω—Ç—ñ–≤
                if (obj[0] && (obj[0].text || obj[0].transcript || obj[0].speaker)) {
                  return obj;
                }
              }
              
              if (typeof obj === 'object' && obj !== null) {
                for (const key in obj) {
                  if (key === 'segments' && Array.isArray(obj[key]) && obj[key].length > 0) {
                    return obj[key];
                  }
                  const found = findSegments(obj[key], path + '.' + key);
                  if (found) return found;
                }
              }
              return null;
            }
            
            const foundSegments = findSegments(result);
            if (foundSegments) {
              segments = foundSegments;
              console.log('‚úÖ [MULTIMODAL] Found segments via recursive search');
            }
          }
          
          if (segments && segments.length > 0) {
            console.log(`‚úÖ [MULTIMODAL] Found ${segments.length} segments`);
            console.log('üîç [MULTIMODAL] Sample segment:', segments[0]);
            
            // –î–æ–ø–æ–º—ñ–∂–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—è –¥–ª—è –Ω–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—ó —Ç–µ–∫—Å—Ç—É –¥–ª—è –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è
            // –í–∏—Ç—è–≥—É—î–º–æ —Ä–µ–ø–ª—ñ–∫–∏ —Ç–∞ —Ç–∞–π–º—Å—Ç–µ–º–ø–∏
            replicasData = segments.map((seg, index) => {
              const replica = {
                index: index + 1,
                speaker: seg.speaker || seg.speaker_id || seg.speakerLabel || 'UNKNOWN',
                text: seg.text || seg.transcript || seg.content || '',
                start: parseFloat(seg.start) || parseFloat(seg.startTime) || 0,
                end: parseFloat(seg.end) || parseFloat(seg.endTime) || parseFloat(seg.start) || 0,
                duration: 0
              };
              
              // –û–±—á–∏—Å–ª—é—î–º–æ —Ç—Ä–∏–≤–∞–ª—ñ—Å—Ç—å
              replica.duration = replica.end - replica.start;
              
              // –í–∞–ª—ñ–¥–∞—Ü—ñ—è —Ç–∞ –Ω–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—è —Ä–æ–ª—ñ –≤—ñ–¥ Gemini (–ø—Ä—ñ–æ—Ä–∏—Ç–µ—Ç Gemini)
              if (seg.role) {
                const geminiRole = (seg.role || '').toLowerCase().trim();
                
                // –ù–æ—Ä–º–∞–ª—ñ–∑—É—î–º–æ —Ä–æ–ª—å –≤—ñ–¥ Gemini
                let normalizedRole = null;
                if (geminiRole === 'operator' || geminiRole === 'agent') {
                  normalizedRole = 'operator';
                } else if (geminiRole === 'client' || geminiRole === 'customer') {
                  normalizedRole = 'client';
                }
                
                // –Ø–∫—â–æ —Ä–æ–ª—å –≤–∞–ª—ñ–¥–Ω–∞, –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ —ó—ó (–ø—Ä—ñ–æ—Ä–∏—Ç–µ—Ç Gemini)
                if (normalizedRole) {
                  replica.role = normalizedRole;
                  replica.roleSource = 'gemini'; // –ü–æ–∑–Ω–∞—á–∞—î–º–æ –¥–∂–µ—Ä–µ–ª–æ —Ä–æ–ª—ñ
                } else {
                  // –Ø–∫—â–æ —Ä–æ–ª—å –Ω–µ –≤–∞–ª—ñ–¥–Ω–∞, —Å–ø—Ä–æ–±—É—î–º–æ –≤–∏–∑–Ω–∞—á–∏—Ç–∏ –Ω–∞ –æ—Å–Ω–æ–≤—ñ —Å–ø—ñ–∫–µ—Ä–∞ (fallback)
                  console.warn(`‚ö†Ô∏è [MULTIMODAL] Invalid role from Gemini: "${seg.role}" for segment ${index + 1}, using speaker-based fallback`);
                  const speaker = replica.speaker;
                  if (speaker.includes('SPEAKER_00') || speaker.includes('SPEAKER_0')) {
                    replica.role = 'operator';
                    replica.roleSource = 'fallback-speaker';
                  } else if (speaker.includes('SPEAKER_01') || speaker.includes('SPEAKER_1')) {
                    replica.role = 'client';
                    replica.roleSource = 'fallback-speaker';
                  }
                }
              } else {
                // –Ø–∫—â–æ —Ä–æ–ª—å –≤—ñ–¥—Å—É—Ç–Ω—è, –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ fallback –Ω–∞ –æ—Å–Ω–æ–≤—ñ —Å–ø—ñ–∫–µ—Ä–∞
                const speaker = replica.speaker;
                if (speaker.includes('SPEAKER_00') || speaker.includes('SPEAKER_0')) {
                  replica.role = 'operator';
                  replica.roleSource = 'fallback-speaker';
                } else if (speaker.includes('SPEAKER_01') || speaker.includes('SPEAKER_1')) {
                  replica.role = 'client';
                  replica.roleSource = 'fallback-speaker';
                }
              }
              
              // –î–æ–¥–∞—î–º–æ –¥–æ–¥–∞—Ç–∫–æ–≤—ñ –ø–æ–ª—è, —è–∫—â–æ –≤–æ–Ω–∏ —î
              if (seg.confidence !== undefined) replica.confidence = seg.confidence;
              
              return replica;
            });
            
            console.log('‚úÖ [MULTIMODAL] Extracted replicas:', replicasData.length);
            
            // –ü–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è –∑ window.currentTable –¥–ª—è –≤–∏—è–≤–ª–µ–Ω–Ω—è –∫–æ–Ω—Ñ–ª—ñ–∫—Ç—ñ–≤ —Ä–æ–ª–µ–π
            // –ü—Ä—ñ–æ—Ä–∏—Ç–µ—Ç –∑–∞–≤–∂–¥–∏ –≤—ñ–¥–¥–∞—î—Ç—å—Å—è —Ä–æ–ª—ñ –≤—ñ–¥ Gemini
            if (window.currentTable && Array.isArray(window.currentTable) && window.currentTable.length > 0) {
              console.log('üîç [MULTIMODAL] Comparing with window.currentTable for role conflicts...');
              
              // –°—Ç–≤–æ—Ä—é—î–º–æ –º–∞–ø—É —Å–µ–≥–º–µ–Ω—Ç—ñ–≤ –∑ currentTable –¥–ª—è —à–≤–∏–¥–∫–æ–≥–æ –ø–æ—à—É–∫—É
              const currentTableSegments = [];
              window.currentTable.forEach(track => {
                if (track.dialogueAnalysis && Array.isArray(track.dialogueAnalysis)) {
                  track.dialogueAnalysis.forEach(fragment => {
                    currentTableSegments.push({
                      text: fragment.fragment || '',
                      start: fragment.start,
                      end: fragment.end,
                      role: track.dialogueType === 'agent' ? 'operator' : 
                            track.dialogueType === 'client' ? 'client' : null,
                      source: 'overlap-diarization'
                    });
                  });
                }
              });
              
              // –ü–æ—Ä—ñ–≤–Ω—é—î–º–æ —Ä–æ–ª—ñ —Ç–∞ –≤—ñ–¥–¥–∞—î–º–æ –ø—Ä—ñ–æ—Ä–∏—Ç–µ—Ç Gemini
              let conflictsFound = 0;
              replicasData.forEach((geminiReplica, idx) => {
                if (!geminiReplica.role || geminiReplica.roleSource === 'fallback-speaker') {
                  return; // –ü—Ä–æ–ø—É—Å–∫–∞—î–º–æ, —è–∫—â–æ —Ä–æ–ª—å –≤—ñ–¥ Gemini –≤—ñ–¥—Å—É—Ç–Ω—è –∞–±–æ fallback
                }
                
                // –®—É–∫–∞—î–º–æ –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–∏–π —Å–µ–≥–º–µ–Ω—Ç –≤ currentTable –∑–∞ —Ç–µ–∫—Å—Ç–æ–º —Ç–∞ —Ç–∞–π–º—Å—Ç–µ–º–ø–æ–º
                const matchingSegment = currentTableSegments.find(seg => {
                  const textSimilar = normalizeTextForComparison(seg.text).includes(normalizeTextForComparison(geminiReplica.text)) ||
                                     normalizeTextForComparison(geminiReplica.text).includes(normalizeTextForComparison(seg.text));
                  const timeOverlap = Math.abs(seg.start - geminiReplica.start) < 2.0 || 
                                     Math.abs(seg.end - geminiReplica.end) < 2.0;
                  return textSimilar && timeOverlap;
                });
                
                if (matchingSegment && matchingSegment.role && matchingSegment.role !== geminiReplica.role) {
                  conflictsFound++;
                  console.log(`‚ö†Ô∏è [MULTIMODAL] Role conflict detected for replica ${idx + 1}:`, {
                    geminiRole: geminiReplica.role,
                    overlapRole: matchingSegment.role,
                    text: geminiReplica.text.substring(0, 50),
                    resolution: `Using Gemini role (${geminiReplica.role}) - priority to Gemini`
                  });
                  
                  // –í—ñ–¥–¥–∞—î–º–æ –ø—Ä—ñ–æ—Ä–∏—Ç–µ—Ç —Ä–æ–ª—ñ –≤—ñ–¥ Gemini (–≤–∂–µ –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ, –ø—Ä–æ—Å—Ç–æ –ª–æ–≥—É—î–º–æ)
                  geminiReplica.roleConflict = {
                    overlapRole: matchingSegment.role,
                    geminiRole: geminiReplica.role,
                    resolved: true,
                    resolution: 'gemini-priority'
                  };
                }
              });
              
              if (conflictsFound > 0) {
                console.log(`‚úÖ [MULTIMODAL] Found ${conflictsFound} role conflicts, all resolved with Gemini priority`);
              } else {
                console.log('‚úÖ [MULTIMODAL] No role conflicts found with overlap-diarization results');
              }
            }
          } else {
            console.warn('‚ö†Ô∏è [MULTIMODAL] No segments found in result');
            replicasData = [{
              error: 'No segments found in multimodal diarization result',
              rawResultStructure: Object.keys(result),
              fullResult: result
            }];
          }
        } catch (extractionError) {
          console.error('‚ùå [MULTIMODAL] Error extracting replicas:', extractionError);
          replicasData = [{
            error: `Extraction error: ${extractionError.message}`,
            stack: extractionError.stack,
            rawResult: result
          }];
        }
        
        // –°—Ç–≤–æ—Ä—é—î–º–æ JSON –∑ —Ä–µ–ø–ª—ñ–∫–∞–º–∏
        const replicasJSON = {
          source: 'multimodal-diarization',
          timestamp: new Date().toISOString(),
          totalReplicas: replicasData.length,
          replicas: replicasData,
          roleValidation: {
            geminiPriority: true,
            note: 'Roles from Gemini multimodal diarization have priority over other sources in case of conflicts'
          }
        };
        
        // –í–∏–≤–æ–¥–∏–º–æ JSON –≤ textarea
        const formattedResult = JSON.stringify(replicasJSON, null, 2);
        resultEl.value = formattedResult;
        
        statusEl.textContent = `‚úÖ Multimodal diarization completed! Extracted ${replicasData.length} replicas.`;
        statusEl.style.color = '#27ae60';
        
        console.log('‚úÖ [MULTIMODAL] Replicas extracted:', replicasJSON);
        
        // –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –≤–∏–∫–ª–∏–∫–∞—î–º–æ –æ–±'—î–¥–Ω–∞–Ω–Ω—è –¥–ª—è –≤—Å—ñ—Ö –Ω–∞—è–≤–Ω–∏—Ö —Ä–µ–ø–ª—ñ–∫
        if (replicasData.length > 0 && window.currentTable) {
          console.log(`üîÑ [MULTIMODAL] Starting merge analysis for all ${replicasData.length} replicas...`);
          statusEl.textContent = `Analyzing all ${replicasData.length} replicas merge...`;
          try {
            await mergeReplicasWithLLM(replicasData, resultEl, statusEl);
          } catch (mergeError) {
            console.error('‚ùå [MULTIMODAL] Merge analysis error:', mergeError);
            statusEl.textContent = `‚úÖ Multimodal completed. Merge analysis failed: ${mergeError.message}`;
          }
        }
        
      } catch (error) {
        console.error('‚ùå [MULTIMODAL] Error:', error);
        statusEl.textContent = `‚ùå Error: ${error.message}`;
        statusEl.style.color = '#e74c3c';
        resultEl.value = `Error: ${error.message}\n\nStack: ${error.stack || 'N/A'}`;
        alert(`Error: ${error.message}`);
      } finally {
        btn.disabled = false;
        btn.style.opacity = '1';
        btn.style.cursor = 'pointer';
        btn.innerHTML = originalText;
      }
    }
    
    // Match original replicas (without timestamps) with diarized segments (with timestamps) using LLM
    async function matchOriginalReplicasWithLLM(originalReplicas, diarizedSegments) {
      if (!originalReplicas || originalReplicas.length === 0) {
        console.log('‚ÑπÔ∏è [MATCH ORIGINAL] No original replicas to match');
        return new Map();
      }
      
      if (!diarizedSegments || diarizedSegments.length === 0) {
        console.log('‚ÑπÔ∏è [MATCH ORIGINAL] No diarized segments to match');
        return new Map();
      }
      
      console.log(`üîç [MATCH ORIGINAL] Starting LLM matching: ${originalReplicas.length} original replicas vs ${diarizedSegments.length} diarized segments`);
      
      const matches = new Map(); // key: segmentIndex, value: {originalRole, originalText, originalIndex, confidence}
      
      // Process in batches to avoid overwhelming LLM
      const batchSize = 5;
      const batches = [];
      for (let i = 0; i < diarizedSegments.length; i += batchSize) {
        batches.push(diarizedSegments.slice(i, i + batchSize));
      }
      
      for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {
        const batch = batches[batchIndex];
        console.log(`üîÑ [MATCH ORIGINAL] Processing batch ${batchIndex + 1}/${batches.length} (${batch.length} segments)`);
        
        // Create prompt for batch matching
        const segmentsList = batch.map((seg, idx) => {
          const globalIdx = batchIndex * batchSize + idx;
          const text = seg.text || seg.transcript || (seg.words && Array.isArray(seg.words) 
            ? seg.words.map(w => w.word || w.text || '').join(' ').trim() 
            : '');
          const role = seg.role || (seg.speaker === 'SPEAKER_00' || seg.speaker === 'SPEAKER_0' ? 'agent' : 'client');
          return {
            index: globalIdx,
            text: text,
            role: role,
            start: seg.start || 0,
            end: seg.end || 0
          };
        }).filter(s => s.text && s.text.trim());
        
        const originalList = originalReplicas.map((orig, idx) => ({
          index: idx,
          text: orig.text || '',
          role: orig.role || 'unknown'
        })).filter(o => o.text && o.text.trim());
        
        if (segmentsList.length === 0 || originalList.length === 0) {
          continue;
        }
        
        const prompt = `You are matching original dialogue replicas (from a script/transcript without timestamps) with diarized audio segments (with timestamps).

**Original Replicas (from script):**
${originalList.map((o, i) => `${i + 1}. [${o.role || 'unknown'}] ${o.text}`).join('\n')}

**Diarized Segments (from audio processing):**
${segmentsList.map((s, i) => `${i + 1}. [${s.role}] [${s.start.toFixed(2)}s-${s.end.toFixed(2)}s] ${s.text}`).join('\n')}

**Task:**
For each diarized segment, find the best matching original replica based on semantic meaning (not exact text match). Consider:
- Semantic similarity (same meaning, even if words differ)
- Role consistency (agent should match agent, client should match client)
- Context and flow of conversation

**Output Format (JSON only):**
{
  "matches": [
    {
      "segmentIndex": 0,
      "originalIndex": 2,
      "confidence": 0.95,
      "reason": "Semantically identical - both ask for account number"
    }
  ]
}

Return matches for all ${segmentsList.length} diarized segments. If no good match exists (confidence < 0.5), omit that segment.`;

        try {
          const response = await fetch('/api/debug-llm-query', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              prompt: prompt
            })
          });
          
          if (!response.ok) {
            throw new Error(`LLM request failed: ${response.status}`);
          }
          
          const result = await response.json();
          if (!result.success) {
            throw new Error(result.error || 'LLM query failed');
          }
          
          const llmOutput = result.result.trim();
          console.log(`‚úÖ [MATCH ORIGINAL] LLM response for batch ${batchIndex + 1}:`, llmOutput.substring(0, 200) + '...');
          
          // Parse JSON response
          let matchResult = null;
          try {
            // Remove markdown code blocks if present
            let jsonText = llmOutput;
            jsonText = jsonText.replace(/<\|[^|]+\|>/g, ''); // Remove tokens
            const jsonMatch = jsonText.match(/```(?:json)?\s*(\{[\s\S]*?\})\s*```/);
            if (jsonMatch) {
              jsonText = jsonMatch[1];
            } else {
              const jsonObjectMatch = jsonText.match(/\{[\s\S]*\}/);
              if (jsonObjectMatch) {
                jsonText = jsonObjectMatch[0];
              }
            }
            matchResult = JSON.parse(jsonText.trim());
          } catch (parseError) {
            console.error(`‚ùå [MATCH ORIGINAL] Failed to parse LLM response for batch ${batchIndex + 1}:`, parseError);
            console.error(`Raw output:`, llmOutput);
            continue;
          }
          
          // Process matches
          if (matchResult && matchResult.matches && Array.isArray(matchResult.matches)) {
            matchResult.matches.forEach(match => {
              const segmentIdx = match.segmentIndex;
              const originalIdx = match.originalIndex;
              const confidence = match.confidence || 0;
              
              if (segmentIdx >= 0 && segmentIdx < segmentsList.length && 
                  originalIdx >= 0 && originalIdx < originalList.length &&
                  confidence >= 0.5) {
                const originalReplica = originalReplicas[originalIdx];
                const globalSegmentIdx = batchIndex * batchSize + segmentIdx;
                
                matches.set(globalSegmentIdx, {
                  originalRole: originalReplica.role || 'unknown',
                  originalText: originalReplica.text || '',
                  originalIndex: originalIdx,
                  confidence: confidence,
                  reason: match.reason || 'LLM matched'
                });
                
                console.log(`‚úÖ [MATCH ORIGINAL] Matched segment ${globalSegmentIdx} with original ${originalIdx} (confidence: ${(confidence * 100).toFixed(1)}%)`);
              }
            });
          }
          
        } catch (error) {
          console.error(`‚ùå [MATCH ORIGINAL] Error processing batch ${batchIndex + 1}:`, error);
          // Continue with next batch
        }
      }
      
      console.log(`‚úÖ [MATCH ORIGINAL] Matching completed: ${matches.size} matches found out of ${diarizedSegments.length} segments`);
      return matches;
    }
    
    // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –∞–Ω–∞–ª—ñ–∑—É –æ–¥–Ω—ñ—î—ó —Ä–µ–ø–ª—ñ–∫–∏
    async function analyzeReplicaMerge(overlapReplica, multimodalReplica, replicaNumber) {
      console.log(`üîç [MERGE] Analyzing replica ${replicaNumber}...`);
      console.log(`   Overlap: "${overlapReplica.text.substring(0, 50)}..."`);
      console.log(`   Multimodal: "${multimodalReplica.text.substring(0, 50)}..."`);
      
      // –û–±—á–∏—Å–ª—é—î–º–æ –º–µ—Ç—Ä–∏–∫–∏ –ø–µ—Ä–µ—Ç–∏–Ω—É —Ç–∞–π–º—Å—Ç–µ–º–ø—ñ–≤
      const timeOverlap = calculateTimeOverlap(
        overlapReplica.start, overlapReplica.end,
        multimodalReplica.start, multimodalReplica.end
      );
      
      // –ü—Ä–æ—Å—Ç–∏–π –ø—Ä–æ–º–ø—Ç –¥–ª—è –æ–±'—î–¥–Ω–∞–Ω–Ω—è –¥–≤–æ—Ö —Ä–µ–ø–ª—ñ–∫
      const mergePrompt = `You have two versions of the same utterance from a customer support dialogue. Your task is to create ONE correct, complete, and grammatically correct sentence that combines all unique details from both versions.

**Version A:** "${overlapReplica.text}"
**Version B:** "${multimodalReplica.text}"

**Instructions:**
1. Combine ALL unique content from both versions into a single sentence
2. Fix any transcription errors (e.g., "acne" -> "Acme", "active" -> "Acme")
3. Use proper punctuation, capitalization, and grammar
4. Remove duplicate words and phrases
5. Create a natural, fluent sentence (NOT a concatenation of both texts)

**Output Format (JSON only):**
{
  "mergedText": "The single, correct, complete sentence combining both versions with all errors fixed"
}`;

      // –í—ñ–¥–ø—Ä–∞–≤–ª—è—î–º–æ –Ω–∞ LLM –¥–ª—è –æ–±'—î–¥–Ω–∞–Ω–Ω—è
      const llmResponse = await fetch('/api/debug-llm-query', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          prompt: mergePrompt
        })
      });
      
      if (!llmResponse.ok) {
        throw new Error(`LLM request failed: ${llmResponse.status}`);
      }
      
      const llmResult = await llmResponse.json();
      if (!llmResult.success) {
        throw new Error(llmResult.error || 'LLM query failed');
      }
      
      const llmOutput = llmResult.result.trim();
      console.log(`‚úÖ [MERGE] LLM response received for replica ${replicaNumber}:`, llmOutput.substring(0, 200) + '...');
      
      // –ü–∞—Ä—Å–∏–º–æ JSON –≤—ñ–¥–ø–æ–≤—ñ–¥—å –≤—ñ–¥ LLM
      let mergeResult = null;
      try {
        let jsonText = llmOutput;
        
        // –ö—Ä–æ–∫ 1: –í–∏–¥–∞–ª—è—î–º–æ —Ç–æ–∫–µ–Ω–∏ —Ç–∏–ø—É <|channel|>, <|constrain|>, <|message|> —Ç–∞ —ñ–Ω—à—ñ –ø–æ–¥—ñ–±–Ω—ñ
        jsonText = jsonText.replace(/<\|[^|]+\|>/g, '');
        
        // –ö—Ä–æ–∫ 2: –°–ø—Ä–æ–±—É—î–º–æ –≤–∏—Ç—è–≥—Ç–∏ JSON –∑ markdown code blocks
        const jsonMatch = jsonText.match(/```(?:json)?\s*(\{[\s\S]*?\})\s*```/);
        if (jsonMatch) {
          jsonText = jsonMatch[1];
        } else {
          // –ö—Ä–æ–∫ 3: –°–ø—Ä–æ–±—É—î–º–æ –∑–Ω–∞–π—Ç–∏ JSON –æ–±'—î–∫—Ç –≤ —Ç–µ–∫—Å—Ç—ñ (–ø–æ—á–∏–Ω–∞—î—Ç—å—Å—è –∑ { —ñ –∑–∞–∫—ñ–Ω—á—É—î—Ç—å—Å—è })
          const jsonObjectMatch = jsonText.match(/\{[\s\S]*\}/);
          if (jsonObjectMatch) {
            jsonText = jsonObjectMatch[0];
          }
        }
        
        // –ö—Ä–æ–∫ 4: –û—á–∏—â–∞—î–º–æ –≤—ñ–¥ –∑–∞–π–≤–∏—Ö –ø—Ä–æ–±—ñ–ª—ñ–≤ —Ç–∞ –ø–µ—Ä–µ–Ω–æ—Å—ñ–≤ —Ä—è–¥–∫—ñ–≤
        jsonText = jsonText.trim();
        
        // –ö—Ä–æ–∫ 5: –ü–∞—Ä—Å–∏–º–æ JSON
        mergeResult = JSON.parse(jsonText);
      } catch (parseError) {
        console.error(`‚ùå [MERGE] Failed to parse LLM response as JSON for replica ${replicaNumber}:`, parseError);
        console.error(`‚ùå [MERGE] Raw LLM output:`, llmOutput);
        
        // –°–ø—Ä–æ–±—É—î–º–æ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–∏–π –º–µ—Ç–æ–¥: –≤–∏—Ç—è–≥—Ç–∏ mergedText –Ω–∞–ø—Ä—è–º—É –∑ —Ç–µ–∫—Å—Ç—É
        try {
          const mergedTextMatch = llmOutput.match(/"mergedText"\s*:\s*"([^"]+)"/);
          if (mergedTextMatch) {
            mergeResult = { mergedText: mergedTextMatch[1] };
            console.log(`‚úÖ [MERGE] Extracted mergedText using regex fallback for replica ${replicaNumber}`);
          } else {
            // –û—Å—Ç–∞–Ω–Ω—è —Å–ø—Ä–æ–±–∞: –∑–Ω–∞–π—Ç–∏ —Ç–µ–∫—Å—Ç –º—ñ–∂ –ª–∞–ø–∫–∞–º–∏ –ø—ñ—Å–ª—è "mergedText"
            const altMatch = llmOutput.match(/mergedText["\s:]+["']([^"']+)["']/);
            if (altMatch) {
              mergeResult = { mergedText: altMatch[1] };
              console.log(`‚úÖ [MERGE] Extracted mergedText using alternative regex for replica ${replicaNumber}`);
            } else {
        throw new Error(`Failed to parse LLM response: ${parseError.message}`);
            }
          }
        } catch (fallbackError) {
          console.error(`‚ùå [MERGE] All parsing attempts failed for replica ${replicaNumber}:`, fallbackError);
          throw new Error(`Failed to parse LLM response: ${parseError.message}`);
        }
      }
      
      // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –≤–∞–ª—ñ–¥–Ω—ñ—Å—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—É
      if (!mergeResult || !mergeResult.mergedText || mergeResult.mergedText.trim().length === 0) {
        console.warn(`‚ö†Ô∏è [MERGE] Invalid merge result for replica ${replicaNumber}, using multimodal version`);
        // –Ø–∫—â–æ LLM –Ω–µ –Ω–∞–¥–∞–ª–∞ –æ–±'—î–¥–Ω–∞–Ω–∏–π —Ç–µ–∫—Å—Ç, –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ multimodal –≤–µ—Ä—Å—ñ—é
        return {
          replicaNumber: replicaNumber,
          analysis: {
            similarityScore: timeOverlap.overlapRatio,
            explanation: 'LLM did not provide merged text, using multimodal version',
            confidence: 0,
            recommendation: 'use_B',
            fallbackUsed: true
          },
          metrics: {
            timeOverlap: {
              overlapRatio: timeOverlap.overlapRatio,
              overlapDuration: timeOverlap.overlapDuration,
              totalDuration: timeOverlap.totalDuration
            },
            roleMatch: overlapReplica.role === multimodalReplica.role,
            speakerMatch: overlapReplica.speaker === multimodalReplica.speaker
          },
          versions: {
            overlap: {
              text: overlapReplica.text,
              start: overlapReplica.start,
              end: overlapReplica.end,
              role: overlapReplica.role,
              speaker: overlapReplica.speaker
            },
            multimodal: {
              text: multimodalReplica.text,
              start: multimodalReplica.start,
              end: multimodalReplica.end,
              role: multimodalReplica.role,
              speaker: multimodalReplica.speaker
            }
          },
          decision: {
            isMatching: timeOverlap.overlapRatio >= 0.2,
            selectedText: multimodalReplica.text,
            selectedSource: 'multimodal-diarization',
            decisionReason: 'LLM did not provide merged text, using multimodal version',
            similarityScore: timeOverlap.overlapRatio,
            llmConfidence: 0,
            timeOverlapRatio: timeOverlap.overlapRatio
          },
          recommendedText: multimodalReplica.text
        };
      }
      
      // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –æ–±'—î–¥–Ω–∞–Ω–∏–π —Ç–µ–∫—Å—Ç –≤—ñ–¥ LLM
      const mergedText = mergeResult.mergedText.trim();
      console.log(`‚úÖ [MERGE] Using merged text from LLM for replica ${replicaNumber}:`, mergedText.substring(0, 80) + '...');
      
      // –§–æ—Ä–º—É—î–º–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –¥–ª—è –≤–∏–≤–µ–¥–µ–Ω–Ω—è
      return {
        replicaNumber: replicaNumber,
        analysis: {
          similarityScore: timeOverlap.overlapRatio,
          explanation: 'LLM successfully merged both versions',
          confidence: 0.9,
          recommendation: 'merge',
          fallbackUsed: false
        },
        metrics: {
          timeOverlap: {
            overlapRatio: timeOverlap.overlapRatio,
            overlapDuration: timeOverlap.overlapDuration,
            totalDuration: timeOverlap.totalDuration
          },
          roleMatch: overlapReplica.role === multimodalReplica.role,
          speakerMatch: overlapReplica.speaker === multimodalReplica.speaker
        },
        versions: {
          overlap: {
            text: overlapReplica.text,
            start: overlapReplica.start,
            end: overlapReplica.end,
            role: overlapReplica.role,
            speaker: overlapReplica.speaker
          },
          multimodal: {
            text: multimodalReplica.text,
            start: multimodalReplica.start,
            end: multimodalReplica.end,
            role: multimodalReplica.role,
            speaker: multimodalReplica.speaker
          }
        },
        decision: {
          isMatching: true,
          selectedText: mergedText,
          selectedSource: 'merged',
          decisionReason: 'LLM merged and corrected both versions',
          similarityScore: timeOverlap.overlapRatio,
          llmConfidence: 0.9,
          timeOverlapRatio: timeOverlap.overlapRatio
        },
        recommendedText: mergedText
      };
    }
    
    // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –æ–±'—î–¥–Ω–∞–Ω–Ω—è —Ä–µ–ø–ª—ñ–∫ –∑ overlap-–¥—ñ–∞—Ä–∏–∑–∞—Ü—ñ—ó —Ç–∞ multimodal diarization
    async function mergeReplicasWithLLM(multimodalReplicas, resultEl, statusEl) {
      try {
        console.log(`üîç [MERGE] Starting merge analysis for ${multimodalReplicas.length} replica(s)...`);
        
        // –û—Ç—Ä–∏–º—É—î–º–æ —Ä–µ–ø–ª—ñ–∫–∏ –∑ overlap-–¥—ñ–∞—Ä–∏–∑–∞—Ü—ñ—ó (window.currentTable)
        if (!window.currentTable || !Array.isArray(window.currentTable) || window.currentTable.length === 0) {
          throw new Error('window.currentTable is not available. Please run "Analyze Dialogue" first.');
        }
        
        // –ó–±–∏—Ä–∞—î–º–æ –≤—Å—ñ —Ä–µ–ø–ª—ñ–∫–∏ –∑ overlap-–¥—ñ–∞—Ä–∏–∑–∞—Ü—ñ—ó –≤ —Ö—Ä–æ–Ω–æ–ª–æ–≥—ñ—á–Ω–æ–º—É –ø–æ—Ä—è–¥–∫—É
        const overlapReplicas = [];
        window.currentTable.forEach(track => {
          if (track.dialogueAnalysis && Array.isArray(track.dialogueAnalysis)) {
            track.dialogueAnalysis.forEach(fragment => {
              // –í–∏–∑–Ω–∞—á–∞—î–º–æ —Ä–æ–ª—å –Ω–∞ –æ—Å–Ω–æ–≤—ñ track.dialogueType (–±—ñ–ª—å—à –Ω–∞–¥—ñ–π–Ω–µ, –Ω—ñ–∂ fragment.role)
              const role = track.dialogueType === 'agent' ? 'operator' : 
                          track.dialogueType === 'client' ? 'client' : 
                          (fragment.role === 'agent' ? 'operator' : 
                           fragment.role === 'client' ? 'client' : null);
              
              // –í–∏–∑–Ω–∞—á–∞—î–º–æ —Å–ø—ñ–∫–µ—Ä–∞ –Ω–∞ –æ—Å–Ω–æ–≤—ñ track.dialogueType —Ç–∞ dialogueNumber
              // dialogueNumber 0 -> SPEAKER_00, dialogueNumber 1 -> SPEAKER_01
              const speaker = track.dialogueNumber === 1 ? 'SPEAKER_01' : 'SPEAKER_00';
              
              overlapReplicas.push({
                text: fragment.fragment || '',
                start: fragment.start,
                end: fragment.end,
                role: role,
                speaker: speaker,
                source: 'overlap-diarization',
                dialogueNumber: track.dialogueNumber,
                fragmentNumber: fragment.fragmentNumber
              });
            });
          }
        });
        
        // –°–æ—Ä—Ç—É—î–º–æ –∑–∞ —á–∞—Å–æ–º –ø–æ—á–∞—Ç–∫—É
        overlapReplicas.sort((a, b) => (a.start || 0) - (b.start || 0));
        
        if (overlapReplicas.length === 0) {
          throw new Error('No replicas found in window.currentTable');
        }
        
        console.log(`üîç [MERGE] Found ${overlapReplicas.length} overlap replicas, analyzing all ${multimodalReplicas.length} multimodal replicas...`);
        
        // –û–±—Ä–æ–±–ª—è—î–º–æ –∫–æ–∂–Ω—É —Ä–µ–ø–ª—ñ–∫—É
        const mergeResults = [];
        const totalToProcess = Math.min(multimodalReplicas.length, overlapReplicas.length);
        
        for (let i = 0; i < totalToProcess; i++) {
          const multimodalReplica = multimodalReplicas[i];
          const overlapReplica = overlapReplicas[i];
          
          console.log(`üîç [MERGE] Processing replica ${i + 1}/${totalToProcess}...`);
          statusEl.textContent = `Analyzing replica ${i + 1}/${totalToProcess} (${((i + 1) / totalToProcess * 100).toFixed(0)}%)...`;
          
          try {
            const replicaResult = await analyzeReplicaMerge(overlapReplica, multimodalReplica, i + 1);
            mergeResults.push(replicaResult);
            console.log(`‚úÖ [MERGE] Completed replica ${i + 1}/${totalToProcess}: similarity=${((replicaResult.analysis.similarityScore || 0) * 100).toFixed(1)}%`);
          } catch (replicaError) {
            console.error(`‚ùå [MERGE] Error processing replica ${i + 1}:`, replicaError);
            console.log(`üîÑ [MERGE] Attempting fallback matching for replica ${i + 1}...`);
            
            // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ fallback –ª–æ–≥—ñ–∫—É –¥–ª—è –º–µ—Ç—á–∏–Ω–≥—É
            try {
              const fallbackResult = fallbackMatching(multimodalReplica, overlapReplicas, i + 1);
              mergeResults.push(fallbackResult);
              console.log(`‚úÖ [MERGE] Fallback matching completed for replica ${i + 1}`);
            } catch (fallbackError) {
              console.error(`‚ùå [MERGE] Fallback matching also failed for replica ${i + 1}:`, fallbackError);
              // –î–æ–¥–∞—î–º–æ –ø–æ–º–∏–ª–∫—É –¥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤, —â–æ–± –Ω–µ –≤—Ç—Ä–∞—Ç–∏—Ç–∏ –ø—Ä–æ–≥—Ä–µ—Å
              mergeResults.push({
                replicaNumber: i + 1,
                error: replicaError.message,
                fallbackError: fallbackError.message,
                versions: {
                  overlap: {
                    text: overlapReplica.text,
                    start: overlapReplica.start,
                    end: overlapReplica.end,
                    role: overlapReplica.role,
                    speaker: overlapReplica.speaker
                  },
                  multimodal: {
                    text: multimodalReplica.text,
                    start: multimodalReplica.start,
                    end: multimodalReplica.end,
                    role: multimodalReplica.role,
                    speaker: multimodalReplica.speaker
                  }
                },
                decision: {
                  selectedText: multimodalReplica.text,
                  selectedSource: 'multimodal-diarization',
                  decisionReason: 'LLM analysis failed, fallback matching failed, using multimodal version as default'
                }
              });
            }
          }
        }
        
        // –Ø–∫—â–æ —î –¥–æ–¥–∞—Ç–∫–æ–≤—ñ —Ä–µ–ø–ª—ñ–∫–∏ –≤ multimodal, —è–∫—ñ –Ω–µ –º–∞—é—Ç—å –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–∏–∫—ñ–≤ –≤ overlap
        if (multimodalReplicas.length > overlapReplicas.length) {
          console.log(`‚ö†Ô∏è [MERGE] Found ${multimodalReplicas.length - overlapReplicas.length} additional multimodal replicas without overlap counterparts`);
          for (let i = overlapReplicas.length; i < multimodalReplicas.length; i++) {
            mergeResults.push({
              replicaNumber: i + 1,
              note: 'No overlap-diarization counterpart found',
              versions: {
                multimodal: {
                  text: multimodalReplicas[i].text,
                  start: multimodalReplicas[i].start,
                  end: multimodalReplicas[i].end,
                  role: multimodalReplicas[i].role,
                  speaker: multimodalReplicas[i].speaker
                }
              },
              decision: {
                selectedText: multimodalReplicas[i].text,
                selectedSource: 'multimodal-diarization',
                decisionReason: 'No overlap-diarization counterpart available, using multimodal version'
              }
            });
          }
        }
        
        // –í–∏–≤–æ–¥–∏–º–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ textarea
        const formattedResult = JSON.stringify({
          totalReplicasAnalyzed: mergeResults.length,
          replicas: mergeResults,
          summary: {
            totalReplicas: mergeResults.length,
            analyzedReplicas: mergeResults.filter(r => r.analysis && !r.error && !r.note).length,
            errorReplicas: mergeResults.filter(r => r.error).length,
            replicasWithoutCounterpart: mergeResults.filter(r => r.note && r.note.includes('No overlap-diarization counterpart')).length,
            averageSimilarity: (() => {
              const validResults = mergeResults.filter(r => r.analysis && r.analysis.similarityScore !== undefined && r.analysis.similarityScore !== null);
              if (validResults.length === 0) return 0;
              const sum = validResults.reduce((acc, r) => acc + r.analysis.similarityScore, 0);
              return sum / validResults.length;
            })(),
            totalMatching: mergeResults.filter(r => r.decision && r.decision.isMatching === true).length,
            recommendations: {
              useA: mergeResults.filter(r => r.analysis && r.analysis.recommendation === 'use_A').length,
              useB: mergeResults.filter(r => r.analysis && r.analysis.recommendation === 'use_B').length,
              merge: mergeResults.filter(r => r.analysis && r.analysis.recommendation === 'merge').length
            }
          },
          note: `This is the merge analysis for all ${mergeResults.length} available replicas.`
        }, null, 2);
        resultEl.value = formattedResult;
        
        // –§–æ—Ä–º—É—î–º–æ –¥—ñ–∞–ª–æ–≥ —É —á–∏—Ç–∞–±–µ–ª—å–Ω–æ–º—É —Ñ–æ—Ä–º–∞—Ç—ñ
        const dialogueEl = document.getElementById('multimodalDialogue');
        if (dialogueEl) {
          const dialogueText = formatMergedDialogue(mergeResults);
          dialogueEl.value = dialogueText;
        }
        
        const validResults = mergeResults.filter(r => r.analysis && r.analysis.similarityScore !== undefined && r.analysis.similarityScore !== null);
        const avgSimilarity = validResults.length > 0 
          ? validResults.reduce((sum, r) => sum + r.analysis.similarityScore, 0) / validResults.length 
          : 0;
        statusEl.textContent = `‚úÖ Merge analysis completed! Analyzed ${validResults.length}/${mergeResults.length} replica(s), avg similarity: ${(avgSimilarity * 100).toFixed(1)}%`;
        statusEl.style.color = '#27ae60';
        
        console.log(`‚úÖ [MERGE] Merge analysis completed for ${mergeResults.length} replica(s):`, mergeResults);
        
      } catch (error) {
        console.error('‚ùå [MERGE] Error:', error);
        throw error;
      }
    }
    
    // –î–æ–ø–æ–º—ñ–∂–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—è –¥–ª—è –æ–±—á–∏—Å–ª–µ–Ω–Ω—è –ø–µ—Ä–µ—Ç–∏–Ω—É —Ç–∞–π–º—Å—Ç–µ–º–ø—ñ–≤
    function calculateTimeOverlap(startA, endA, startB, endB) {
      const overlapStart = Math.max(startA, startB);
      const overlapEnd = Math.min(endA, endB);
      const overlapDuration = Math.max(0, overlapEnd - overlapStart);
      
      const totalStart = Math.min(startA, startB);
      const totalEnd = Math.max(endA, endB);
      const totalDuration = totalEnd - totalStart;
      
      const overlapRatio = totalDuration > 0 ? overlapDuration / totalDuration : 0;
      
      return {
        overlapDuration,
        totalDuration,
        overlapRatio,
        overlapStart,
        overlapEnd
      };
    }
    
    // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è fallback –º–µ—Ç—á–∏–Ω–≥—É, –∫–æ–ª–∏ LLM –∞–Ω–∞–ª—ñ–∑ –Ω–µ–≤–∞–ª—ñ–¥–Ω–∏–π
    function fallbackMatching(multimodalReplica, overlapReplicas, replicaNumber) {
      console.log(`üîç [FALLBACK] Starting fallback matching for replica ${replicaNumber}...`);
      
      // –ó–Ω–∞—Ö–æ–¥–∏–º–æ –Ω–∞–π–∫—Ä–∞—â–∏–π –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–∏–∫ —Å–µ—Ä–µ–¥ overlap-—Ä–µ–ø–ª—ñ–∫
      let bestMatch = null;
      let bestScore = 0;
      
      for (const overlapReplica of overlapReplicas) {
        // –û–±—á–∏—Å–ª—é—î–º–æ –º–µ—Ç—Ä–∏–∫–∏
        const timeOverlap = calculateTimeOverlap(
          overlapReplica.start, overlapReplica.end,
          multimodalReplica.start, multimodalReplica.end
        );
        
        // –ê–ª–≥–æ—Ä–∏—Ç–º—ñ—á–Ω–∞ –æ—Ü—ñ–Ω–∫–∞ —Å—Ö–æ–∂–æ—Å—Ç—ñ —Ç–µ–∫—Å—Ç—É
        const textSimilarity = computeTextSimilarityFallback(
          overlapReplica.text,
          multimodalReplica.text
        );
        
        // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ —Ä–æ–ª–µ–π —Ç–∞ —Å–ø—ñ–∫–µ—Ä—ñ–≤
        const roleMatch = overlapReplica.role === multimodalReplica.role ? 1 : 0;
        const speakerMatch = overlapReplica.speaker === multimodalReplica.speaker ? 1 : 0;
        
        // –ö–æ–º–±—ñ–Ω–æ–≤–∞–Ω–∞ –æ—Ü—ñ–Ω–∫–∞ (–≤–∞–≥–∏: —Ç–µ–∫—Å—Ç 50%, —á–∞—Å 30%, —Ä–æ–ª—ñ 20%)
        const combinedScore = 
          (textSimilarity * 0.5) +
          (timeOverlap.overlapRatio * 0.3) +
          ((roleMatch + speakerMatch) / 2 * 0.2);
        
        if (combinedScore > bestScore) {
          bestScore = combinedScore;
          bestMatch = {
            overlap: overlapReplica,
            metrics: {
              textSimilarity,
              timeOverlap,
              roleMatch: roleMatch === 1,
              speakerMatch: speakerMatch === 1
            },
            combinedScore
          };
        }
      }
      
      // –í–∏–∑–Ω–∞—á–∞—î–º–æ, —á–∏ –∑–Ω–∞–π—à–ª–∏ –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–∏–∫
      const isMatching = bestMatch && bestScore >= 0.4; // –ü–æ—Ä—ñ–≥ –¥–ª—è fallback –Ω–∏–∂—á–∏–π
      
      let selectedText = '';
      let selectedSource = '';
      let decisionReason = '';
      
      if (isMatching && bestMatch) {
        // –ó–Ω–∞–π—à–ª–∏ –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–∏–∫ - –≤–∏–±–∏—Ä–∞—î–º–æ –Ω–∞ –æ—Å–Ω–æ–≤—ñ –º–µ—Ç—Ä–∏–∫
        if (bestMatch.metrics.textSimilarity >= 0.7 && bestMatch.metrics.roleMatch) {
          // –í–∏—Å–æ–∫–∞ —Ç–µ–∫—Å—Ç–æ–≤–∞ —Å—Ö–æ–∂—ñ—Å—Ç—å —ñ —Å–ø—ñ–≤–ø–∞–¥—ñ–Ω–Ω—è —Ä–æ–ª—ñ - –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ multimodal (Gemini –ø—Ä—ñ–æ—Ä–∏—Ç–µ—Ç)
          selectedText = multimodalReplica.text;
          selectedSource = 'multimodal-diarization';
          decisionReason = `Fallback: High text similarity (${(bestMatch.metrics.textSimilarity * 100).toFixed(1)}%), role match, using multimodal version (Gemini priority)`;
        } else if (bestMatch.metrics.textSimilarity >= 0.6) {
          // –°–µ—Ä–µ–¥–Ω—è —Ç–µ–∫—Å—Ç–æ–≤–∞ —Å—Ö–æ–∂—ñ—Å—Ç—å - –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ multimodal
          selectedText = multimodalReplica.text;
          selectedSource = 'multimodal-diarization';
          decisionReason = `Fallback: Moderate text similarity (${(bestMatch.metrics.textSimilarity * 100).toFixed(1)}%), using multimodal version`;
        } else {
          // –ù–∏–∑—å–∫–∞ —Å—Ö–æ–∂—ñ—Å—Ç—å - –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ multimodal —è–∫ fallback
          selectedText = multimodalReplica.text;
          selectedSource = 'multimodal-diarization';
          decisionReason = `Fallback: Low similarity (${(bestScore * 100).toFixed(1)}%), using multimodal version as default`;
        }
      } else {
        // –ù–µ –∑–Ω–∞–π—à–ª–∏ –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–∏–∫ - –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ multimodal
        selectedText = multimodalReplica.text;
        selectedSource = 'multimodal-diarization';
        decisionReason = `Fallback: No matching overlap replica found (best score: ${(bestScore * 100).toFixed(1)}%), using multimodal version`;
      }
      
      return {
        replicaNumber: replicaNumber,
        analysis: {
          similarityScore: bestMatch ? bestMatch.combinedScore : 0,
          explanation: `Fallback algorithmic matching: ${bestMatch ? `Found match with score ${(bestMatch.combinedScore * 100).toFixed(1)}%` : 'No match found'}`,
          confidence: bestMatch ? Math.min(0.7, bestMatch.combinedScore) : 0.3, // Fallback –º–∞—î –Ω–∏–∂—á—É –≤–ø–µ–≤–Ω–µ–Ω—ñ—Å—Ç—å
          recommendation: 'use_B', // –ó–∞–≤–∂–¥–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ multimodal –ø—Ä–∏ fallback
          fallbackUsed: true
        },
        metrics: bestMatch ? {
          timeOverlap: {
            overlapRatio: bestMatch.metrics.timeOverlap.overlapRatio,
            overlapDuration: bestMatch.metrics.timeOverlap.overlapDuration,
            totalDuration: bestMatch.metrics.timeOverlap.totalDuration
          },
          roleMatch: bestMatch.metrics.roleMatch,
          speakerMatch: bestMatch.metrics.speakerMatch,
          textSimilarity: bestMatch.metrics.textSimilarity
        } : {
          timeOverlap: { overlapRatio: 0, overlapDuration: 0, totalDuration: 0 },
          roleMatch: false,
          speakerMatch: false,
          textSimilarity: 0
        },
        versions: {
          overlap: bestMatch ? {
            text: bestMatch.overlap.text,
            start: bestMatch.overlap.start,
            end: bestMatch.overlap.end,
            role: bestMatch.overlap.role,
            speaker: bestMatch.overlap.speaker
          } : null,
          multimodal: {
            text: multimodalReplica.text,
            start: multimodalReplica.start,
            end: multimodalReplica.end,
            role: multimodalReplica.role,
            speaker: multimodalReplica.speaker
          }
        },
        decision: {
          isMatching: isMatching,
          selectedText: selectedText,
          selectedSource: selectedSource,
          decisionReason: decisionReason,
          similarityScore: bestMatch ? bestMatch.combinedScore : 0,
          llmConfidence: 0, // LLM –Ω–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞–≤—Å—è
          timeOverlapRatio: bestMatch ? bestMatch.metrics.timeOverlap.overlapRatio : 0
        },
        recommendedText: selectedText
      };
    }
    
    // –î–æ–ø–æ–º—ñ–∂–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—è –¥–ª—è –æ–±—á–∏—Å–ª–µ–Ω–Ω—è —Å—Ö–æ–∂–æ—Å—Ç—ñ —Ç–µ–∫—Å—Ç—É (fallback)
    // –ì–ª–æ–±–∞–ª—å–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—è –¥–ª—è –Ω–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—ó —Ç–µ–∫—Å—Ç—É –¥–ª—è –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è
    function normalizeTextForComparison(text) {
      return (text || '').trim().toLowerCase().replace(/\s+/g, ' ').replace(/[^\w\s]/g, '');
    }
    
    function computeTextSimilarityFallback(text1, text2) {
      if (!text1 || !text2) return 0;
      
      // –ù–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—è —Ç–µ–∫—Å—Ç—É
      const normalize = (text) => {
        return (text || '').trim().toLowerCase()
          .replace(/[^\w\s]/g, ' ')
          .replace(/\s+/g, ' ');
      };
      
      const norm1 = normalize(text1);
      const norm2 = normalize(text2);
      
      if (norm1 === norm2) return 1.0;
      if (!norm1 || !norm2) return 0;
      
      // Jaccard similarity –Ω–∞ —Å–ª–æ–≤–∞—Ö
      const words1 = new Set(norm1.split(/\s+/).filter(w => w.length > 0));
      const words2 = new Set(norm2.split(/\s+/).filter(w => w.length > 0));
      
      if (words1.size === 0 || words2.size === 0) return 0;
      
      const intersection = new Set([...words1].filter(w => words2.has(w)));
      const union = new Set([...words1, ...words2]);
      const jaccard = union.size > 0 ? intersection.size / union.size : 0;
      
      // Substring matching
      let substringScore = 0;
      if (norm1.includes(norm2) || norm2.includes(norm1)) {
        const ratio = Math.min(norm1.length, norm2.length) / Math.max(norm1.length, norm2.length);
        substringScore = ratio >= 0.7 ? 0.9 : ratio * 1.2;
      }
      
      // –ö–æ–º–±—ñ–Ω–æ–≤–∞–Ω–∞ –æ—Ü—ñ–Ω–∫–∞
      return Math.max(jaccard, substringScore, jaccard * 0.8 + substringScore * 0.2);
    }
    
    // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –ø—Ä–∏–π–Ω—è—Ç—Ç—è —Ä—ñ—à–µ–Ω–Ω—è –ø—Ä–æ –æ–±'—î–¥–Ω–∞–Ω–Ω—è
    function makeMergeDecision(overlapReplica, multimodalReplica, llmAnalysis, timeOverlap) {
      const similarityScore = llmAnalysis.similarityScore || 0;
      const llmConfidence = llmAnalysis.confidence || 0;
      const recommendation = llmAnalysis.recommendation || 'merge'; // –ó–º—ñ–Ω–∏–≤ default –Ω–∞ 'merge'
      
      // –í–∏–∑–Ω–∞—á–∞—î–º–æ, —á–∏ —Ä–µ–ø–ª—ñ–∫–∏ –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω—ñ –æ–¥–Ω–∞ –æ–¥–Ω—ñ–π (–Ω–∏–∂—á–∏–π –ø–æ—Ä—ñ–≥ –¥–ª—è –æ–±'—î–¥–Ω–∞–Ω–Ω—è)
      const isMatching = similarityScore >= 0.5 && timeOverlap.overlapRatio >= 0.2;
      
      let selectedText = '';
      let selectedSource = '';
      let decisionReason = '';
      
      // –í–ò–ö–û–†–ò–°–¢–û–í–£–Ñ–ú–û –¢–Ü–õ–¨–ö–ò LLM, –ë–ï–ó –ê–õ–ì–û–†–ò–¢–ú–Ü–ß–ù–û–ì–û –û–ë'–Ñ–î–ù–ê–ù–ù–Ø
      if (isMatching) {
        // –Ø–∫—â–æ LLM —Ä–µ–∫–æ–º–µ–Ω–¥—É—î –æ–±'—î–¥–Ω–∞–Ω–Ω—è
        if (recommendation === 'merge') {
          // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ recommendedText –≤—ñ–¥ LLM, —è–∫—â–æ –≤—ñ–Ω —î
          if (llmAnalysis.recommendedText && llmAnalysis.recommendedText.trim().length > 0) {
            selectedText = llmAnalysis.recommendedText;
            selectedSource = 'merged';
            decisionReason = 'LLM merged and corrected both versions';
            console.log(`‚úÖ [MERGE] Using LLM merged text:`, selectedText.substring(0, 80) + '...');
          } else {
            // LLM –Ω–µ –Ω–∞–¥–∞–ª–∞ recommendedText - –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ multimodal –≤–µ—Ä—Å—ñ—é (Gemini priority)
            selectedText = multimodalReplica.text;
            selectedSource = 'multimodal-diarization';
            decisionReason = `LLM recommended merge but didn't provide merged text. Using multimodal version (Gemini priority).`;
            console.log(`‚ö†Ô∏è [MERGE] LLM recommended merge but no merged text provided, using multimodal version`);
          }
        } else if (recommendation === 'use_A') {
          // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ overlap –≤–µ—Ä—Å—ñ—é
          selectedText = overlapReplica.text;
          selectedSource = 'overlap-diarization';
          decisionReason = 'LLM recommended using overlap-diarization version';
        } else if (recommendation === 'use_B') {
          // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ multimodal –≤–µ—Ä—Å—ñ—é
          selectedText = multimodalReplica.text;
          selectedSource = 'multimodal-diarization';
          decisionReason = 'LLM recommended using multimodal-diarization version';
        } else {
          // –ù–µ–≤—ñ–¥–æ–º–∞ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—è - –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ multimodal (Gemini priority)
          selectedText = multimodalReplica.text;
          selectedSource = 'multimodal-diarization';
          decisionReason = `Unknown LLM recommendation. Using multimodal version (Gemini priority).`;
        }
      } else {
        // –†–µ–ø–ª—ñ–∫–∏ –Ω–µ –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω—ñ - –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ multimodal (Gemini priority)
        selectedText = multimodalReplica.text;
        selectedSource = 'multimodal-diarization';
        decisionReason = `Replicas do not match (similarity: ${(similarityScore * 100).toFixed(1)}%, overlap: ${(timeOverlap.overlapRatio * 100).toFixed(1)}%). Using multimodal version.`;
      }
      
      return {
        isMatching,
        selectedText,
        selectedSource,
        decisionReason,
        similarityScore,
        llmConfidence,
        timeOverlapRatio: timeOverlap.overlapRatio
      };
    }
    
    // –î–æ–ø–æ–º—ñ–∂–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—è –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ–≥–æ –æ–±'—î–¥–Ω–∞–Ω–Ω—è —Ç–µ–∫—Å—Ç—ñ–≤ —Ä–µ–ø–ª—ñ–∫
    function mergeReplicasText(textA, textB) {
      if (!textA && !textB) return '';
      if (!textA) return textB;
      if (!textB) return textA;
      
      // –ù–æ—Ä–º–∞–ª—ñ–∑—É—î–º–æ —Ç–µ–∫—Å—Ç–∏ –¥–ª—è –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è
      const normalize = (text) => {
        return (text || '').trim().toLowerCase()
          .replace(/[^\w\s]/g, ' ')
          .replace(/\s+/g, ' ');
      };
      
      const normA = normalize(textA);
      const normB = normalize(textB);
      
      // –Ø–∫—â–æ —Ç–µ–∫—Å—Ç–∏ —ñ–¥–µ–Ω—Ç–∏—á–Ω—ñ - –ø–æ–≤–µ—Ä—Ç–∞—î–º–æ –æ–¥–∏–Ω (–∑ –∫—Ä–∞—â–æ—é –ø—É–Ω–∫—Ç—É–∞—Ü—ñ—î—é)
      if (normA === normB) {
        return textB.length > textA.length ? textB : textA; // –í—ñ–¥–¥–∞—î–º–æ –ø–µ—Ä–µ–≤–∞–≥—É –±—ñ–ª—å—à –¥–æ–≤–≥–æ–º—É (–∫—Ä–∞—â–∞ –ø—É–Ω–∫—Ç—É–∞—Ü—ñ—è)
      }
      
      // –Ø–∫—â–æ –æ–¥–∏–Ω —Ç–µ–∫—Å—Ç –º—ñ—Å—Ç–∏—Ç—å —ñ–Ω—à–∏–π - –ø–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ —î –¥–æ–¥–∞—Ç–∫–æ–≤–∏–π –∫–æ–Ω—Ç–µ–Ω—Ç
      if (normA.includes(normB)) {
        // textA –º—ñ—Å—Ç–∏—Ç—å textB - –ø–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ textA –º–∞—î –¥–æ–¥–∞—Ç–∫–æ–≤–∏–π –∫–æ–Ω—Ç–µ–Ω—Ç
        const wordsA = normA.split(/\s+/).filter(w => w.length > 0);
        const wordsB = normB.split(/\s+/).filter(w => w.length > 0);
        const uniqueInA = wordsA.filter(w => !wordsB.includes(w));
        if (uniqueInA.length > 2) {
          // textA –º–∞—î –∑–Ω–∞—á–Ω–∏–π –¥–æ–¥–∞—Ç–∫–æ–≤–∏–π –∫–æ–Ω—Ç–µ–Ω—Ç - –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ textA
          return textA;
        } else {
          // textA –º–∞–π–∂–µ —ñ–¥–µ–Ω—Ç–∏—á–Ω–∏–π textB - –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ textB (–∫—Ä–∞—â–∞ –ø—É–Ω–∫—Ç—É–∞—Ü—ñ—è)
          return textB;
        }
      }
      if (normB.includes(normA)) {
        // textB –º—ñ—Å—Ç–∏—Ç—å textA - –ø–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ textB –º–∞—î –¥–æ–¥–∞—Ç–∫–æ–≤–∏–π –∫–æ–Ω—Ç–µ–Ω—Ç
        const wordsA = normA.split(/\s+/).filter(w => w.length > 0);
        const wordsB = normB.split(/\s+/).filter(w => w.length > 0);
        const uniqueInB = wordsB.filter(w => !wordsA.includes(w));
        if (uniqueInB.length > 2) {
          // textB –º–∞—î –∑–Ω–∞—á–Ω–∏–π –¥–æ–¥–∞—Ç–∫–æ–≤–∏–π –∫–æ–Ω—Ç–µ–Ω—Ç - –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ textB
          return textB;
        } else {
          // textB –º–∞–π–∂–µ —ñ–¥–µ–Ω—Ç–∏—á–Ω–∏–π textA - –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ textA (–º–æ–∂–µ –º–∞—Ç–∏ overlap –∫–æ–Ω—Ç–µ–Ω—Ç)
          return textA;
        }
      }
      
      // –û–±'—î–¥–Ω—É—î–º–æ —É–Ω—ñ–∫–∞–ª—å–Ω—ñ —á–∞—Å—Ç–∏–Ω–∏
      const wordsA = new Set(normA.split(/\s+/).filter(w => w.length > 0));
      const wordsB = new Set(normB.split(/\s+/).filter(w => w.length > 0));
      
      // –ó–Ω–∞—Ö–æ–¥–∏–º–æ —É–Ω—ñ–∫–∞–ª—å–Ω—ñ —Å–ª–æ–≤–∞ –≤ –∫–æ–∂–Ω–æ–º—É —Ç–µ–∫—Å—Ç—ñ
      const uniqueInA = [...wordsA].filter(w => !wordsB.has(w));
      const uniqueInB = [...wordsB].filter(w => !wordsA.has(w));
      
      // –Ø–∫—â–æ —î —É–Ω—ñ–∫–∞–ª—å–Ω–∏–π –∫–æ–Ω—Ç–µ–Ω—Ç –≤ –æ–±–æ—Ö - –æ–±'—î–¥–Ω—É—î–º–æ
      // –ê–±–æ —è–∫—â–æ –æ–¥–∏–Ω —Ç–µ–∫—Å—Ç –∑–Ω–∞—á–Ω–æ –¥–æ–≤—à–∏–π –∑–∞ —ñ–Ω—à–∏–π (–º–æ–∂–µ –º—ñ—Å—Ç–∏—Ç–∏ –¥–æ–¥–∞—Ç–∫–æ–≤–∏–π –∫–æ–Ω—Ç–µ–Ω—Ç)
      const lengthRatio = Math.min(textA.length, textB.length) / Math.max(textA.length, textB.length);
      const hasSignificantDifference = lengthRatio < 0.7; // –û–¥–∏–Ω —Ç–µ–∫—Å—Ç –Ω–∞ 30%+ –¥–æ–≤—à–∏–π
      
      if (uniqueInA.length > 0 || uniqueInB.length > 0 || hasSignificantDifference) {
        // –°–ø—Ä–æ–±—É—î–º–æ –∑–Ω–∞–π—Ç–∏ —Å–ø—ñ–ª—å–Ω—É —á–∞—Å—Ç–∏–Ω—É –Ω–∞ –ø–æ—á–∞—Ç–∫—É/–∫—ñ–Ω—Ü—ñ
        const textAWords = textA.trim().split(/\s+/);
        const textBWords = textB.trim().split(/\s+/);
        
        // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ –æ–¥–∏–Ω —Ç–µ–∫—Å—Ç –ø—Ä–æ–¥–æ–≤–∂—É—î —ñ–Ω—à–∏–π (–±—ñ–ª—å—à –∞–≥—Ä–µ—Å–∏–≤–Ω–∏–π –ø–æ—à—É–∫)
        const maxOverlap = Math.min(textAWords.length, textBWords.length, 5);
        let startOverlap = 0;
        let endOverlap = 0;
        
        // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –Ω–∞ –ø–æ—á–∞—Ç–∫—É (–¥–æ 5 —Å–ª—ñ–≤)
        for (let i = 0; i < maxOverlap; i++) {
          if (i < textAWords.length && i < textBWords.length && 
              normalize(textAWords[i]) === normalize(textBWords[i])) {
            startOverlap++;
          } else {
            break;
          }
        }
        
        // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –≤ –∫—ñ–Ω—Ü—ñ (–¥–æ 5 —Å–ª—ñ–≤)
        for (let i = 0; i < maxOverlap; i++) {
          const idxA = textAWords.length - 1 - i;
          const idxB = textBWords.length - 1 - i;
          if (idxA >= 0 && idxB >= 0 && 
              normalize(textAWords[idxA]) === normalize(textBWords[idxB])) {
            endOverlap++;
          } else {
            break;
          }
        }
        
        // –Ø–∫—â–æ —î –ø–µ—Ä–µ—Ç–∏–Ω –Ω–∞ –ø–æ—á–∞—Ç–∫—É - textB –ø—Ä–æ–¥–æ–≤–∂—É—î textA
        if (startOverlap >= 2) {
          return textA.trim() + ' ' + textBWords.slice(startOverlap).join(' ');
        }
        
        // –Ø–∫—â–æ —î –ø–µ—Ä–µ—Ç–∏–Ω –≤ –∫—ñ–Ω—Ü—ñ - textB –ø–µ—Ä–µ–¥—É—î textA
        if (endOverlap >= 2) {
          return textBWords.slice(0, textBWords.length - endOverlap).join(' ') + ' ' + textA.trim();
        }
        
        // –Ø–∫—â–æ –Ω–µ–º–∞—î —è–≤–Ω–æ–≥–æ –ø–µ—Ä–µ—Ç–∏–Ω—É - –æ–±'—î–¥–Ω—É—î–º–æ —á–µ—Ä–µ–∑ –∫—Ä–∞–ø–∫—É, –∞–ª–µ —Å–ø–æ—á–∞—Ç–∫—É –ø–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —á–∏ —î —É–Ω—ñ–∫–∞–ª—å–Ω—ñ —á–∞—Å—Ç–∏–Ω–∏
        // –Ø–∫—â–æ –æ–¥–∏–Ω —Ç–µ–∫—Å—Ç –º–∞—î —É–Ω—ñ–∫–∞–ª—å–Ω—ñ —Å–ª–æ–≤–∞, —è–∫—ñ –≤—ñ–¥—Å—É—Ç–Ω—ñ –≤ —ñ–Ω—à–æ–º—É - –æ–±'—î–¥–Ω—É—î–º–æ
        if (uniqueInA.length > 0 && uniqueInB.length > 0) {
          // –û–±–∏–¥–≤–∞ –º–∞—é—Ç—å —É–Ω—ñ–∫–∞–ª—å–Ω–∏–π –∫–æ–Ω—Ç–µ–Ω—Ç - –æ–±'—î–¥–Ω—É—î–º–æ
          // –°–ø—Ä–æ–±—É—î–º–æ –∑–Ω–∞–π—Ç–∏, —è–∫–∏–π —Ç–µ–∫—Å—Ç –ø–æ—á–∏–Ω–∞—î—Ç—å—Å—è —Ä–∞–Ω—ñ—à–µ (–¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ –ø–æ—Ä—è–¥–∫—É)
          return textA.trim() + '. ' + textB.trim();
        } else if (uniqueInA.length > 0) {
          // textA –º–∞—î —É–Ω—ñ–∫–∞–ª—å–Ω–∏–π –∫–æ–Ω—Ç–µ–Ω—Ç - –¥–æ–¥–∞—î–º–æ –π–æ–≥–æ –¥–æ textB
          // –ó–Ω–∞—Ö–æ–¥–∏–º–æ —É–Ω—ñ–∫–∞–ª—å–Ω—ñ —Ñ—Ä–∞–∑–∏ –∑ textA
          const uniquePhrases = [];
          let currentPhrase = [];
          for (let i = 0; i < textAWords.length; i++) {
            const word = normalize(textAWords[i]);
            if (uniqueInA.includes(word)) {
              currentPhrase.push(textAWords[i]);
            } else {
              if (currentPhrase.length > 0) {
                uniquePhrases.push(currentPhrase.join(' '));
                currentPhrase = [];
              }
            }
          }
          if (currentPhrase.length > 0) {
            uniquePhrases.push(currentPhrase.join(' '));
          }
          
          if (uniquePhrases.length > 0) {
            return textB.trim() + '. ' + uniquePhrases.join('. ');
          } else {
            return textB.trim() + '. ' + textAWords.filter(w => uniqueInA.includes(normalize(w))).join(' ');
          }
        } else if (uniqueInB.length > 0) {
          // textB –º–∞—î —É–Ω—ñ–∫–∞–ª—å–Ω–∏–π –∫–æ–Ω—Ç–µ–Ω—Ç - –¥–æ–¥–∞—î–º–æ –π–æ–≥–æ –¥–æ textA
          // –ó–Ω–∞—Ö–æ–¥–∏–º–æ —É–Ω—ñ–∫–∞–ª—å–Ω—ñ —Ñ—Ä–∞–∑–∏ –∑ textB
          const uniquePhrases = [];
          let currentPhrase = [];
          for (let i = 0; i < textBWords.length; i++) {
            const word = normalize(textBWords[i]);
            if (uniqueInB.includes(word)) {
              currentPhrase.push(textBWords[i]);
            } else {
              if (currentPhrase.length > 0) {
                uniquePhrases.push(currentPhrase.join(' '));
                currentPhrase = [];
              }
            }
          }
          if (currentPhrase.length > 0) {
            uniquePhrases.push(currentPhrase.join(' '));
          }
          
          if (uniquePhrases.length > 0) {
            return textA.trim() + '. ' + uniquePhrases.join('. ');
          } else {
            return textA.trim() + '. ' + textBWords.filter(w => uniqueInB.includes(normalize(w))).join(' ');
          }
        }
      }
      
      // –Ø–∫—â–æ –æ–¥–∏–Ω —Ç–µ–∫—Å—Ç –º–∞–π–∂–µ –ø–æ–≤–Ω—ñ—Å—Ç—é –º—ñ—Å—Ç–∏—Ç—å—Å—è –≤ —ñ–Ω—à–æ–º—É - –ø–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –¥–æ–≤–∂–∏–Ω—É
      const overlapRatio = [...wordsA].filter(w => wordsB.has(w)).length / Math.max(wordsA.size, wordsB.size);
      if (overlapRatio > 0.7) {
        // –í–∏—Å–æ–∫–∏–π –ø–µ—Ä–µ—Ç–∏–Ω - –≤–∏–±–∏—Ä–∞—î–º–æ –±—ñ–ª—å—à –ø–æ–≤–Ω–∏–π –∞–±–æ –∑ –∫—Ä–∞—â–æ—é –ø—É–Ω–∫—Ç—É–∞—Ü—ñ—î—é
        // –ê–ª–µ —è–∫—â–æ –æ–¥–∏–Ω –∑–Ω–∞—á–Ω–æ –¥–æ–≤—à–∏–π - –æ–±'—î–¥–Ω—É—î–º–æ
        const lengthDiff = Math.abs(textA.length - textB.length);
        const avgLength = (textA.length + textB.length) / 2;
        if (lengthDiff > avgLength * 0.2) {
          // –ó–Ω–∞—á–Ω–∞ —Ä—ñ–∑–Ω–∏—Ü—è –≤ –¥–æ–≤–∂–∏–Ω—ñ - –æ–±'—î–¥–Ω—É—î–º–æ
          return textA.length > textB.length 
            ? textA.trim() + '. ' + textB.trim()
            : textB.trim() + '. ' + textA.trim();
        }
        return textA.length > textB.length ? textA : textB;
      }
      
      // –ó–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º - –æ–±'—î–¥–Ω—É—î–º–æ —á–µ—Ä–µ–∑ –∫—Ä–∞–ø–∫—É (–∑–∞–≤–∂–¥–∏ –æ–±'—î–¥–Ω—É—î–º–æ, —è–∫—â–æ –¥–æ—Å—è–≥–ª–∏ —Ü—å–æ–≥–æ –∫—Ä–æ–∫—É)
      return textA.trim() + '. ' + textB.trim();
    }
    
    // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è —Ñ–æ—Ä–º–∞—Ç—É–≤–∞–Ω–Ω—è –æ–±'—î–¥–Ω–∞–Ω–æ–≥–æ –¥—ñ–∞–ª–æ–≥—É —É —á–∏—Ç–∞–±–µ–ª—å–Ω–∏–π —Ñ–æ—Ä–º–∞—Ç
    function formatMergedDialogue(mergeResults) {
      if (!mergeResults || mergeResults.length === 0) {
        return 'No replicas to display.';
      }
      
      // –ó–±–∏—Ä–∞—î–º–æ –≤—Å—ñ —Ä–µ–ø–ª—ñ–∫–∏ –∑ —Ä—ñ—à–µ–Ω–Ω—è–º–∏
      const dialogueLines = [];
      
      mergeResults.forEach((result, index) => {
        if (!result.decision || !result.decision.selectedText) {
          return; // –ü—Ä–æ–ø—É—Å–∫–∞—î–º–æ —Ä–µ–ø–ª—ñ–∫–∏ –±–µ–∑ —Ä—ñ—à–µ–Ω–Ω—è
        }
        
        const selectedText = result.decision.selectedText;
        const selectedSource = result.decision.selectedSource;
        
        // –í–∏–∑–Ω–∞—á–∞—î–º–æ —Å–ø—ñ–∫–µ—Ä–∞ —Ç–∞ —Ä–æ–ª—å
        let speaker = 'UNKNOWN';
        let role = 'unknown';
        
        if (result.versions) {
          if (selectedSource === 'merged' || selectedSource === 'overlap-diarization') {
            speaker = result.versions.overlap?.speaker || result.versions.multimodal?.speaker || 'UNKNOWN';
            role = result.versions.overlap?.role || result.versions.multimodal?.role || 'unknown';
          } else if (selectedSource === 'multimodal-diarization') {
            speaker = result.versions.multimodal?.speaker || 'UNKNOWN';
            role = result.versions.multimodal?.role || 'unknown';
          }
        }
        
        // –í–∏–∑–Ω–∞—á–∞—î–º–æ —Ç–∞–π–º—Å—Ç–µ–º–ø–∏
        // –î–ª—è –æ–±'—î–¥–Ω–∞–Ω–∏—Ö —Ä–µ–ø–ª—ñ–∫ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –Ω–∞–π—Ä–∞–Ω—ñ—à–∏–π start —ñ –Ω–∞–π–ø—ñ–∑–Ω—ñ—à–∏–π end
        let start = null;
        let end = null;
        
        if (result.versions) {
          if (selectedSource === 'merged') {
            // –î–ª—è –æ–±'—î–¥–Ω–∞–Ω–∏—Ö - –±–µ—Ä–µ–º–æ –Ω–∞–π—à–∏—Ä—à–∏–π –¥—ñ–∞–ø–∞–∑–æ–Ω
            const overlapStart = result.versions.overlap?.start;
            const overlapEnd = result.versions.overlap?.end;
            const multimodalStart = result.versions.multimodal?.start;
            const multimodalEnd = result.versions.multimodal?.end;
            
            if (overlapStart !== null && overlapStart !== undefined && multimodalStart !== null && multimodalStart !== undefined) {
              start = Math.min(overlapStart, multimodalStart);
            } else {
              start = overlapStart !== null && overlapStart !== undefined ? overlapStart : multimodalStart;
            }
            
            if (overlapEnd !== null && overlapEnd !== undefined && multimodalEnd !== null && multimodalEnd !== undefined) {
              end = Math.max(overlapEnd, multimodalEnd);
            } else {
              end = overlapEnd !== null && overlapEnd !== undefined ? overlapEnd : multimodalEnd;
            }
          } else if (selectedSource === 'overlap-diarization') {
            start = result.versions.overlap?.start;
            end = result.versions.overlap?.end;
          } else if (selectedSource === 'multimodal-diarization') {
            start = result.versions.multimodal?.start;
            end = result.versions.multimodal?.end;
          }
          
          // –Ø–∫—â–æ —Ç–∞–π–º—Å—Ç–µ–º–ø–∏ –≤—ñ–¥—Å—É—Ç–Ω—ñ, –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –∑ —ñ–Ω—à–æ—ó –≤–µ—Ä—Å—ñ—ó
          if (start === null || start === undefined) {
            start = result.versions.multimodal?.start || result.versions.overlap?.start;
          }
          if (end === null || end === undefined) {
            end = result.versions.multimodal?.end || result.versions.overlap?.end;
          }
        }
        
        // –§–æ—Ä–º–∞—Ç—É—î–º–æ —Ä–æ–ª—å –¥–ª—è –≤—ñ–¥–æ–±—Ä–∞–∂–µ–Ω–Ω—è
        const roleDisplay = role === 'operator' ? 'Agent' : 
                           role === 'client' ? 'Client' : 
                           role === 'agent' ? 'Agent' : 
                           role === 'customer' ? 'Client' : 
                           'Unknown';
        
        // –§–æ—Ä–º–∞—Ç—É—î–º–æ —Ç–∞–π–º—Å—Ç–µ–º–ø–∏
        const timeDisplay = (start !== null && start !== undefined && end !== null && end !== undefined)
          ? `[${start.toFixed(2)}s - ${end.toFixed(2)}s]`
          : '[time unknown]';
        
        // –§–æ—Ä–º—É—î–º–æ —Ä—è–¥–æ–∫ –¥—ñ–∞–ª–æ–≥—É
        const line = `${roleDisplay} (${speaker}): ${selectedText} ${timeDisplay}`;
        dialogueLines.push({
          line: line,
          start: start !== null && start !== undefined ? start : 999999,
          replicaNumber: result.replicaNumber || index + 1
        });
      });
      
      // –°–æ—Ä—Ç—É—î–º–æ –∑–∞ —á–∞—Å–æ–º –ø–æ—á–∞—Ç–∫—É
      dialogueLines.sort((a, b) => a.start - b.start);
      
      // –§–æ—Ä–º—É—î–º–æ —Ñ—ñ–Ω–∞–ª—å–Ω–∏–π —Ç–µ–∫—Å—Ç
      const dialogueText = dialogueLines.map((item, idx) => {
        return `${idx + 1}. ${item.line}`;
      }).join('\n\n');
      
      return dialogueText || 'No dialogue lines to display.';
    }
    
    function copyMultimodalResult() {
      const resultEl = document.getElementById('multimodalResult');
      const dialogueEl = document.getElementById('multimodalDialogue');
      const resultText = resultEl.value;
      const dialogueText = dialogueEl ? dialogueEl.value : '';
      
      // –ö–æ–ø—ñ—é—î–º–æ –æ–±–∏–¥–≤–∞ —Ç–µ–∫—Å—Ç–∏
      const combinedText = dialogueText 
        ? `=== Merged Dialogue ===\n\n${dialogueText}\n\n=== Full JSON Result ===\n\n${resultText}`
        : resultText;
      
      if (!combinedText || combinedText.trim() === '') {
        alert('‚ö†Ô∏è No result to copy.');
        return;
      }
      
      navigator.clipboard.writeText(combinedText).then(() => {
        console.log('‚úÖ [MULTIMODAL] Result and dialogue copied to clipboard');
        alert('‚úÖ Result and dialogue copied to clipboard!');
      }).catch(err => {
        console.error('‚ùå [MULTIMODAL] Failed to copy:', err);
        // Fallback
        const tempTextarea = document.createElement('textarea');
        tempTextarea.value = combinedText;
        tempTextarea.style.position = 'fixed';
        tempTextarea.style.opacity = '0';
        document.body.appendChild(tempTextarea);
        tempTextarea.select();
        document.execCommand('copy');
        document.body.removeChild(tempTextarea);
        alert('‚úÖ Result and dialogue copied to clipboard!');
      });
    }
    
    async function applyMultimodalResults() {
      const resultEl = document.getElementById('multimodalResult');
      if (!resultEl || !resultEl.value || resultEl.value.trim() === '') {
        alert('‚ö†Ô∏è No multimodal results to apply. Please run the analysis first.');
        return;
      }
      
      try {
        // –ü–∞—Ä—Å–∏–º–æ JSON –∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤
        let mergeData = null;
        try {
          const jsonText = resultEl.value.trim();
          const jsonMatch = jsonText.match(/```(?:json)?\s*(\{[\s\S]*\})\s*```/);
          mergeData = JSON.parse(jsonMatch ? jsonMatch[1] : jsonText);
        } catch (parseError) {
          console.error('‚ùå [APPLY MULTIMODAL] Failed to parse JSON:', parseError);
          alert('‚ùå Failed to parse multimodal results. Please check the JSON format.');
          return;
        }
        
        if (!mergeData || !mergeData.replicas || !Array.isArray(mergeData.replicas)) {
          alert('‚ö†Ô∏è Invalid multimodal results format. Expected "replicas" array.');
          return;
        }
        
        console.log(`üîÑ [APPLY MULTIMODAL] Applying ${mergeData.replicas.length} merged replicas...`);
        
        // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ —î window.currentTable
        if (!window.currentTable || !Array.isArray(window.currentTable) || window.currentTable.length === 0) {
          alert('‚ö†Ô∏è No current table found. Please run "Analyze Dialogue" first.');
          return;
        }
        
        // –°—Ç–≤–æ—Ä—é—î–º–æ –Ω–æ–≤–∏–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–∏—Ö –Ω–∞ –æ—Å–Ω–æ–≤—ñ –æ–±'—î–¥–Ω–∞–Ω–∏—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤
        // –ì—Ä—É–ø—É—î–º–æ —Ä–µ–ø–ª—ñ–∫–∏ –∑–∞ —Ä–æ–ª—è–º–∏ —Ç–∞ —Å—Ç–≤–æ—Ä—é—î–º–æ —Å—Ç—Ä—É–∫—Ç—É—Ä—É, –ø–æ–¥—ñ–±–Ω—É –¥–æ window.currentTable
        const mergedTracks = {};
        
        console.log(`üîç [APPLY MULTIMODAL] Processing ${mergeData.replicas.length} replicas...`);
        
        mergeData.replicas.forEach((replica, idx) => {
          // –û–±—Ä–æ–±–ª—è—î–º–æ —Ä–µ–ø–ª—ñ–∫–∏ –∑ decision.selectedText –∞–±–æ —Ä–µ–ø–ª—ñ–∫–∏ –±–µ–∑ overlap counterpart
          let selectedText = null;
          let selectedSource = null;
          let role = null;
          let speaker = null;
          
          if (replica.decision && replica.decision.selectedText) {
            // –ó–≤–∏—á–∞–π–Ω–∞ —Ä–µ–ø–ª—ñ–∫–∞ –∑ —Ä—ñ—à–µ–Ω–Ω—è–º
            selectedText = replica.decision.selectedText;
            selectedSource = replica.decision.selectedSource;
            
            // –í–∏–∑–Ω–∞—á–∞—î–º–æ —Ä–æ–ª—å: –ø–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ —Ä–æ–ª—ñ —Å–ø—ñ–≤–ø–∞–¥–∞—é—Ç—å
            const overlapRole = replica.versions?.overlap?.role;
            const multimodalRole = replica.versions?.multimodal?.role;
            const roleMatch = overlapRole === multimodalRole;
            
            // –Ø–∫—â–æ —Ä–æ–ª—ñ —Å–ø—ñ–≤–ø–∞–¥–∞—é—Ç—å, –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ —ó—Ö
            // –Ø–∫—â–æ –Ω–µ —Å–ø—ñ–≤–ø–∞–¥–∞—é—Ç—å, –ø—Ä—ñ–æ—Ä–∏—Ç–µ—Ç overlap-–¥—ñ–∞—Ä–∏–∑–∞—Ü—ñ—ó (–≤–æ–Ω–∞ –∑–∞–∑–≤–∏—á–∞–π —Ç–æ—á–Ω—ñ—à–∞ –¥–ª—è —Ä–æ–ª–µ–π)
            // –ê–ª–µ —è–∫—â–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è merged —Ç–µ–∫—Å—Ç, –ø–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –º–µ—Ç—Ä–∏–∫–∏
            if (roleMatch) {
              role = overlapRole || multimodalRole || 'unknown';
            } else {
              // –†–æ–ª—ñ –Ω–µ —Å–ø—ñ–≤–ø–∞–¥–∞—é—Ç—å - –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ —Ä–æ–ª—å –∑ –¥–∂–µ—Ä–µ–ª–∞, —è–∫–µ –º–∞—î –±—ñ–ª—å—à—É –≤–ø–µ–≤–Ω–µ–Ω—ñ—Å—Ç—å
              // –ê–±–æ –ø—Ä—ñ–æ—Ä–∏—Ç–µ—Ç overlap, —è–∫—â–æ –≤—ñ–Ω —î
              if (selectedSource === 'merged') {
                // –î–ª—è merged: –ø–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –º–µ—Ç—Ä–∏–∫–∏
                const hasRoleMatch = replica.metrics?.roleMatch;
                if (hasRoleMatch === false && overlapRole) {
                  // –Ø–∫—â–æ —Ä–æ–ª—ñ –Ω–µ —Å–ø—ñ–≤–ø–∞–¥–∞—é—Ç—å, –∞–ª–µ overlap —Ä–æ–ª—å —î - –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ —ó—ó
                  role = overlapRole;
                } else if (multimodalRole) {
                  // –Ü–Ω–∞–∫—à–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ multimodal —Ä–æ–ª—å
                  role = multimodalRole;
                } else {
                  role = overlapRole || 'unknown';
                }
              } else if (selectedSource === 'overlap-diarization') {
                role = overlapRole || multimodalRole || 'unknown';
              } else {
                // –î–ª—è multimodal-diarization: –ø–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ overlap —Ä–æ–ª—å —î —ñ —á–∏ –≤–æ–Ω–∞ –±—ñ–ª—å—à –Ω–∞–¥—ñ–π–Ω–∞
                role = overlapRole || multimodalRole || 'unknown';
              }
            }
            
            // –í–∏–∑–Ω–∞—á–∞—î–º–æ —Å–ø—ñ–∫–µ—Ä–∞ –∞–Ω–∞–ª–æ–≥—ñ—á–Ω–æ
            const overlapSpeaker = replica.versions?.overlap?.speaker;
            const multimodalSpeaker = replica.versions?.multimodal?.speaker;
            const speakerMatch = overlapSpeaker === multimodalSpeaker;
            
            if (speakerMatch) {
              speaker = overlapSpeaker || multimodalSpeaker || 'SPEAKER_00';
            } else {
              // –Ø–∫—â–æ —Å–ø—ñ–∫–µ—Ä–∏ –Ω–µ —Å–ø—ñ–≤–ø–∞–¥–∞—é—Ç—å, –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ —Å–ø—ñ–∫–µ—Ä–∞ –∑ overlap (—Ç–æ—á–Ω—ñ—à–∏–π)
              speaker = overlapSpeaker || multimodalSpeaker || 'SPEAKER_00';
            }
          } else if (replica.note && replica.note.includes('No overlap-diarization counterpart')) {
            // –†–µ–ø–ª—ñ–∫–∞ –±–µ–∑ overlap counterpart - –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ multimodal –≤–µ—Ä—Å—ñ—é
            selectedText = replica.versions?.multimodal?.text || '';
            selectedSource = 'multimodal-diarization';
            role = replica.versions?.multimodal?.role || 'unknown';
            speaker = replica.versions?.multimodal?.speaker || 'SPEAKER_00';
          } else {
            console.log(`‚ö†Ô∏è [APPLY MULTIMODAL] Replica ${idx + 1} skipped: no valid data`, replica);
            return;
          }
          
          if (!selectedText || selectedText.trim() === '') {
            console.log(`‚ö†Ô∏è [APPLY MULTIMODAL] Replica ${idx + 1} skipped: empty text`);
            return;
          }
          
          console.log(`üîç [APPLY MULTIMODAL] Replica ${idx + 1}: role=${role}, speaker=${speaker}, text="${selectedText.substring(0, 50)}..."`);
          
          // –í–∏–∑–Ω–∞—á–∞—î–º–æ dialogueType –Ω–∞ –æ—Å–Ω–æ–≤—ñ —Ä–æ–ª—ñ
          const dialogueType = role === 'operator' || role === 'agent' ? 'agent' : 
                              role === 'client' || role === 'customer' ? 'client' : 'unknown';
          
          // –í–∏–∑–Ω–∞—á–∞—î–º–æ dialogueNumber –Ω–∞ –æ—Å–Ω–æ–≤—ñ —Å–ø—ñ–∫–µ—Ä–∞ (SPEAKER_00 -> 0, SPEAKER_01 -> 1)
          const dialogueNumber = speaker === 'SPEAKER_01' ? 1 : 0;
          
          if (!mergedTracks[dialogueNumber]) {
            mergedTracks[dialogueNumber] = {
              dialogueNumber: dialogueNumber,
              dialogueType: dialogueType,
              dialogueAnalysis: []
            };
            console.log(`üìä [APPLY MULTIMODAL] Created track ${dialogueNumber} with type ${dialogueType}`);
          }
          
          // –í–∏–∑–Ω–∞—á–∞—î–º–æ start —Ç–∞ end –∑ –≤–µ—Ä—Å—ñ–π
          let start = null;
          let end = null;
          if (selectedSource === 'merged' && replica.versions?.overlap && replica.versions?.multimodal) {
            start = Math.min(replica.versions.overlap.start || Infinity, replica.versions.multimodal.start || Infinity);
            end = Math.max(replica.versions.overlap.end || 0, replica.versions.multimodal.end || 0);
          } else if (selectedSource === 'overlap-diarization' && replica.versions?.overlap) {
            start = replica.versions.overlap.start;
            end = replica.versions.overlap.end;
          } else if (selectedSource === 'multimodal-diarization' && replica.versions?.multimodal) {
            start = replica.versions.multimodal.start;
            end = replica.versions.multimodal.end;
          } else if (replica.versions?.multimodal) {
            // Fallback: –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ multimodal –≤–µ—Ä—Å—ñ—é
            start = replica.versions.multimodal.start;
            end = replica.versions.multimodal.end;
          } else if (replica.versions?.overlap) {
            // Fallback: –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ overlap –≤–µ—Ä—Å—ñ—é
            start = replica.versions.overlap.start;
            end = replica.versions.overlap.end;
          }
          
          const fragmentRole = role === 'operator' || role === 'agent' ? 'agent' : 'client';
          
          mergedTracks[dialogueNumber].dialogueAnalysis.push({
            fragmentNumber: mergedTracks[dialogueNumber].dialogueAnalysis.length + 1,
            fragment: selectedText,
            role: fragmentRole,
            start: start,
            end: end
          });
          
          console.log(`‚úÖ [APPLY MULTIMODAL] Added fragment to track ${dialogueNumber}: "${selectedText.substring(0, 30)}..." (${start}s - ${end}s)`);
        });
        
        // –°–æ—Ä—Ç—É—î–º–æ —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∏ –∑–∞ —á–∞—Å–æ–º –ø–æ—á–∞—Ç–∫—É
        Object.values(mergedTracks).forEach(track => {
          track.dialogueAnalysis.sort((a, b) => (a.start || 0) - (b.start || 0));
          // –ü–µ—Ä–µ—ñ–Ω–¥–µ–∫—Å—É—î–º–æ fragmentNumber
          track.dialogueAnalysis.forEach((frag, idx) => {
            frag.fragmentNumber = idx + 1;
          });
        });
        
        // –ö–æ–Ω–≤–µ—Ä—Ç—É—î–º–æ –≤ –º–∞—Å–∏–≤
        const newTable = Object.values(mergedTracks).sort((a, b) => a.dialogueNumber - b.dialogueNumber);
        
        console.log(`üìä [APPLY MULTIMODAL] Created ${newTable.length} tracks:`, newTable.map(t => ({
          dialogueNumber: t.dialogueNumber,
          dialogueType: t.dialogueType,
          fragmentsCount: t.dialogueAnalysis.length
        })));
        
        if (newTable.length === 0) {
          throw new Error('No tracks created from merged replicas. Check replica data format.');
        }
        
        // –û–Ω–æ–≤–ª—é—î–º–æ window.currentTable
        window.currentTable = newTable;
        console.log('‚úÖ [APPLY MULTIMODAL] Updated window.currentTable:', newTable);
        
        // –û–Ω–æ–≤–ª—é—î–º–æ debugTextarea, —è–∫—â–æ –≤—ñ–Ω —ñ—Å–Ω—É—î, —â–æ–± applyDebugMarkup –º—ñ–≥ –π–æ–≥–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞—Ç–∏
        const debugTextarea = document.getElementById('debugTextarea');
        if (debugTextarea) {
          debugTextarea.value = JSON.stringify(newTable, null, 2);
          console.log('‚úÖ [APPLY MULTIMODAL] Updated debugTextarea with new data');
        } else {
          console.warn('‚ö†Ô∏è [APPLY MULTIMODAL] debugTextarea not found');
        }
        
        // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ —Å—Ç–∞–Ω –ø—ñ—Å–ª—è –∑–∞—Å—Ç–æ—Å—É–≤–∞–Ω–Ω—è multimodal —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤
        if (currentAnalysisData) {
          savePageState(currentAnalysisData);
          console.log('üíæ [APPLY MULTIMODAL] State saved after applying multimodal results');
        }
        
        // –í–∏–∫–ª–∏–∫–∞—î–º–æ applyDebugMarkup –¥–ª—è –æ–Ω–æ–≤–ª–µ–Ω–Ω—è —Ç–∞–±–ª–∏—Ü—ñ
        // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ autoRun=true, —â–æ–± –≤—ñ–Ω –º—ñ–≥ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞—Ç–∏ window.currentTable —è–∫—â–æ debugTextarea –Ω–µ –ø—ñ–¥—Ö–æ–¥–∏—Ç—å
        console.log('üîÑ [APPLY MULTIMODAL] Calling applyDebugMarkup...');
        await applyDebugMarkup(true);
        console.log('‚úÖ [APPLY MULTIMODAL] applyDebugMarkup completed');
        
        console.log('‚úÖ [APPLY MULTIMODAL] Table updated successfully');
        alert('‚úÖ Multimodal results applied to table successfully!');
        
        // –ó–∞–∫—Ä–∏–≤–∞—î–º–æ –º–æ–¥–∞–ª—å–Ω–µ –≤—ñ–∫–Ω–æ
        closeMultimodalModal();
        
      } catch (error) {
        console.error('‚ùå [APPLY MULTIMODAL] Error applying results:', error);
        alert(`‚ùå Failed to apply multimodal results: ${error.message}`);
      }
    }
    
    // –§—É–Ω–∫—Ü—ñ—ó –¥–ª—è —Ä–æ–±–æ—Ç–∏ –∑ Global Variables Modal
    function showGlobalVariablesModal() {
      const modal = document.getElementById('globalVariablesModal');
      const textarea = document.getElementById('globalVariablesCurrentTable');
      
      // Refresh the content
      refreshGlobalVariables();
      
      modal.style.display = 'flex';
    }
    
    function closeGlobalVariablesModal() {
      document.getElementById('globalVariablesModal').style.display = 'none';
    }
    
    function refreshGlobalVariables() {
      const textarea = document.getElementById('globalVariablesCurrentTable');
      
      if (!textarea) {
        console.error('‚ùå [GLOBAL_VARS] Textarea not found');
        return;
      }
      
      if (window.currentTable === null || window.currentTable === undefined) {
        textarea.value = '// Current Table is not set yet.\n// Run "Analyze Dialogue" and click "Apply" to populate this variable.';
        console.log('‚ÑπÔ∏è [GLOBAL_VARS] currentTable is not set');
        return;
      }
      
      try {
        // Format as JSON
        const formattedJSON = JSON.stringify(window.currentTable, null, 2);
        textarea.value = formattedJSON;
        console.log('‚úÖ [GLOBAL_VARS] Refreshed currentTable:', {
          tracksCount: Array.isArray(window.currentTable) ? window.currentTable.length : 0,
          isArray: Array.isArray(window.currentTable)
        });
      } catch (error) {
        console.error('‚ùå [GLOBAL_VARS] Error formatting currentTable:', error);
        textarea.value = `// Error formatting currentTable:\n// ${error.message}\n\n// Raw value:\n${String(window.currentTable)}`;
      }
    }
    
    function copyGlobalVariable() {
      const textarea = document.getElementById('globalVariablesCurrentTable');
      const text = textarea.value;
      
      if (!text || text.trim() === '' || text.trim().startsWith('//')) {
        alert('‚ö†Ô∏è No data to copy. Current Table is not set yet.');
        return;
      }
      
      navigator.clipboard.writeText(text).then(() => {
        console.log('‚úÖ [GLOBAL_VARS] Current Table copied to clipboard');
        alert('‚úÖ Current Table copied to clipboard!');
      }).catch(err => {
        console.error('‚ùå [GLOBAL_VARS] Failed to copy:', err);
        // Fallback
        const tempTextarea = document.createElement('textarea');
        tempTextarea.value = text;
        tempTextarea.style.position = 'fixed';
        tempTextarea.style.opacity = '0';
        document.body.appendChild(tempTextarea);
        tempTextarea.select();
        document.execCommand('copy');
        document.body.removeChild(tempTextarea);
        alert('‚úÖ Current Table copied to clipboard!');
      });
    }
    
    // –§—É–Ω–∫—Ü—ñ—ó –¥–ª—è —Ä–æ–±–æ—Ç–∏ –∑ Generator Modal
    async function showGeneratorModal() {
      const modal = document.getElementById('generatorModal');
      const generatorContent = document.getElementById('generatorContent');
      
      if (modal) {
        modal.style.display = 'flex';
        
        // –ó–∞–≤–∞–Ω—Ç–∞–∂—É—î–º–æ –∫–æ–Ω—Ç–µ–Ω—Ç –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞ –±–µ–∑–ø–æ—Å–µ—Ä–µ–¥–Ω—å–æ, —è–∫—â–æ —â–µ –Ω–µ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ
        if (generatorContent && !generatorContent.dataset.loaded) {
          try {
            generatorContent.innerHTML = '<p style="text-align: center; padding: 20px;">–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞...</p>';
            const response = await fetch('/audio-generator');
            if (response.ok) {
              const html = await response.text();
              // –í–∏—Ç—è–≥—É—î–º–æ —Ç—ñ–ª—å–∫–∏ body –∫–æ–Ω—Ç–µ–Ω—Ç (–±–µ–∑ DOCTYPE, html, head —Ç–µ–≥—ñ–≤)
              const parser = new DOMParser();
              const doc = parser.parseFromString(html, 'text/html');
              const bodyContent = doc.body.innerHTML;
              const headContent = doc.head.innerHTML;
              
              // –í—Å—Ç–∞–≤–ª—è—î–º–æ —Å—Ç–∏–ª—ñ –∑ head
              const styleContainer = document.createElement('div');
              styleContainer.innerHTML = headContent;
              const styles = styleContainer.querySelectorAll('style');
              styles.forEach(style => {
                const existingStyle = document.head.querySelector(`style[data-generator-style]`);
                if (!existingStyle) {
                  const newStyle = document.createElement('style');
                  newStyle.setAttribute('data-generator-style', 'true');
                  newStyle.textContent = style.textContent;
                  document.head.appendChild(newStyle);
                }
              });
              
              // –í—Å—Ç–∞–≤–ª—è—î–º–æ body –∫–æ–Ω—Ç–µ–Ω—Ç
              generatorContent.innerHTML = bodyContent;
              
              // –í–∏–∫–æ–Ω—É—î–º–æ —Å–∫—Ä–∏–ø—Ç–∏ –∑ body - —Å–ø–æ—á–∞—Ç–∫—É –∑–±–µ—Ä—ñ–≥–∞—î–º–æ —ó—Ö, –ø–æ—Ç—ñ–º –≤–∏–∫–æ–Ω—É—î–º–æ
              const scripts = Array.from(doc.body.querySelectorAll('script'));
              const scriptPromises = [];
              
              scripts.forEach((oldScript, index) => {
                try {
                  const newScript = document.createElement('script');
                  if (oldScript.src) {
                    newScript.src = oldScript.src;
                    const promise = new Promise((resolve, reject) => {
                      newScript.onload = resolve;
                      newScript.onerror = (err) => {
                        console.warn(`‚ö†Ô∏è Script ${index} (${oldScript.src}) failed to load:`, err);
                        reject(err);
                      };
                    });
                    scriptPromises.push(promise);
                    // –î–æ–¥–∞—î–º–æ —Å–∫—Ä–∏–ø—Ç –≤ –∫—ñ–Ω–µ—Ü—å generatorContent
                    try {
                      generatorContent.appendChild(newScript);
                    } catch (appendError) {
                      console.error(`Error appending script ${index} (external):`, appendError);
                      scriptPromises.pop(); // –í–∏–¥–∞–ª—è—î–º–æ promise, —è–∫—â–æ –Ω–µ –≤–¥–∞–ª–æ—Å—è –¥–æ–¥–∞—Ç–∏
                    }
                  } else {
                    // –î–ª—è inline —Å–∫—Ä–∏–ø—Ç—ñ–≤ –≤–∏–∫–æ–Ω—É—î–º–æ —ó—Ö –Ω–∞–ø—Ä—è–º—É, –∞ –Ω–µ —á–µ—Ä–µ–∑ appendChild
                    // —â–æ–± —É–Ω–∏–∫–Ω—É—Ç–∏ –ø–æ–º–∏–ª–æ–∫ –≤–∏–∫–æ–Ω–∞–Ω–Ω—è –ø—ñ–¥ —á–∞—Å –¥–æ–¥–∞–≤–∞–Ω–Ω—è
                    const scriptText = oldScript.textContent || '';
                    if (scriptText.trim()) {
                      try {
                        // –í–∏–∫–æ–Ω—É—î–º–æ —Å–∫—Ä–∏–ø—Ç –≤ –≥–ª–æ–±–∞–ª—å–Ω–æ–º—É –∫–æ–Ω—Ç–µ–∫—Å—Ç—ñ
                        // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ eval –¥–ª—è –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è –∫–æ–Ω—Ç–µ–∫—Å—Ç—É –≤–∏–∫–æ–Ω–∞–Ω–Ω—è
                        (function() {
                          try {
                            eval(scriptText);
                          } catch (evalError) {
                            // –Ø–∫—â–æ eval –Ω–µ –ø—Ä–∞—Ü—é—î, —Å–ø—Ä–æ–±—É—î–º–æ —á–µ—Ä–µ–∑ Function constructor
                            try {
                              const scriptFunction = new Function(scriptText);
                              scriptFunction();
                            } catch (funcError) {
                              console.warn(`‚ö†Ô∏è Script ${index} execution failed:`, funcError.message);
                              console.warn('Script content preview:', scriptText.substring(0, 200));
                            }
                          }
                        })();
                      } catch (error) {
                        console.error(`Error executing script ${index}:`, error);
                      }
                    }
                  }
                } catch (error) {
                  console.error(`Error processing script ${index}:`, error);
                }
              });
              
              // –ß–µ–∫–∞—î–º–æ –Ω–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –≤—Å—ñ—Ö —Å–∫—Ä–∏–ø—Ç—ñ–≤
              await Promise.all(scriptPromises);
              
              // –î–∞—î–º–æ —á–∞—Å —Å–∫—Ä–∏–ø—Ç–∞–º –≤–∏–∫–æ–Ω–∞—Ç–∏—Å—è —Ç–∞ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑—É–≤–∞—Ç–∏ –∑–º—ñ–Ω–Ω—ñ
              await new Promise(resolve => setTimeout(resolve, 300));
              
              // –í–∏–∫–ª–∏–∫–∞—î–º–æ –∫–æ–¥ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—ó, —è–∫–∏–π –≤–∏–∫–æ–Ω—É—î—Ç—å—Å—è –≤ DOMContentLoaded
              // –°—Ç–≤–æ—Ä—é—î–º–æ —Å–∫—Ä–∏–ø—Ç, —è–∫–∏–π –≤–∏–∫–ª–∏–∫–∞—î —Ñ—É–Ω–∫—Ü—ñ—ó —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—ó
              const initScript = document.createElement('script');
              initScript.textContent = `
                (function() {
                  try {
                    // –í–∏–∫–ª–∏–∫–∞—î–º–æ —Ñ—É–Ω–∫—Ü—ñ—ó —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—ó, —è–∫—â–æ –≤–æ–Ω–∏ –¥–æ—Å—Ç—É–ø–Ω—ñ
                    if (typeof loadSavedResults === 'function') {
                      loadSavedResults();
                    }
                    if (typeof renderCachedDialogues === 'function') {
                      renderCachedDialogues();
                    }
                    if (typeof initAudioSegmentDB === 'function') {
                      initAudioSegmentDB().catch(err => console.warn('IndexedDB init failed', err));
                    }
                    
                    // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ –∫–Ω–æ–ø–∫–∞ diarizeBtn –¥–æ—Å—Ç—É–ø–Ω–∞ —ñ –º–∞—î –æ–±—Ä–æ–±–Ω–∏–∫
                    setTimeout(() => {
                      const diarizeBtn = document.getElementById('diarizeBtn');
                      if (diarizeBtn) {
                        console.log('‚úì diarizeBtn found, checking handlers...');
                        // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ —î –æ–±—Ä–æ–±–Ω–∏–∫
                        if (!diarizeBtn.onclick && !diarizeBtn.getAttribute('data-handler-set')) {
                          console.log('‚ö†Ô∏è diarizeBtn has no handler, this is normal - handler will be set after audio processing');
                        }
                      } else {
                        console.warn('‚úó diarizeBtn not found');
                      }
                    }, 500);
                    
                    // –ó–∞–≤–∞–Ω—Ç–∞–∂—É—î–º–æ –≤—Å—ñ –∫–µ—à—ñ
                    setTimeout(() => {
                      try {
                        // 1. –ó–∞–≤–∞–Ω—Ç–∞–∂—É—î–º–æ ElevenLabs cache —Ç–∞ –≤—ñ–¥–æ–±—Ä–∞–∂–∞—î–º–æ –∑–±–µ—Ä–µ–∂–µ–Ω—ñ —Ñ–æ–Ω–∏
                        if (typeof loadElevenLabsCache === 'function') {
                          const cache = loadElevenLabsCache();
                          // –û–Ω–æ–≤–ª—é—î–º–æ –≥–ª–æ–±–∞–ª—å–Ω—É –∑–º—ñ–Ω–Ω—É elevenLabsCache, —è–∫—â–æ –≤–æ–Ω–∞ —ñ—Å–Ω—É—î
                          if (typeof elevenLabsCache !== 'undefined') {
                            // –Ø–∫—â–æ –∑–º—ñ–Ω–Ω–∞ –≤ –≥–ª–æ–±–∞–ª—å–Ω–æ–º—É –∫–æ–Ω—Ç–µ–∫—Å—Ç—ñ, –æ–Ω–æ–≤–ª—é—î–º–æ —ó—ó
                            try {
                              eval('elevenLabsCache = cache');
                            } catch (e) {
                              // –Ø–∫—â–æ –Ω–µ –≤–¥–∞–ª–æ—Å—è, —Å–ø—Ä–æ–±—É—î–º–æ —á–µ—Ä–µ–∑ window
                              if (typeof window !== 'undefined') {
                                window.elevenLabsCache = cache;
                              }
                            }
                          }
                        }
                        if (typeof renderElevenLabsSavedBackgrounds === 'function') {
                          renderElevenLabsSavedBackgrounds();
                        }
                        
                        // 2. –ó–∞–≤–∞–Ω—Ç–∞–∂—É—î–º–æ ElevenLabs API key
                        if (typeof loadElevenLabsKey === 'function') {
                          const savedKey = loadElevenLabsKey();
                          const elevenLabsKeyInput = document.getElementById('elevenLabsKey');
                          const dialogueElevenLabsKeyInput = document.getElementById('dialogueElevenLabsKey');
                          if (elevenLabsKeyInput && savedKey) {
                            elevenLabsKeyInput.value = savedKey;
                          }
                          if (dialogueElevenLabsKeyInput && savedKey) {
                            dialogueElevenLabsKeyInput.value = savedKey;
                          }
                        }
                        
                        // 3. –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –Ω–∞—è–≤–Ω—ñ—Å—Ç—å –∑–±–µ—Ä–µ–∂–µ–Ω–æ–≥–æ —Ñ–∞–π–ª—É
                        const audioGeneratorFile = localStorage.getItem('audioGeneratorFile');
                        const audioGeneratorReady = localStorage.getItem('audioGeneratorReady');
                        if (audioGeneratorFile && audioGeneratorReady === 'true') {
                          try {
                            const fileData = JSON.parse(audioGeneratorFile);
                            console.log('Found saved audio file in cache:', fileData.name);
                            // –§–∞–π–ª –∑–±–µ—Ä–µ–∂–µ–Ω–∏–π, –º–æ–∂–Ω–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –ø—Ä–∏ –ø–æ—Ç—Ä–µ–±—ñ
                          } catch (e) {
                            console.warn('Error parsing audioGeneratorFile:', e);
                          }
                        }
                        
                        // 4. –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —ñ–Ω—à—ñ storage keys
                        const originalScript = localStorage.getItem('diarizationOriginalScript');
                        const analyzerPayload = localStorage.getItem('diarizationAnalyzerPayload');
                        const flowIntent = localStorage.getItem('diarizationFlowIntent');
                        if (originalScript || analyzerPayload || flowIntent) {
                          console.log('Found additional storage data in cache');
                        }
                        
                        // 5. –õ–æ–≥—É—î–º–æ –≤—Å—ñ –∑–Ω–∞–π–¥–µ–Ω—ñ –∫–µ—à—ñ –¥–ª—è –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏
                        console.log('üì¶ Cache loading summary:', {
                          dialogueCache: !!localStorage.getItem('audioGeneratorDialogueCache'),
                          elevenLabsCache: !!localStorage.getItem('audioGeneratorElevenLabsCache'),
                          savedResults: !!localStorage.getItem('audioGeneratorResults'),
                          elevenLabsKey: !!localStorage.getItem('audioGeneratorElevenLabsKey'),
                          audioGeneratorFile: !!localStorage.getItem('audioGeneratorFile'),
                          audioGeneratorReady: !!localStorage.getItem('audioGeneratorReady'),
                          originalScript: !!originalScript,
                          analyzerPayload: !!analyzerPayload,
                          flowIntent: !!flowIntent
                        });
                      } catch (error) {
                        console.warn('Error loading additional caches:', error);
                      }
                    }, 100);
                    
                    // –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –∑–∞–≤–∞–Ω—Ç–∞–∂—É—î–º–æ –æ—Å—Ç–∞–Ω–Ω—ñ–π –∫–µ—à–æ–≤–∞–Ω–∏–π –¥—ñ–∞–ª–æ–≥ –∞–±–æ –æ—Å—Ç–∞–Ω–Ω—ñ–π –∑–±–µ—Ä–µ–∂–µ–Ω–∏–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç
                    setTimeout(() => {
                      try {
                        // –°–ø–æ—á–∞—Ç–∫—É –ø–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –∑–±–µ—Ä–µ–∂–µ–Ω—ñ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏ (–≥–æ—Ç–æ–≤–∏–π –æ–±—Ä–æ–±–ª–µ–Ω–∏–π –∞—É–¥—ñ–æ)
                        const savedResults = localStorage.getItem('audioGeneratorResults');
                        if (savedResults) {
                          const results = JSON.parse(savedResults);
                          if (results.length > 0) {
                            // –°–æ—Ä—Ç—É—î–º–æ –∑–∞ timestamp (–Ω–∞–π–Ω–æ–≤—ñ—à–∏–π –ø–µ—Ä—à–∏–π)
                            results.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
                            const latestResult = results[0];
                            
                            // –ó–∞–≤–∞–Ω—Ç–∞–∂—É—î–º–æ –æ—Å—Ç–∞–Ω–Ω—ñ–π –∑–±–µ—Ä–µ–∂–µ–Ω–∏–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç
                            if (typeof playSavedResult === 'function') {
                              // –ö–æ–Ω–≤–µ—Ä—Ç—É—î–º–æ base64 –≤ blob —ñ –∑–∞–≤–∞–Ω—Ç–∞–∂—É—î–º–æ
                              const byteCharacters = atob(latestResult.audioBlob.split(',')[1]);
                              const byteNumbers = new Array(byteCharacters.length);
                              for (let i = 0; i < byteCharacters.length; i++) {
                                byteNumbers[i] = byteCharacters.charCodeAt(i);
                              }
                              const byteArray = new Uint8Array(byteNumbers);
                              const blob = new Blob([byteArray], { type: 'audio/wav' });
                              const url = URL.createObjectURL(blob);
                              
                              // –ó–∞–≤–∞–Ω—Ç–∞–∂—É—î–º–æ –≤ processedAudio
                              const processedAudio = document.getElementById('processedAudio');
                              if (processedAudio) {
                                processedAudio.src = url;
                                processedAudio.classList.remove('hidden');
                                
                                // –ü–æ–∫–∞–∑—É—î–º–æ –∫–æ–Ω—Ç—Ä–æ–ª–∏
                                const audioControls = document.getElementById('audioControls');
                                if (audioControls) {
                                  audioControls.classList.remove('hidden');
                                }
                                
                                // –û–Ω–æ–≤–ª—é—î–º–æ —Å—Ç–∞—Ç—É—Å
                                const statusMessage = document.getElementById('statusMessage');
                                if (statusMessage && typeof showStatus === 'function') {
                                  showStatus('‚úì Loaded last saved result from cache', 'success');
                                }
                              }
                              return;
                            }
                          }
                        }
                        
                        // –Ø–∫—â–æ –Ω–µ–º–∞—î –∑–±–µ—Ä–µ–∂–µ–Ω–∏—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤, –∑–∞–≤–∞–Ω—Ç–∞–∂—É—î–º–æ –æ—Å—Ç–∞–Ω–Ω—ñ–π –∫–µ—à–æ–≤–∞–Ω–∏–π –¥—ñ–∞–ª–æ–≥
                        const DIALOGUE_CACHE_KEY = 'audioGeneratorDialogueCache';
                        const dialogueCache = localStorage.getItem(DIALOGUE_CACHE_KEY);
                        if (dialogueCache) {
                          const cache = JSON.parse(dialogueCache);
                          const entries = Object.entries(cache);
                          if (entries.length > 0) {
                            // –°–æ—Ä—Ç—É—î–º–æ –∑–∞ timestamp (–Ω–∞–π–Ω–æ–≤—ñ—à–∏–π –ø–µ—Ä—à–∏–π)
                            entries.sort((a, b) => (b[1].timestamp || 0) - (a[1].timestamp || 0));
                            const latestEntry = entries[0];
                            const data = latestEntry[1];
                            
                            // –ó–∞–≤–∞–Ω—Ç–∞–∂—É—î–º–æ –æ—Å—Ç–∞–Ω–Ω—ñ–π –∫–µ—à–æ–≤–∞–Ω–∏–π –¥—ñ–∞–ª–æ–≥
                            if (typeof loadCachedDialogue === 'function' && data.dialogue) {
                              loadCachedDialogue(data.dialogue, data.params || {});
                            }
                          }
                        }
                      } catch (error) {
                        console.warn('Error auto-loading cached content:', error);
                      }
                    }, 500);
                  } catch (error) {
                    console.warn('Error initializing generator:', error);
                  }
                })();
              `;
              generatorContent.appendChild(initScript);
              
              // –¢–∞–∫–æ–∂ –≤–∏–∫–ª–∏–∫–∞—î–º–æ –ø–æ–¥—ñ—é DOMContentLoaded –¥–ª—è generatorContent
              // —â–æ–± –æ–±—Ä–æ–±–Ω–∏–∫–∏ –ø–æ–¥—ñ–π –º–æ–≥–ª–∏ —Å–ø—Ä–∞—Ü—é–≤–∞—Ç–∏
              const domContentLoadedEvent = new Event('DOMContentLoaded', { bubbles: true, cancelable: true });
              generatorContent.dispatchEvent(domContentLoadedEvent);
              
              generatorContent.dataset.loaded = 'true';
            } else {
              generatorContent.innerHTML = '<p style="text-align: center; padding: 20px; color: red;">–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞</p>';
            }
          } catch (error) {
            console.error('Error loading generator:', error);
            generatorContent.innerHTML = '<p style="text-align: center; padding: 20px; color: red;">–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞: ' + error.message + '</p>';
          }
        }
      }
    }

    function closeGeneratorModal() {
      const modal = document.getElementById('generatorModal');
      if (modal) {
        modal.style.display = 'none';
      }
    }
    
    // –§—É–Ω–∫—Ü—ñ—ó –¥–ª—è —Ä–æ–±–æ—Ç–∏ –∑ Debug –º–µ–Ω—é
    function toggleDebugMenu(event) {
      event.stopPropagation();
      const menu = document.getElementById('debugMenu');
      if (menu) {
        const isVisible = menu.style.display === 'block';
        menu.style.display = isVisible ? 'none' : 'block';
      }
    }
    
    function closeDebugMenu() {
      const menu = document.getElementById('debugMenu');
      if (menu) {
        menu.style.display = 'none';
      }
    }
    
    // –ó–∞–∫—Ä–∏–≤–∞—î–º–æ –º–µ–Ω—é –ø—Ä–∏ –∫–ª—ñ–∫—É –ø–æ–∑–∞ –Ω–∏–º
    document.addEventListener('click', function(event) {
      const debugBtn = document.getElementById('debugBtn');
      const debugMenu = document.getElementById('debugMenu');
      if (debugMenu && debugBtn && !debugBtn.contains(event.target) && !debugMenu.contains(event.target)) {
        closeDebugMenu();
      }
    });
    
    // –ó–∞–∫—Ä–∏–≤–∞—î–º–æ –º–æ–¥–∞–ª—å–Ω–µ –≤—ñ–∫–Ω–æ –ø—Ä–∏ –Ω–∞—Ç–∏—Å–∫–∞–Ω–Ω—ñ Escape
    document.addEventListener('keydown', function(event) {
      if (event.key === 'Escape') {
        const debugModal = document.getElementById('debugModal');
        if (debugModal && debugModal.style.display === 'flex') {
          closeDebugModal();
        }
        const generatorModal = document.getElementById('generatorModal');
        if (generatorModal && generatorModal.style.display === 'flex') {
          closeGeneratorModal();
        }
        const separationDebugModal = document.getElementById('separationDebugModal');
        if (separationDebugModal && separationDebugModal.style.display === 'flex') {
          closeSeparationDebugModal();
        }
      }
    });
    
    // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è debug –¥–∞–Ω–∏—Ö (–≤–∫–ª—é—á–∞—î –æ–±–∏–¥–≤–∞ –ø–æ–ª—è)
    async function copyDebugData(buttonElement) {
      const debugTextarea = document.getElementById('debugTextarea');
      const postProcessingResult = document.getElementById('postProcessingResult');
      
      // –ó–±–∏—Ä–∞—î–º–æ –¥–∞–Ω—ñ –∑ –æ–±–æ—Ö –ø–æ–ª—ñ–≤
      const debugData = debugTextarea.value || '';
      const postProcessingData = postProcessingResult.value || '';
      
      // –ó–±–∏—Ä–∞—î–º–æ –ª–æ–≥–∏ –∫–æ–Ω—Å–æ–ª—ñ (–∑ fallback –Ω–∞ –ø—Ä—è–º–∏–π –¥–æ—Å—Ç—É–ø –¥–æ –º–∞—Å–∏–≤—É)
      let consoleLogsText = '';
      try {
        if (window.getFormattedConsoleLogs) {
          consoleLogsText = window.getFormattedConsoleLogs();
        } else if (window.consoleLogs && Array.isArray(window.consoleLogs) && window.consoleLogs.length > 0) {
          // Fallback: —Ñ–æ—Ä–º–∞—Ç—É—î–º–æ –ª–æ–≥–∏ –≤—Ä—É—á–Ω—É, —è–∫—â–æ —Ñ—É–Ω–∫—Ü—ñ—è –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞
          consoleLogsText = window.consoleLogs.map(log => {
            try {
              const time = new Date(log.timestamp).toLocaleTimeString();
              const typePrefix = (log.type || 'LOG').toUpperCase().padEnd(5);
              return `[${time}] ${typePrefix} ${log.message || ''}`;
            } catch (e) {
              return `[ERROR] Failed to format log: ${String(log)}`;
            }
          }).join('\n');
        }
      } catch (logError) {
        console.error('‚ùå [COPY] Error formatting console logs:', logError);
        consoleLogsText = `(Error formatting console logs: ${logError.message})`;
      }
      
      // –§–æ—Ä–º—É—î–º–æ –æ–±'—î–¥–Ω–∞–Ω–∏–π —Ç–µ–∫—Å—Ç
      let combinedText = '';
      
      if (debugData) {
        combinedText += '=== Original Analysis Result ===\n\n';
        combinedText += debugData;
        combinedText += '\n\n';
      }
      
      if (postProcessingData) {
        combinedText += '=== Post-Processing Result ===\n\n';
        combinedText += postProcessingData;
        combinedText += '\n\n';
      }
      
      // –î–æ–¥–∞—î–º–æ –ª–æ–≥–∏ –∫–æ–Ω—Å–æ–ª—ñ (–∑–∞–≤–∂–¥–∏ –¥–æ–¥–∞—î–º–æ —Å–µ–∫—Ü—ñ—é, –Ω–∞–≤—ñ—Ç—å —è–∫—â–æ –ª–æ–≥—ñ–≤ –Ω–µ–º–∞—î)
      combinedText += '=== Console Logs ===\n\n';
      if (consoleLogsText && consoleLogsText.trim()) {
        combinedText += consoleLogsText;
      } else {
        // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ —Å–∏—Å—Ç–µ–º–∞ –ø–µ—Ä–µ—Ö–æ–ø–ª–µ–Ω–Ω—è –∞–∫—Ç–∏–≤–Ω–∞
        if (window.consoleLogCaptureEnabled === false) {
          combinedText += '(Console log capture is disabled)';
        } else if (!window.consoleLogs || window.consoleLogs.length === 0) {
          combinedText += '(No console logs captured yet)';
        } else {
          combinedText += '(No console logs captured)';
        }
      }
      combinedText += '\n\n';
      
      // –Ø–∫—â–æ –æ–±–∏–¥–≤–∞ –ø–æ–ª—è –ø–æ—Ä–æ–∂–Ω—ñ, –∫–æ–ø—ñ—é—î–º–æ —Ç—ñ–ª—å–∫–∏ –ø–µ—Ä—à–µ
      if (!combinedText.trim()) {
        combinedText = debugData || '';
      }
      
      // –ö–æ–ø—ñ—é—î–º–æ –≤ –±—É—Ñ–µ—Ä –æ–±–º—ñ–Ω—É
      try {
        await navigator.clipboard.writeText(combinedText);
        console.log('‚úÖ [COPY] All debug data copied to clipboard');
      } catch (clipboardError) {
        // Fallback –¥–ª—è —Å—Ç–∞—Ä–∏—Ö –±—Ä–∞—É–∑–µ—Ä—ñ–≤
        const tempTextarea = document.createElement('textarea');
        tempTextarea.value = combinedText;
        tempTextarea.style.position = 'fixed';
        tempTextarea.style.opacity = '0';
        document.body.appendChild(tempTextarea);
        tempTextarea.select();
        document.execCommand('copy');
        document.body.removeChild(tempTextarea);
        console.log('‚úÖ [COPY] All debug data copied to clipboard (fallback method)');
      }
      
      // –ü–æ–∫–∞–∑—É—î–º–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –ø—Ä–æ —É—Å–ø—ñ—à–Ω–µ –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è
      const copyBtn = buttonElement || document.getElementById('copyAllBtn');
      if (copyBtn) {
        const originalText = copyBtn.innerHTML;
        copyBtn.innerHTML = '‚úÖ Copied!';
        copyBtn.style.background = '#27ae60';
        setTimeout(() => {
          copyBtn.innerHTML = originalText;
          copyBtn.style.background = '#27ae60';
        }, 2000);
      }
    }
    
    // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –æ—Ç—Ä–∏–º–∞–Ω–Ω—è General JSON
    function getGeneralJSON() {
      if (!currentAnalysisData) return null;
      
      let primaryDiarization = currentAnalysisData.primaryDiarization || currentAnalysisData.general;
      
      // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –≤–∫–ª–∞–¥–µ–Ω—ñ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏
      if (!primaryDiarization && currentAnalysisData.primaryDiarization) {
        const primary = currentAnalysisData.primaryDiarization;
        if (primary.recordings && Array.isArray(primary.recordings) && primary.recordings[0]) {
          primaryDiarization = primary.recordings[0];
        } else {
          primaryDiarization = primary;
        }
      }
      
      return primaryDiarization;
    }
    
    // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –æ—Ç—Ä–∏–º–∞–Ω–Ω—è Speaker1 JSON
    function getSpeaker1JSON() {
      if (!currentAnalysisData) return null;
      
      const voiceTracks = currentAnalysisData.voiceTracks || [];
      
      if (voiceTracks.length > 0) {
        const speaker1Track = voiceTracks.find(t => 
          t.speaker === 'SPEAKER_00' || 
          t.role === 'operator' || 
          t.role === 'agent' ||
          (t.roleAnalysis && (t.roleAnalysis.role === 'operator' || t.roleAnalysis.role === 'agent'))
        ) || voiceTracks[0];
        
        if (speaker1Track) {
          // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —Ä—ñ–∑–Ω—ñ –º–æ–∂–ª–∏–≤—ñ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏ –¥–ª—è –≤–∏—Ç—è–≥—É–≤–∞–Ω–Ω—è –ø–æ–≤–Ω–æ–≥–æ JSON —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü—ñ—ó
          // 1. –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ transcription.recordings[0].results.speechmatics (–Ω–∞–π–≥–ª–∏–±—à–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞)
          if (speaker1Track.transcription && 
              speaker1Track.transcription.recordings && 
              Array.isArray(speaker1Track.transcription.recordings) && 
              speaker1Track.transcription.recordings[0] &&
              speaker1Track.transcription.recordings[0].results &&
              speaker1Track.transcription.recordings[0].results.speechmatics) {
            return speaker1Track.transcription.recordings[0].results.speechmatics;
          }
          
          // 2. –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ transcription.recordings[0] (—Å–µ—Ä–µ–¥–Ω—ñ–π —Ä—ñ–≤–µ–Ω—å)
          if (speaker1Track.transcription && 
              speaker1Track.transcription.recordings && 
              Array.isArray(speaker1Track.transcription.recordings) && 
              speaker1Track.transcription.recordings[0]) {
            return speaker1Track.transcription.recordings[0];
          }
          
          // 3. –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ transcription –Ω–∞–ø—Ä—è–º—É (—è–∫—â–æ –≤—ñ–Ω –º—ñ—Å—Ç–∏—Ç—å segments)
          if (speaker1Track.transcription && 
              (speaker1Track.transcription.segments || 
               speaker1Track.transcription.recordings || 
               speaker1Track.transcription.results)) {
            return speaker1Track.transcription;
          }
          
          // 4. –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ recordings[0]
          if (speaker1Track.recordings && Array.isArray(speaker1Track.recordings) && speaker1Track.recordings[0]) {
            return speaker1Track.recordings[0];
          }
          
          // 5. –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ speechmatics
          if (speaker1Track.speechmatics) {
            return speaker1Track.speechmatics;
          }
          
          // 6. –Ø–∫—â–æ —î segments –∞–±–æ transcriptText - –ø–æ–≤–µ—Ä—Ç–∞—î–º–æ –≤–µ—Å—å –æ–±'—î–∫—Ç
          if (speaker1Track.segments || speaker1Track.transcriptText) {
            return speaker1Track;
          }
          
          // 7. –Ø–∫—â–æ –Ω—ñ—á–æ–≥–æ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ - –ø–æ–≤–µ—Ä—Ç–∞—î–º–æ null
          return null;
        }
      }
      
      return null;
    }
    
    // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –æ—Ç—Ä–∏–º–∞–Ω–Ω—è Speaker2 JSON
    function getSpeaker2JSON() {
      if (!currentAnalysisData) return null;
      
      const voiceTracks = currentAnalysisData.voiceTracks || [];
      
      if (voiceTracks.length > 1) {
        const speaker2Track = voiceTracks.find(t => 
          t.speaker === 'SPEAKER_01' || 
          t.role === 'client' || 
          t.role === 'customer' ||
          (t.roleAnalysis && (t.roleAnalysis.role === 'client' || t.roleAnalysis.role === 'customer'))
        ) || voiceTracks[1];
        
        if (speaker2Track) {
          // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —Ä—ñ–∑–Ω—ñ –º–æ–∂–ª–∏–≤—ñ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏ –¥–ª—è –≤–∏—Ç—è–≥—É–≤–∞–Ω–Ω—è –ø–æ–≤–Ω–æ–≥–æ JSON —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü—ñ—ó
          // 1. –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ transcription.recordings[0].results.speechmatics (–Ω–∞–π–≥–ª–∏–±—à–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞)
          if (speaker2Track.transcription && 
              speaker2Track.transcription.recordings && 
              Array.isArray(speaker2Track.transcription.recordings) && 
              speaker2Track.transcription.recordings[0] &&
              speaker2Track.transcription.recordings[0].results &&
              speaker2Track.transcription.recordings[0].results.speechmatics) {
            return speaker2Track.transcription.recordings[0].results.speechmatics;
          }
          
          // 2. –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ transcription.recordings[0] (—Å–µ—Ä–µ–¥–Ω—ñ–π —Ä—ñ–≤–µ–Ω—å)
          if (speaker2Track.transcription && 
              speaker2Track.transcription.recordings && 
              Array.isArray(speaker2Track.transcription.recordings) && 
              speaker2Track.transcription.recordings[0]) {
            return speaker2Track.transcription.recordings[0];
          }
          
          // 3. –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ transcription –Ω–∞–ø—Ä—è–º—É (—è–∫—â–æ –≤—ñ–Ω –º—ñ—Å—Ç–∏—Ç—å segments)
          if (speaker2Track.transcription && 
              (speaker2Track.transcription.segments || 
               speaker2Track.transcription.recordings || 
               speaker2Track.transcription.results)) {
            return speaker2Track.transcription;
          }
          
          // 4. –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ recordings[0]
          if (speaker2Track.recordings && Array.isArray(speaker2Track.recordings) && speaker2Track.recordings[0]) {
            return speaker2Track.recordings[0];
          }
          
          // 5. –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ speechmatics
          if (speaker2Track.speechmatics) {
            return speaker2Track.speechmatics;
          }
          
          // 6. –Ø–∫—â–æ —î segments –∞–±–æ transcriptText - –ø–æ–≤–µ—Ä—Ç–∞—î–º–æ –≤–µ—Å—å –æ–±'—î–∫—Ç
          if (speaker2Track.segments || speaker2Track.transcriptText) {
            return speaker2Track;
          }
          
          // 7. –Ø–∫—â–æ –Ω—ñ—á–æ–≥–æ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ - –ø–æ–≤–µ—Ä—Ç–∞—î–º–æ null
          return null;
        }
      }
      
      return null;
    }
    
    // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –≤–∏—Ç—è–≥—É–≤–∞–Ω–Ω—è —Å–µ–≥–º–µ–Ω—Ç—ñ–≤ –∑ —Ä—ñ–∑–Ω–∏—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä JSON
    function extractSegments(data) {
      if (!data) return [];
      
      // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —Ä—ñ–∑–Ω—ñ –º–æ–∂–ª–∏–≤—ñ –º—ñ—Å—Ü—è, –¥–µ –º–æ–∂—É—Ç—å –±—É—Ç–∏ segments
      if (Array.isArray(data.segments)) {
        return data.segments;
      }
      
      if (data.speechmatics && Array.isArray(data.speechmatics.segments)) {
        return data.speechmatics.segments;
      }
      
      if (data.recordings && Array.isArray(data.recordings) && data.recordings[0]) {
        const recording = data.recordings[0];
        if (recording.results && recording.results.speechmatics && Array.isArray(recording.results.speechmatics.segments)) {
          return recording.results.speechmatics.segments;
        }
        if (Array.isArray(recording.segments)) {
          return recording.segments;
        }
      }
      
      if (data.results && data.results.speechmatics && Array.isArray(data.results.speechmatics.segments)) {
        return data.results.speechmatics.segments;
      }
      
      if (data.transcription) {
        return extractSegments(data.transcription);
      }
      
      return [];
    }
    
    // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è —Ñ–æ—Ä–º–∞—Ç—É–≤–∞–Ω–Ω—è –¥—ñ–∞–ª–æ–≥—É –∑ —Ä–µ–ø–ª—ñ–∫
    function formatDialog(segments) {
      if (!segments || segments.length === 0) {
        return 'No segments found';
      }
      
      // –°–æ—Ä—Ç—É—î–º–æ —Å–µ–≥–º–µ–Ω—Ç–∏ –∑–∞ —á–∞—Å–æ–º –ø–æ—á–∞—Ç–∫—É
      const sortedSegments = [...segments].sort((a, b) => {
        const startA = a.start || 0;
        const startB = b.start || 0;
        return startA - startB;
      });
      
      // –§–æ—Ä–º–∞—Ç—É—î–º–æ —è–∫ –¥—ñ–∞–ª–æ–≥
      let dialog = '';
      sortedSegments.forEach((segment, index) => {
        const speaker = segment.speaker || 'UNKNOWN';
        const text = segment.text || '';
        const role = segment.role || '';
        
        // –§–æ—Ä–º–∞—Ç—É—î–º–æ —Å–ø—ñ–∫–µ—Ä–∞ –∑ —Ä–æ–ª–ª—é (—è–∫—â–æ —î)
        let speakerLabel = speaker;
        if (role) {
          speakerLabel += ` (${role})`;
        }
        
        dialog += `${speakerLabel}: ${text}\n`;
      });
      
      return dialog.trim();
    }
    
    // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è General JSON (–¥—ñ–∞–ª–æ–≥)
    function copyGeneralJSON() {
      const jsonData = getGeneralJSON();
      if (!jsonData) {
        alert('General JSON not available');
        return;
      }
      
      const segments = extractSegments(jsonData);
      if (segments.length === 0) {
        alert('No segments found in General JSON');
        return;
      }
      
      const dialog = formatDialog(segments);
      copyToClipboard(dialog, event.target, '#3498db');
    }
    
    // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è Speaker1 JSON (–¥—ñ–∞–ª–æ–≥)
    function copySpeaker1JSON() {
      const jsonData = getSpeaker1JSON();
      if (!jsonData) {
        alert('Speaker1 JSON not available');
        return;
      }
      
      const segments = extractSegments(jsonData);
      if (segments.length === 0) {
        alert('No segments found in Speaker1 JSON');
        return;
      }
      
      const dialog = formatDialog(segments);
      copyToClipboard(dialog, event.target, '#9b59b6');
    }
    
    // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è Speaker2 JSON (–¥—ñ–∞–ª–æ–≥)
    function copySpeaker2JSON() {
      const jsonData = getSpeaker2JSON();
      if (!jsonData) {
        alert('Speaker2 JSON not available');
        return;
      }
      
      const segments = extractSegments(jsonData);
      if (segments.length === 0) {
        alert('No segments found in Speaker2 JSON');
        return;
      }
      
      const dialog = formatDialog(segments);
      copyToClipboard(dialog, event.target, '#e67e22');
    }
    
    const normalizeSpeakerName = (name) => {
      if (!name) return null;
      const normalized = name.toString().trim().toLowerCase();
      if (normalized === 'agent' || normalized === 'operator') return 'agent';
      if (normalized === 'client' || normalized === 'customer') return 'client';
      return normalized;
    };

    const formatRoleLabel = (roleNorm, fallbackLabel = null) => {
      if (roleNorm) {
        return roleNorm.charAt(0).toUpperCase() + roleNorm.slice(1);
      }
      if (fallbackLabel) {
        return fallbackLabel;
      }
      return 'Unknown';
    };

    const normalizeText = (text) => {
      return (text || '')
        .toLowerCase()
        .replace(/[\n\r]+/g, " ")
        .replace(/[^a-z0-9\s']/g, " ")
        .replace(/\buh\b/g, " ")
        .replace(/\s+/g, " ")
        .trim();
    };

    const parseTimeValue = (value) => {
      if (value === undefined || value === null) return null;
      if (typeof value === 'number' && !isNaN(value)) return value;
      const str = value.toString().trim();
      if (str === '') return null;
      if (/^\d+(\.\d+)?$/.test(str)) {
        return parseFloat(str);
      }
      if (str.includes(':')) {
        const parts = str.split(':').map(part => parseFloat(part));
        if (parts.every(part => !isNaN(part))) {
          let seconds = 0;
          let multiplier = 1;
          for (let i = parts.length - 1; i >= 0; i--) {
            seconds += parts[i] * multiplier;
            multiplier *= 60;
          }
          return seconds;
        }
      }
      const cleaned = str.replace(/[^\d.]/g, '');
      const num = parseFloat(cleaned);
      return isNaN(num) ? null : num;
    };

    const getSegmentTimeRange = (segment) => {
      const startKeys = ['start', 'begin', 'offset', 'from', 'timeStart'];
      const endKeys = ['end', 'stop', 'to', 'timeEnd'];

      let start = null;
      let end = null;

      for (const key of startKeys) {
        if (segment && segment[key] !== undefined) {
          const value = parseTimeValue(segment[key]);
          if (value !== null) {
            start = value;
            break;
          }
        }
      }

      for (const key of endKeys) {
        if (segment && segment[key] !== undefined) {
          const value = parseTimeValue(segment[key]);
          if (value !== null) {
            end = value;
            break;
          }
        }
      }

      if (start === null && end !== null) {
        start = end;
      } else if (end === null && start !== null) {
        end = start;
      }

      return { start, end };
    };

    const buildSpeakerRoleMap = (voiceTracks = []) => {
      const map = {};
      voiceTracks.forEach(track => {
        const speakerId = track?.speaker || track?.speakerId;
        if (!speakerId) return;
        const roleCandidate = track?.roleAnalysis?.role || track?.role || track?.metadata?.role;
        const normalizedRole = normalizeSpeakerName(roleCandidate);
        if (normalizedRole && !map[speakerId]) {
          map[speakerId] = normalizedRole;
        }
      });
      return map;
    };

    const detectSpeakerFromSegments = (segments, speakerRoleMap = {}) => {
      for (const segment of segments) {
        const directRole = normalizeSpeakerName(segment?.role);
        if (directRole) return directRole;
        const speakerId = segment?.speaker;
        if (speakerId && speakerRoleMap[speakerId]) {
          return speakerRoleMap[speakerId];
        }
      }
      return null;
    };

    const getDialogSliceForPhrase = (phraseInfo, segments, speakerRoleMap) => {
      if (!phraseInfo || !segments || segments.length === 0) return null;

      const tolerance = 1.0;
      const targetStart = typeof phraseInfo.start === 'number' ? phraseInfo.start : null;
      const targetEnd = typeof phraseInfo.end === 'number' ? phraseInfo.end : targetStart;
      const normalizedSpeaker = phraseInfo.speakerNorm;

      let sliceSegments = [];

      if (targetStart !== null && targetEnd !== null) {
        sliceSegments = segments.filter(segment => {
          const { start, end } = getSegmentTimeRange(segment);
          if (start === null && end === null) {
            return false;
          }
          const segmentStart = start !== null ? start : end;
          const segmentEnd = end !== null ? end : start;
          const overlaps = (
            segmentStart <= (targetEnd + tolerance) &&
            segmentEnd >= (targetStart - tolerance)
          );
          if (!overlaps) {
            return false;
          }
          if (normalizedSpeaker) {
            const segmentSpeaker = normalizeSpeakerName(segment?.role || segment?.speaker);
            if (segmentSpeaker && segmentSpeaker !== normalizedSpeaker) {
              return false;
            }
          }
          return true;
        });
      }

      if ((!sliceSegments || sliceSegments.length === 0) && normalizedSpeaker) {
        sliceSegments = segments.filter(segment => {
          const segmentSpeaker = normalizeSpeakerName(segment?.role || segment?.speaker);
          return segmentSpeaker && segmentSpeaker === normalizedSpeaker;
        });
      }

      if (!sliceSegments || sliceSegments.length === 0) {
        return null;
      }

      const textParts = sliceSegments
        .map(segment => getSegmentText(segment))
        .filter(Boolean);

      if (textParts.length === 0) {
        return null;
      }

      const detectedSpeaker = normalizedSpeaker || detectSpeakerFromSegments(sliceSegments, speakerRoleMap);

      return {
        text: textParts.join(' ').trim(),
        speakerNorm: detectedSpeaker
      };
    };

    // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –≤–∏–∫–æ–Ω–∞–Ω–Ω—è –¥—ñ—ó Run
    // –ó–ê–ö–û–ú–ï–ù–¢–û–í–ê–ù–û: –ü–æ—Ç–æ—á–Ω–∏–π —Ñ—É–Ω–∫—Ü—ñ–æ–Ω–∞–ª –∫–Ω–æ–ø–∫–∏ Run —Ç–∏–º—á–∞—Å–æ–≤–æ –≤–∏–º–∫–Ω–µ–Ω–æ, –±—É–¥–µ —ñ–Ω—à–∏–π —Ñ—É–Ω–∫—Ü—ñ–æ–Ω–∞–ª
    /*
    function runDebugAction() {
      const btn = document.getElementById('runBtn');
      const originalText = btn.innerHTML;
      const debugTextarea = document.getElementById('debugTextarea');
      
      // –ü–æ–∫–∞–∑—É—î–º–æ —ñ–Ω–¥–∏–∫–∞—Ç–æ—Ä –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è
      btn.disabled = true;
      btn.style.opacity = '0.6';
      btn.style.cursor = 'not-allowed';
      btn.innerHTML = '‚è≥ Running...';
      
      try {
        // 1. –û—Ç—Ä–∏–º—É—î–º–æ markdown —Ç–∞–±–ª–∏—Ü—é
        let markdownTable = null;
        if (currentAnalysisData && currentAnalysisData.markdownTable) {
          markdownTable = currentAnalysisData.markdownTable;
        } else if (currentAnalysisData && currentAnalysisData.correctedDiarization) {
          const corrected = currentAnalysisData.correctedDiarization;
          if (corrected.recordings && Array.isArray(corrected.recordings) && corrected.recordings[0]) {
            const recording = corrected.recordings[0];
            if (recording.results && recording.results['overlap-corrected']) {
              const rawData = recording.results['overlap-corrected'].rawData;
              if (rawData && rawData.markdownTable) {
                markdownTable = rawData.markdownTable;
              }
            }
          } else if (corrected.rawData && corrected.rawData.markdownTable) {
            markdownTable = corrected.rawData.markdownTable;
          }
        }
        
        if (!markdownTable) {
          throw new Error('Markdown table not available');
        }
        
        // 2. –í–∏—Ç—è–≥—É—î–º–æ –≤—Å—ñ —Ä–µ–ø–ª—ñ–∫–∏ –∑ markdown —Ç–∞–±–ª–∏—Ü—ñ
        const lines = markdownTable.split('\n');
        const phrases = [];
        let headerFound = false;
        let separatorFound = false;
        
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i].trim();
          
          // –®—É–∫–∞—î–º–æ —Ä—è–¥–æ–∫ —Ç–∞–±–ª–∏—Ü—ñ (–ø–æ—á–∏–Ω–∞—î—Ç—å—Å—è –∑ |)
          if (line.startsWith('|') && line.endsWith('|')) {
            // –ü—Ä–æ–ø—É—Å–∫–∞—î–º–æ –∑–∞–≥–æ–ª–æ–≤–æ–∫
            if (!headerFound) {
              headerFound = true;
              continue;
            }
            
            // –ü—Ä–æ–ø—É—Å–∫–∞—î–º–æ —Ä–æ–∑–¥—ñ–ª—å–Ω–∏–∫ (|---|---|)
            const cells = line.split('|').map(c => c.trim()).filter(c => c.length > 0);
            const isSeparator = cells.every(c => {
              const trimmed = c.trim();
              return trimmed === '' || trimmed.match(/^:?-+:?$/) || trimmed.match(/^:?-+:?$/);
            });
            
            if (isSeparator) {
              separatorFound = true;
              continue;
            }
            
            // –Ø–∫—â–æ –∑–Ω–∞–π—à–ª–∏ —Ä–æ–∑–¥—ñ–ª—å–Ω–∏–∫, –Ω–∞—Å—Ç—É–ø–Ω—ñ —Ä—è–¥–∫–∏ - —Ü–µ —Ä—è–¥–∫–∏ –¥–∞–Ω–∏—Ö
            if (separatorFound && cells.length >= 3) {
              // –ö–æ–ª–æ–Ω–∫–∞ Text - —Ü–µ —Ç—Ä–µ—Ç—è –∫–æ–ª–æ–Ω–∫–∞ (—ñ–Ω–¥–µ–∫—Å 2)
              const phraseText = cells[2] || null;
              if (phraseText && phraseText.trim() !== '') {
                const phraseInfo = {
                  text: phraseText.trim(),
                  speaker: cells[1] || null,
                  speakerLabel: cells[1] || null,
                  speakerNorm: normalizeSpeakerName(cells[1]),
                  start: parseTimeValue(cells[3]),
                  end: parseTimeValue(cells[4])
                };
                phrases.push(phraseInfo);
              }
            }
          }
        }
        
        if (phrases.length === 0) {
          throw new Error('No phrases found in markdown table');
        }
        
        // 3. –û—Ç—Ä–∏–º—É—î–º–æ –¥—ñ–∞–ª–æ–≥ –∑ General JSON
        const jsonData = getGeneralJSON();
        if (!jsonData) {
          throw new Error('General JSON not available');
        }
        
        const generalSegments = extractSegments(jsonData);
        if (generalSegments.length === 0) {
          throw new Error('No segments found in General JSON');
        }
        
        const dialog = formatDialog(generalSegments);
        
        // 3.0. –ë—É–¥—É—î–º–æ –º–∞–ø—É —Å–ø—ñ–∫–µ—Ä—ñ–≤ –¥–ª—è –≤–∏–∑–Ω–∞—á–µ–Ω–Ω—è —Ä–æ–ª–µ–π
        const speakerRoleMap = buildSpeakerRoleMap(currentAnalysisData.voiceTracks || []);
        
        // 3.1. –û—Ç—Ä–∏–º—É—î–º–æ textAnalysis –¥–ª—è –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ –∫–ª–∞—Å–∏—Ñ—ñ–∫–∞—Ü—ñ—ó
        let textAnalysis = currentAnalysisData.textAnalysis;
        
        // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —Ä—ñ–∑–Ω—ñ –º–æ–∂–ª–∏–≤—ñ –º—ñ—Å—Ü—è, –¥–µ –º–æ–∂–µ –±—É—Ç–∏ textAnalysis
        if (!textAnalysis && currentAnalysisData.correctedDiarization) {
          const corrected = currentAnalysisData.correctedDiarization;
          if (corrected.textAnalysis) {
            textAnalysis = corrected.textAnalysis;
          } else if (corrected.rawData && corrected.rawData.textAnalysis) {
            textAnalysis = corrected.rawData.textAnalysis;
          } else if (corrected.recordings && Array.isArray(corrected.recordings) && corrected.recordings[0]) {
            const recording = corrected.recordings[0];
            if (recording.results && recording.results['overlap-corrected']) {
              const result = recording.results['overlap-corrected'];
              if (result.textAnalysis) {
                textAnalysis = result.textAnalysis;
              } else if (result.rawData && result.rawData.textAnalysis) {
                textAnalysis = result.rawData.textAnalysis;
              }
            }
          }
        }
        
        // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏, —á–∏ —Ñ—Ä–∞–∑–∞ —î –≤ Blue –º–∞—Å–∏–≤—ñ
        const isPhraseInBlue = (phrase) => {
          if (!textAnalysis || !textAnalysis.Blue || !Array.isArray(textAnalysis.Blue)) {
            return false;
          }
          
          const normalizedPhrase = phrase.toLowerCase().trim();
          
          for (let i = 0; i < textAnalysis.Blue.length; i++) {
            const blueItem = textAnalysis.Blue[i];
            const blueText = blueItem.text || blueItem;
            const normalizedBlueText = (typeof blueText === 'string' ? blueText : '').toLowerCase().trim();
            
            // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —Ç–æ—á–Ω–µ –≤—Ö–æ–¥–∂–µ–Ω–Ω—è –∞–±–æ —á–∞—Å—Ç–∫–æ–≤–µ
            if (normalizedBlueText === normalizedPhrase || normalizedBlueText.includes(normalizedPhrase) || normalizedPhrase.includes(normalizedBlueText)) {
              return true;
            }
          }
          
          return false;
        };
        
        // 3.2. –û—Ç—Ä–∏–º—É—î–º–æ –¥—ñ–∞–ª–æ–≥ –∑ Speaker1 JSON –¥–ª—è –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ —Ä–µ–ø–ª—ñ–∫, —è–∫—ñ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω—ñ –≤ General JSON
        let speaker1Dialog = null;
        try {
          const speaker1JsonData = getSpeaker1JSON();
          if (speaker1JsonData) {
            const speaker1Segments = extractSegments(speaker1JsonData);
            if (speaker1Segments.length > 0) {
              const speaker1Text = formatDialog(speaker1Segments);
              speaker1Dialog = {
                text: speaker1Text,
                speakerNorm: detectSpeakerFromSegments(speaker1Segments, speakerRoleMap)
              };
            }
          }
        } catch (error) {
          console.warn('‚ö†Ô∏è [runDebugAction] Could not get Speaker1 JSON:', error);
        }
        
        // 3.3. –û—Ç—Ä–∏–º—É—î–º–æ –¥—ñ–∞–ª–æ–≥ –∑ Speaker2 JSON –¥–ª—è –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ —Ä–µ–ø–ª—ñ–∫, —è–∫—ñ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω—ñ –≤ General JSON
        let speaker2Dialog = null;
        try {
          const speaker2JsonData = getSpeaker2JSON();
          if (speaker2JsonData) {
            const speaker2Segments = extractSegments(speaker2JsonData);
            if (speaker2Segments.length > 0) {
              const speaker2Text = formatDialog(speaker2Segments);
              speaker2Dialog = {
                text: speaker2Text,
                speakerNorm: detectSpeakerFromSegments(speaker2Segments, speakerRoleMap)
              };
            }
          }
        } catch (error) {
          console.warn('‚ö†Ô∏è [runDebugAction] Could not get Speaker2 JSON:', error);
        }
        
        
        // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ —á–∞—Å—Ç–∏–Ω —Ñ—Ä–∞–∑–∏ –≤ –¥—ñ–∞–ª–æ–∑—ñ
        const checkPhraseSegments = (phrase, dialogue) => {
          const normDialogue = normalizeText(dialogue);
          const normPhrase = normalizeText(phrase);
          
          // 1. –ü–æ–≤–Ω–∞ –Ω–∞—è–≤–Ω—ñ—Å—Ç—å —è–∫ –ø—ñ–¥—Ä—è–¥–æ–∫
          if (normDialogue.includes(normPhrase)) {
            return "yes";
          }
          
          // 2. –°–ª–æ–≤–∞
          const dialogueWords = new Set(normDialogue.split(" "));
          const phraseWords = normPhrase.split(" ").filter(w => w.length > 0);
          
          let hasAnyWord = false;
          let segments = [];
          let currentSegmentWords = [];
          
          for (const w of phraseWords) {
            if (dialogueWords.has(w)) {
              hasAnyWord = true;
              // —è–∫—â–æ –∑–∞—Ä–∞–∑ –Ω–∞–∫–æ–ø–∏—á—É–≤–∞–≤—Å—è —Å–µ–≥–º–µ–Ω—Ç –≤—ñ–¥—Å—É—Ç–Ω—ñ—Ö —Å–ª—ñ–≤ ‚Äî –∑–∞–∫—Ä–∏–≤–∞—î–º–æ –π–æ–≥–æ
              if (currentSegmentWords.length > 0) {
                segments.push(currentSegmentWords.join(" "));
                currentSegmentWords = [];
              }
            } else {
              // —Å–ª–æ–≤–∞ –Ω–µ–º–∞—î –≤ –¥—ñ–∞–ª–æ–∑—ñ ‚Üí –¥–æ–¥–∞—î–º–æ –¥–æ –ø–æ—Ç–æ—á–Ω–æ–≥–æ —Å–µ–≥–º–µ–Ω—Ç–∞
              currentSegmentWords.push(w);
            }
          }
          
          // –∑–∞–∫—Ä–∏–≤–∞—î–º–æ –æ—Å—Ç–∞–Ω–Ω—ñ–π —Å–µ–≥–º–µ–Ω—Ç, —è–∫—â–æ —î
          if (currentSegmentWords.length > 0) {
            segments.push(currentSegmentWords.join(" "));
          }
          
          // 3. –Ø–∫—â–æ –≤–∑–∞–≥–∞–ª—ñ –Ω–µ–º–∞—î –∂–æ–¥–Ω–æ–≥–æ —Å–ª–æ–≤–∞ –∑ —Ñ—Ä–∞–∑–∏ ‚Üí no
          if (!hasAnyWord) {
            return "no";
          }
          
          // 4. –Ø–∫—â–æ —Å–µ–≥–º–µ–Ω—Ç—ñ–≤ –Ω–µ–º–∞—î, –∞–ª–µ –≤—Å—è —Ñ—Ä–∞–∑–∞ –Ω–µ —î –ø—ñ–¥—Ä—è–¥–∫–æ–º ‚Äî
          //    –∑–Ω–∞—á–∏—Ç—å —É—Å—ñ —Å–ª–æ–≤–∞ —î, –∞–ª–µ —Ä–æ–∑—ñ—Ä–≤–∞–Ω—ñ; —Ç–æ–¥—ñ –ø–æ–≤–µ—Ä—Ç–∞—î–º–æ –≤—Å—é —Ñ—Ä–∞–∑—É
          if (segments.length === 0) {
            return phrase;
          }
          
          // 5. –ü–æ–≤–µ—Ä—Ç–∞—î–º–æ –±–µ–∑–ø–µ—Ä–µ—Ä–≤–Ω—ñ –≤—ñ–¥—Ä—ñ–∑–∫–∏, –∫–æ–∂–µ–Ω –∑ –Ω–æ–≤–æ–≥–æ —Ä—è–¥–∫–∞
          return segments.join("\n");
        };
        
        // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è —Ä–æ–∑–±–∏—Ç—Ç—è —Ñ—Ä–∞–∑–∏ –Ω–∞ —Å–ø—ñ–≤–ø–∞–¥–∞—é—á—ñ —Ç–∞ –Ω–µ—Å–ø—ñ–≤–ø–∞–¥–∞—é—á—ñ —Å–µ–≥–º–µ–Ω—Ç–∏
        const splitPhraseIntoMatchingSegments = (phrase, dialogue) => {
          const normDialogue = normalizeText(dialogue);
          const normPhrase = normalizeText(phrase);
          const MIN_MATCH_WORDS = 3;
          
          // 1. –ü–æ–≤–Ω–∞ –Ω–∞—è–≤–Ω—ñ—Å—Ç—å —è–∫ –ø—ñ–¥—Ä—è–¥–æ–∫
          if (normDialogue.includes(normPhrase)) {
            return {
              matching: [phrase],
              nonMatching: []
            };
          }
          
          // 2. –†–æ–∑–±–∏–≤–∞—î–º–æ –Ω–∞ —Å–ª–æ–≤–∞
          const phraseWords = phrase.split(" ").filter(w => w.length > 0);
          
          // 3. –®—É–∫–∞—î–º–æ –Ω–∞–π–¥–æ–≤—à—ñ —Å–ø—ñ–≤–ø–∞–¥–∞—é—á—ñ —Å–µ–≥–º–µ–Ω—Ç–∏
          let matchingSegments = [];
          let nonMatchingSegments = [];
          let usedIndices = new Set();
          
          // –ü—Ä–æ—Ö–æ–¥–∏–º–æ –ø–æ –≤—Å—ñ—Ö –º–æ–∂–ª–∏–≤–∏—Ö –ø–æ—á–∞—Ç–∫–æ–≤–∏—Ö –ø–æ–∑–∏—Ü—ñ—è—Ö
          for (let start = 0; start < phraseWords.length; start++) {
            if (usedIndices.has(start)) continue;
            
            // –®—É–∫–∞—î–º–æ –Ω–∞–π–¥–æ–≤—à–∏–π —Å–µ–≥–º–µ–Ω—Ç, —è–∫–∏–π –ø–æ—á–∏–Ω–∞—î—Ç—å—Å—è –∑ —Ü—ñ—î—ó –ø–æ–∑–∏—Ü—ñ—ó —ñ —î –≤ –¥—ñ–∞–ª–æ–∑—ñ
            let bestMatch = null;
            let bestMatchLength = 0;
            
            // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —Å–µ–≥–º–µ–Ω—Ç–∏ –≤—ñ–¥ –Ω–∞–π–¥–æ–≤—à–∏—Ö –¥–æ –Ω–∞–π–∫–æ—Ä–æ—Ç—à–∏—Ö
            for (let length = phraseWords.length - start; length >= 1; length--) {
              const segment = phraseWords.slice(start, start + length).join(" ");
              const normalizedSegment = normalizeText(segment);
              
              if (normDialogue.includes(normalizedSegment)) {
                bestMatch = segment;
                bestMatchLength = length;
                break; // –ó–Ω–∞–π—à–ª–∏ –Ω–∞–π–¥–æ–≤—à–∏–π —Å–µ–≥–º–µ–Ω—Ç, –≤–∏—Ö–æ–¥–∏–º–æ
              }
            }
            
            if (bestMatch && bestMatchLength >= MIN_MATCH_WORDS) {
              matchingSegments.push(bestMatch);
              // –ü–æ–∑–Ω–∞—á–∞—î–º–æ –≤—Å—ñ —Å–ª–æ–≤–∞ —Ü—å–æ–≥–æ —Å–µ–≥–º–µ–Ω—Ç—É —è–∫ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω—ñ
              for (let i = start; i < start + bestMatchLength; i++) {
                usedIndices.add(i);
              }
            } else {
              // –Ø–∫—â–æ –∑–Ω–∞–π–¥–µ–Ω–∏–π —Å–µ–≥–º–µ–Ω—Ç –∑–∞–Ω–∞–¥—Ç–æ –∫–æ—Ä–æ—Ç–∫–∏–π –∞–±–æ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ –∑–±—ñ–≥—ñ–≤ - –≤–≤–∞–∂–∞—î–º–æ —Å–ª–æ–≤–æ –Ω–µ—Å–ø—ñ–≤–ø–∞–¥–∞—é—á–∏–º
              if (!usedIndices.has(start)) {
                nonMatchingSegments.push(phraseWords[start]);
                usedIndices.add(start);
              }
            }
          }
          
          // 4. –ó–±–∏—Ä–∞—î–º–æ –Ω–µ—Å–ø—ñ–≤–ø–∞–¥–∞—é—á—ñ —Å–µ–≥–º–µ–Ω—Ç–∏ (—Å–ª–æ–≤–∞, —è–∫—ñ –Ω–µ –±—É–ª–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω—ñ)
          let currentNonMatching = [];
          for (let i = 0; i < phraseWords.length; i++) {
            if (!usedIndices.has(i)) {
              currentNonMatching.push(phraseWords[i]);
            } else {
              // –Ø–∫—â–æ —Å–ª–æ–≤–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–µ, –∞–ª–µ –±—É–≤ –Ω–∞–∫–æ–ø–∏—á–µ–Ω–∏–π —Å–µ–≥–º–µ–Ω—Ç –Ω–µ—Å–ø—ñ–≤–ø–∞–¥–∞—é—á–∏—Ö - –∑–∞–∫—Ä–∏–≤–∞—î–º–æ –π–æ–≥–æ
              if (currentNonMatching.length > 0) {
                nonMatchingSegments.push(currentNonMatching.join(" "));
                currentNonMatching = [];
              }
            }
          }
          
          // –ó–∞–∫—Ä–∏–≤–∞—î–º–æ –æ—Å—Ç–∞–Ω–Ω—ñ–π –Ω–µ—Å–ø—ñ–≤–ø–∞–¥–∞—é—á–∏–π —Å–µ–≥–º–µ–Ω—Ç
          if (currentNonMatching.length > 0) {
            nonMatchingSegments.push(currentNonMatching.join(" "));
          }
          
          return {
            matching: matchingSegments,
            nonMatching: nonMatchingSegments
          };
        };
      
      const checkSegmentInSpeakerDialog = (segmentText, dialogData, expectedRoleNorm) => {
        if (!segmentText || !dialogData || !dialogData.text) {
          return { available: false, found: false };
        }
        
        const checkResult = checkPhraseSegments(segmentText, dialogData.text);
        const found = checkResult === 'yes' || checkResult === segmentText;
        if (!found) {
          return { available: true, found: false };
        }
        
        const roleNorm = dialogData.speakerNorm || null;
        let roleMatch = null;
        if (roleNorm && expectedRoleNorm) {
          roleMatch = roleNorm === expectedRoleNorm;
        }
        
        return {
          available: true,
          found: true,
          roleNorm,
          roleMatch
        };
      };
      
      const formatSegmentSpeakerLine = (speakerCheckInfo) => {
        if (!speakerCheckInfo) {
          return 'n/a';
        }
        
        if (speakerCheckInfo.available === false) {
          return 'n/a';
        }
        
        if (!speakerCheckInfo.found) {
          return 'no';
        }
        
        let line = 'yes';
        if (speakerCheckInfo.roleNorm) {
          line += ` (${formatRoleLabel(speakerCheckInfo.roleNorm, null)})`;
        }
        
        if (speakerCheckInfo.roleMatch === true) {
          line += ' Role match';
        } else if (speakerCheckInfo.roleMatch === false) {
          line += ' Role mismatch';
        }
        
        return line;
      };
      
      const determineSegmentColor = (speaker1Info, speaker2Info) => {
        const hasValidMatch = (info) => {
          if (!info) return false;
          if (!info.found) return false;
          if (info.roleMatch === false) return false;
          return true;
        };
        
        return (hasValidMatch(speaker1Info) || hasValidMatch(speaker2Info)) ? 'green' : 'red';
      };
        
        // 4. –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –∫–æ–∂–Ω—É —Ä–µ–ø–ª—ñ–∫—É
        const results = [];
        for (let i = 0; i < phrases.length; i++) {
          const phraseInfo = phrases[i];
          const phraseText = phraseInfo.text;
          const phraseDialogSlice = getDialogSliceForPhrase(phraseInfo, generalSegments, speakerRoleMap);
          const phraseDialogText = phraseDialogSlice?.text || dialog;
          const normalizedPhrase = normalizeText(phraseText);
          const normalizedSlice = normalizeText(phraseDialogText);
          const actualSpeakerGeneral = phraseDialogSlice?.speakerNorm || null;
          const generalRoleMatch = actualSpeakerGeneral && phraseInfo.speakerNorm
            ? actualSpeakerGeneral === phraseInfo.speakerNorm
            : null;
          
          // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –Ω–∞—è–≤–Ω—ñ—Å—Ç—å —Ñ—Ä–∞–∑–∏ –≤ –¥—ñ–∞–ª–æ–∑—ñ General JSON
          const phraseFound = normalizedSlice.includes(normalizedPhrase);
          
          // –Ø–∫—â–æ –∑–Ω–∞–π–¥–µ–Ω–∞, –ø–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ –≤–æ–Ω–∞ —î –≤ Blue
          let isBlue = false;
          if (phraseFound) {
            isBlue = isPhraseInBlue(phraseText);
          }
          
          // –Ø–∫—â–æ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∞ –≤ General JSON, –ø–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –≤ Speaker1 JSON
          let inSpeaker1 = false;
          let phraseSegmentsResult = null;
          let speaker1RoleMatch = null;
          let speaker1ActualRole = null;
          if (!phraseFound && speaker1Dialog) {
            phraseSegmentsResult = checkPhraseSegments(phraseText, speaker1Dialog.text);
            inSpeaker1 = (phraseSegmentsResult === "yes");
            speaker1ActualRole = speaker1Dialog.speakerNorm || null;
            if (speaker1ActualRole && phraseInfo.speakerNorm) {
              speaker1RoleMatch = speaker1ActualRole === phraseInfo.speakerNorm;
            }
          }
          
          // –Ø–∫—â–æ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∞ –≤ General JSON —ñ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∞ –≤ Speaker1, –ø–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –≤ Speaker2 JSON
          let inSpeaker2 = false;
          let phraseSegmentsResult2 = null;
          let speaker2RoleMatch = null;
          let speaker2ActualRole = null;
          if (!phraseFound && !inSpeaker1 && speaker2Dialog) {
            phraseSegmentsResult2 = checkPhraseSegments(phraseText, speaker2Dialog.text);
            inSpeaker2 = (phraseSegmentsResult2 === "yes");
            speaker2ActualRole = speaker2Dialog.speakerNorm || null;
            if (speaker2ActualRole && phraseInfo.speakerNorm) {
              speaker2RoleMatch = speaker2ActualRole === phraseInfo.speakerNorm;
            }
          }
          
          results.push({
            phrase: phraseText,
            expectedRoleNorm: phraseInfo.speakerNorm || null,
            found: phraseFound,
            isBlue: isBlue,
            inSpeaker1: inSpeaker1,
            inSpeaker2: inSpeaker2,
            phraseSegmentsResult: phraseSegmentsResult,
            phraseSegmentsResult2: phraseSegmentsResult2,
            speakerLabel: phraseInfo.speakerLabel,
            dialogSlice: phraseDialogText,
            generalRoleNorm: actualSpeakerGeneral,
            generalRoleMatch: generalRoleMatch,
            speaker1RoleMatch: speaker1RoleMatch,
            speaker1RoleNorm: speaker1ActualRole,
            speaker2RoleMatch: speaker2RoleMatch,
            speaker2RoleNorm: speaker2ActualRole
          });
        }
        
        // 5. –§–æ—Ä–º—É—î–º–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –¥–ª—è –≤–∏–≤–æ–¥—É
        let output = '';
        for (let i = 0; i < results.length; i++) {
          const result = results[i];
          const speakerSuffix = result.speakerLabel ? ` (${result.speakerLabel})` : '';
          output += `–†–µ–ø–ª—ñ–∫–∞ - ${result.phrase}${speakerSuffix}\n${result.found ? 'yes' : 'no'}`;
          
          // –Ø–∫—â–æ –∑–Ω–∞–π–¥–µ–Ω–∞ —ñ —î –≤ Blue, –¥–æ–¥–∞—î–º–æ "blue" –Ω–∞—Å—Ç—É–ø–Ω–∏–º —Ä—è–¥–∫–æ–º
          if (result.found && result.isBlue) {
            output += '\nblue';
          }

          if (result.generalRoleMatch !== null) {
            const expectedRole = formatRoleLabel(result.expectedRoleNorm, result.speakerLabel);
            const actualRole = formatRoleLabel(result.generalRoleNorm, null);
            output += `\nRole ${result.generalRoleMatch ? 'match' : 'mismatch'} (expected ${expectedRole}, actual ${actualRole})`;
            if (!result.generalRoleMatch) {
              output += '\nRed';
            }
          }
          
          // –Ø–∫—â–æ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∞, –ø–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –≤ Speaker1 JSON —ñ Speaker2 JSON
          if (!result.found) {
            const phraseContext = result.dialogSlice || dialog;
            let foundInAnyTrack = false;
            
            // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ Speaker1 JSON
            if (speaker1Dialog && result.inSpeaker1) {
              foundInAnyTrack = true;
              output += '\nResult is in Speaker 1 JSON';
              if (result.speakerLabel) {
                output += ` (${result.speakerLabel})`;
              }
              if (result.speaker1RoleMatch !== null) {
                const expectedRole = formatRoleLabel(result.expectedRoleNorm, result.speakerLabel);
                const actualRole = formatRoleLabel(result.speaker1RoleNorm, null);
                output += `\nRole ${result.speaker1RoleMatch ? 'match' : 'mismatch'} (expected ${expectedRole}, actual ${actualRole})`;
                if (!result.speaker1RoleMatch) {
                  output += '\nRed';
                } else if (result.speaker1RoleMatch && !result.found) {
                  // –Ø–∫—â–æ —Ä–æ–ª—å —Å–ø—ñ–≤–ø–∞–¥–∞—î —ñ —Ä–µ–ø–ª—ñ–∫–∏ –Ω–µ–º–∞—î –≤ –ø–µ—Ä—à–æ–º—É —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç—ñ, —Ü–µ green
                  output += '\ngreen';
                }
              }
            }
            
            // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ Speaker2 JSON (—è–∫—â–æ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ –≤ Speaker1)
            if (!foundInAnyTrack && speaker2Dialog && result.inSpeaker2) {
              foundInAnyTrack = true;
              output += '\nResult is in Speaker 2 JSON';
              if (result.speakerLabel) {
                output += ` (${result.speakerLabel})`;
              }
              if (result.speaker2RoleMatch !== null) {
                const expectedRole = formatRoleLabel(result.expectedRoleNorm, result.speakerLabel);
                const actualRole = formatRoleLabel(result.speaker2RoleNorm, null);
                output += `\nRole ${result.speaker2RoleMatch ? 'match' : 'mismatch'} (expected ${expectedRole}, actual ${actualRole})`;
                if (!result.speaker2RoleMatch) {
                  output += '\nRed';
                } else if (result.speaker2RoleMatch && !result.found) {
                  // –Ø–∫—â–æ —Ä–æ–ª—å —Å–ø—ñ–≤–ø–∞–¥–∞—î —ñ —Ä–µ–ø–ª—ñ–∫–∏ –Ω–µ–º–∞—î –≤ –ø–µ—Ä—à–æ–º—É —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç—ñ, —Ü–µ green
                  output += '\ngreen';
                }
              }
            }
            
            // –Ø–∫—â–æ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ –≤ –∂–æ–¥–Ω–æ–º—É —Ç—Ä–µ–∫—É
            if (!foundInAnyTrack) {
              output += '\nResult is absent in Speaker 1 JSON';
              if (speaker2Dialog) {
                output += '\nResult is absent in Speaker 2 JSON';
              }
              
              // –†–æ–∑–±–∏–≤–∞—î–º–æ –≤—Å—é —Ñ—Ä–∞–∑—É –Ω–∞ —Å–ø—ñ–≤–ø–∞–¥–∞—é—á—ñ —Ç–∞ –Ω–µ—Å–ø—ñ–≤–ø–∞–¥–∞—é—á—ñ —Å–µ–≥–º–µ–Ω—Ç–∏ –≤ –æ—Ä–∏–≥—ñ–Ω–∞–ª—å–Ω–æ–º—É –¥—ñ–∞–ª–æ–∑—ñ
              const segmentsResult = splitPhraseIntoMatchingSegments(result.phrase, phraseContext);
              
              // –í–∏–≤–æ–¥–∏–º–æ —Å–ø—ñ–≤–ø–∞–¥–∞—é—á—ñ —Ñ—Ä–∞–∑–∏
              if (segmentsResult.matching.length > 0) {
                output += '\n\n–°–ø—ñ–≤–ø–∞–¥–∞—é—Ç—å:';
                segmentsResult.matching.forEach(seg => {
                  output += '\n' + seg;
                });
              }
              
              // –í–∏–≤–æ–¥–∏–º–æ –Ω–µ—Å–ø—ñ–≤–ø–∞–¥–∞—é—á—ñ —Ñ—Ä–∞–∑–∏ –∑ –ø–µ—Ä–µ–≤—ñ—Ä–∫–æ—é –ø–æ —Ç—Ä–µ–∫–∞—Ö
              const nonMatchingDetails = segmentsResult.nonMatching.map(seg => {
                const speaker1Info = speaker1Dialog ? checkSegmentInSpeakerDialog(seg, speaker1Dialog, result.expectedRoleNorm) : null;
                const speaker2Info = speaker2Dialog ? checkSegmentInSpeakerDialog(seg, speaker2Dialog, result.expectedRoleNorm) : null;
                const color = determineSegmentColor(speaker1Info, speaker2Info);
                return {
                  text: seg,
                  speaker1Info,
                  speaker2Info,
                  color
                };
              });
              
              if (nonMatchingDetails.length > 0) {
                output += '\n\n–ù–µ —Å–ø—ñ–≤–ø–∞–¥–∞—é—Ç—å:';
                nonMatchingDetails.forEach(detail => {
                  output += '\n' + detail.text;
                  const speaker1Line = formatSegmentSpeakerLine(speaker1Dialog ? detail.speaker1Info : { available: false });
                  const speaker2Line = formatSegmentSpeakerLine(speaker2Dialog ? detail.speaker2Info : { available: false });
                  output += '\nSpeaker1 JSON: ' + speaker1Line;
                  output += '\nSpeaker2 JSON: ' + speaker2Line;
                  output += `\nColor: ${detail.color}`;
                  output += '\n';
                });
              }
              
              const allSegmentsRed = nonMatchingDetails.length > 0 && nonMatchingDetails.every(detail => detail.color === 'red');
              if ((segmentsResult.matching.length === 0 && nonMatchingDetails.length === 0) || allSegmentsRed) {
                output += '\n\n–ù–µ –∑–Ω–∞–π–¥–µ–Ω–æ –≤ –∂–æ–¥–Ω–æ–º—É –¥–∂–µ—Ä–µ–ª—ñ';
                output += '\nRed';
              }
            }
          }
          
          if (i < results.length - 1) {
            output += '\n\n';
          }
        }
        
        debugTextarea.value = output;
        
        console.log('‚úÖ [runDebugAction] Check completed:', {
          totalPhrases: phrases.length,
          foundCount: results.filter(r => r.found).length,
          notFoundCount: results.filter(r => !r.found).length,
          dialogLength: dialog.length
        });
        
      } catch (error) {
        console.error('‚ùå [runDebugAction] Error:', error);
        debugTextarea.value = `–ü–æ–º–∏–ª–∫–∞: ${error.message}`;
      } finally {
        // –í—ñ–¥–Ω–æ–≤–ª—é—î–º–æ –∫–Ω–æ–ø–∫—É
        btn.disabled = false;
        btn.style.opacity = '1';
        btn.style.cursor = 'pointer';
        btn.innerHTML = originalText;
      }
    }
    */
    
    // –£–Ω—ñ–≤–µ—Ä—Å–∞–ª—å–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—è –¥–ª—è –∞–Ω–∞–ª—ñ–∑—É –¥—ñ–∞–ª–æ–≥—É
    // –ü—Ä–∏–π–º–∞—î —Å–ø–∏—Å–æ–∫ —Ä—è–¥–∫—ñ–≤ –¥—ñ–∞–ª–æ–≥—É —Ç–∞ –ø–æ–≤–µ—Ä—Ç–∞—î JSON –∑ –∞–Ω–∞–ª—ñ–∑–æ–º
    async function analyzeDialogue(dialogueLines, fullDialogueLines, dialogueNumber, progressCallback, trackRole = null, segments = null) {
      if (!dialogueLines || dialogueLines.length === 0) {
        throw new Error('Dialogue lines are empty');
      }
      
      if (!fullDialogueLines || fullDialogueLines.length === 0) {
        throw new Error('Full dialogue context is empty');
      }
      
      // –§–æ—Ä–º—É—î–º–æ –±–∞–∑–æ–≤–∏–π –ø—Ä–æ–º–ø—Ç –¥–ª—è –≤–∏–∑–Ω–∞—á–µ–Ω–Ω—è —Ä–æ–ª—ñ —Ä–µ–ø–ª—ñ–∫–∏
      const basePromptTemplate = `# Prompt for Identifying Speaker Role in Context

You are analyzing a customer support dialogue. Your task is to determine the role of the speaker for ONE SPECIFIC LINE in the context of the entire conversation.

## Context:

- There are two participants: a support agent and a client

- Support agent represents the company and helps solve problems

- Client is the customer who needs assistance

## Your Task:

Based on the full dialogue context and the specific line provided, determine if the speaker of that line is "agent" or "client"

## Identification Criteria:

**Support Agent typically:**

- Opens conversation with greetings: "Thank you for calling", "How can I assist you"

- Asks for information: "May I have your account number", "Can you provide details"

- Offers solutions: "Try rebooting", "I'll keep the ticket open", "The tech team estimates"

- Uses professional closings: "Have a great day", "Thank you for calling"

- Provides acknowledgments: "I see...", "I understand", "Let me check"

- Takes action: "I'll escalate this", "Let me create a ticket"

**Client typically:**

- Describes problems: "I'm having trouble with", "It keeps dropping"

- Provides requested information: account numbers, problem details

- Asks about timeline: "When will it be fixed?", "How long will it take?"

- Follows instructions: "Okay, I'll do that", "It looks like it's working"

- Expresses gratitude: "Thank you for the help", "I appreciate the assistance"

## Input Format:

You will receive:

1. Full dialogue context (all lines from the conversation)

2. Specific line to analyze (marked with >>> at the beginning)

## Response Format:

Return ONLY one word: either "agent" or "client"

Do not return JSON, do not provide explanations. Only return: agent or client

## Example:

Input:

\`\`\`

Full dialogue:

Hello Thank you for calling acme support How can I assist you today

Hi I'm having trouble with my internet connection It keeps dropping

I see May I have your account number to look into this

Sure it's 12345

Analyze this line:

>>> I see May I have your account number to look into this

\`\`\`

Output: agent

## Full Dialogue:

${fullDialogueLines.join('\n')}

## Line to Analyze:

>>> `;
      
      // –û–±—Ä–æ–±–ª—è—î–º–æ –∫–æ–∂–µ–Ω —Ä—è–¥–æ–∫ –¥—ñ–∞–ª–æ–≥—É
      const dialogueAnalysis = [];
      
      // –°–æ—Ä—Ç—É—î–º–æ —Å–µ–≥–º–µ–Ω—Ç–∏ –∑–∞ —á–∞—Å–æ–º, —è–∫—â–æ –≤–æ–Ω–∏ —î
      let sortedSegments = null;
      if (segments && Array.isArray(segments) && segments.length > 0) {
        sortedSegments = [...segments].sort((a, b) => {
          const startA = parseFloat(a.start) || 0;
          const startB = parseFloat(b.start) || 0;
          return startA - startB;
        });
      }
      
      for (let i = 0; i < dialogueLines.length; i++) {
        const line = dialogueLines[i].trim();
        
        if (!line) {
          console.log(`‚è≠Ô∏è [ANALYZE] Skipping empty line ${i + 1}`);
          continue;
        }
        
        // –í–∏—Ç—è–≥—É—î–º–æ —Ç–µ–∫—Å—Ç —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∞ (–±–µ–∑ –ø—Ä–µ—Ñ—ñ–∫—Å—É —Å–ø—ñ–∫–µ—Ä–∞, —è–∫—â–æ —î)
        let fragmentText = line;
        const textMatch = line.match(/^[^:]+:\s*(.+)$/);
        if (textMatch) {
          fragmentText = textMatch[1].trim();
        }
        
        if (!fragmentText) {
          console.log(`‚è≠Ô∏è [ANALYZE] Skipping empty fragment ${i + 1}`);
          continue;
        }
        
        // –ó–Ω–∞—Ö–æ–¥–∏–º–æ –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–∏–π —Å–µ–≥–º–µ–Ω—Ç –¥–ª—è –æ—Ç—Ä–∏–º–∞–Ω–Ω—è start/end –∑ primary diarization
        let startTime = null;
        let endTime = null;
        
        if (sortedSegments && sortedSegments.length > 0) {
          // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –ø–æ–∫—Ä–∞—â–µ–Ω–æ—ó –Ω–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—ó —Ç–µ–∫—Å—Ç—É
          const normalizeTextForMatching = (text) => {
            if (!text) return '';
            return text
              .toLowerCase()
              .replace(/[^\w\s]/g, ' ')  // –í–∏–¥–∞–ª—è—î–º–æ –ø—É–Ω–∫—Ç—É–∞—Ü—ñ—é
              .replace(/\s+/g, ' ')       // –ù–æ—Ä–º–∞–ª—ñ–∑—É—î–º–æ –ø—Ä–æ–±—ñ–ª–∏
              .trim();
          };
          
          // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –æ–±—á–∏—Å–ª–µ–Ω–Ω—è —Å—Ö–æ–∂–æ—Å—Ç—ñ —Ç–µ–∫—Å—Ç—É (–ø—Ä–æ—Å—Ç–∏–π –∞–ª–≥–æ—Ä–∏—Ç–º –Ω–∞ –æ—Å–Ω–æ–≤—ñ —Å–ø—ñ–ª—å–Ω–∏—Ö —Å–ª—ñ–≤)
          const computeTextSimilarity = (text1, text2) => {
            const words1 = new Set(text1.split(/\s+/).filter(w => w.length > 2));
            const words2 = new Set(text2.split(/\s+/).filter(w => w.length > 2));
            if (words1.size === 0 && words2.size === 0) return 1;
            if (words1.size === 0 || words2.size === 0) return 0;
            
            const intersection = new Set([...words1].filter(w => words2.has(w)));
            const union = new Set([...words1, ...words2]);
            return intersection.size / union.size; // Jaccard similarity
          };
          
          // –ù–æ—Ä–º–∞–ª—ñ–∑—É—î–º–æ —Ç–µ–∫—Å—Ç —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∞ –¥–ª—è –ø–æ—à—É–∫—É
          const normalizedFragText = normalizeTextForMatching(fragmentText);
          
          // –í–∏–∑–Ω–∞—á–∞—î–º–æ –æ—á—ñ–∫—É–≤–∞–Ω—É —Ä–æ–ª—å —Å–ø—ñ–∫–µ—Ä–∞ –¥–ª—è —Ñ—ñ–ª—å—Ç—Ä–∞—Ü—ñ—ó (—è–∫—â–æ trackRole –≤—ñ–¥–æ–º–∏–π)
          const expectedRole = trackRole ? trackRole.toLowerCase() : null;
          
          // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏, —á–∏ —Å–µ–≥–º–µ–Ω—Ç –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—î –æ—á—ñ–∫—É–≤–∞–Ω—ñ–π —Ä–æ–ª—ñ
          const matchesExpectedRole = (seg) => {
            if (!expectedRole) return true;
            const segRole = (seg.role || '').toLowerCase();
            return segRole === expectedRole || 
                   (expectedRole === 'agent' && segRole === 'operator') ||
                   (expectedRole === 'client' && segRole === 'customer');
          };
          
          // –®—É–∫–∞—î–º–æ —Å–µ–≥–º–µ–Ω—Ç –∑ primary diarization, —è–∫–∏–π –º—ñ—Å—Ç–∏—Ç—å —Ü–µ–π —Ç–µ–∫—Å—Ç
          // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –∫—ñ–ª—å–∫–∞ —Å—Ç—Ä–∞—Ç–µ–≥—ñ–π –ø–æ—à—É–∫—É –¥–ª—è –∫—Ä–∞—â–æ—ó —Ç–æ—á–Ω–æ—Å—Ç—ñ
          let matchingSegment = null;
          let bestSimilarity = 0;
          const minSimilarity = 0.3; // –ú—ñ–Ω—ñ–º–∞–ª—å–Ω–∞ —Å—Ö–æ–∂—ñ—Å—Ç—å –¥–ª—è –ø—Ä–∏–π–Ω—è—Ç—Ç—è
          
          // –°—Ç—Ä–∞—Ç–µ–≥—ñ—è 1: –¢–æ—á–Ω–µ —Å–ø—ñ–≤–ø–∞–¥—ñ–Ω–Ω—è (–ø—ñ—Å–ª—è –Ω–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—ó) + –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞ —Ä–æ–ª—ñ
          matchingSegment = sortedSegments.find(seg => {
            if (!matchesExpectedRole(seg)) return false;
            const segText = normalizeTextForMatching(seg.text || '');
            return segText === normalizedFragText;
          });
          
          if (matchingSegment) {
            bestSimilarity = 1.0;
          }
          
          // –°—Ç—Ä–∞—Ç–µ–≥—ñ—è 2: –§—Ä–∞–≥–º–µ–Ω—Ç –º—ñ—Å—Ç–∏—Ç—å—Å—è –≤ —Å–µ–≥–º–µ–Ω—Ç—ñ –∞–±–æ –Ω–∞–≤–ø–∞–∫–∏ (—è–∫—â–æ –Ω–µ –∑–Ω–∞–π—à–ª–∏ —Ç–æ—á–Ω–µ —Å–ø—ñ–≤–ø–∞–¥—ñ–Ω–Ω—è)
          if (!matchingSegment) {
            sortedSegments.forEach(seg => {
              if (!matchesExpectedRole(seg)) return;
              const segText = normalizeTextForMatching(seg.text || '');
              
              // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —á–∏ —Ñ—Ä–∞–≥–º–µ–Ω—Ç –º—ñ—Å—Ç–∏—Ç—å—Å—è –≤ —Å–µ–≥–º–µ–Ω—Ç—ñ –∞–±–æ —Å–µ–≥–º–µ–Ω—Ç –º—ñ—Å—Ç–∏—Ç—å—Å—è —É —Ñ—Ä–∞–≥–º–µ–Ω—Ç—ñ
              if (segText.includes(normalizedFragText) || normalizedFragText.includes(segText)) {
                const minLength = Math.min(segText.length, normalizedFragText.length);
                if (minLength > 10 || segText === normalizedFragText) {
                  const similarity = computeTextSimilarity(segText, normalizedFragText);
                  if (similarity > bestSimilarity) {
                    bestSimilarity = similarity;
                    matchingSegment = seg;
                  }
                }
              }
            });
          }
          
          // –°—Ç—Ä–∞—Ç–µ–≥—ñ—è 3: –°—Ö–æ–∂—ñ—Å—Ç—å —Ç–µ–∫—Å—Ç—É –Ω–∞ –æ—Å–Ω–æ–≤—ñ —Å–ø—ñ–ª—å–Ω–∏—Ö —Å–ª—ñ–≤ (—è–∫—â–æ –ø–æ–ø–µ—Ä–µ–¥–Ω—ñ –Ω–µ —Å–ø—Ä–∞—Ü—é–≤–∞–ª–∏)
          if (!matchingSegment || bestSimilarity < minSimilarity) {
            sortedSegments.forEach(seg => {
              if (!matchesExpectedRole(seg)) return;
              const segText = normalizeTextForMatching(seg.text || '');
              const similarity = computeTextSimilarity(segText, normalizedFragText);
              
              if (similarity > bestSimilarity && similarity >= minSimilarity) {
                bestSimilarity = similarity;
                matchingSegment = seg;
              }
            });
          }
          
          // –°—Ç—Ä–∞—Ç–µ–≥—ñ—è 4: –Ø–∫—â–æ —Ä–æ–ª—å –Ω–µ–≤—ñ–¥–æ–º–∞ –∞–±–æ –Ω–µ –∑–Ω–∞–π—à–ª–∏ –∑ —Ñ—ñ–ª—å—Ç—Ä–æ–º, —à—É–∫–∞—î–º–æ –±–µ–∑ —Ñ—ñ–ª—å—Ç—Ä–∞ —Ä–æ–ª—ñ
          if (!matchingSegment || bestSimilarity < minSimilarity) {
            sortedSegments.forEach(seg => {
              const segText = normalizeTextForMatching(seg.text || '');
              
              // –¢–æ—á–Ω–µ —Å–ø—ñ–≤–ø–∞–¥—ñ–Ω–Ω—è
              if (segText === normalizedFragText) {
                const similarity = 1.0;
                if (similarity > bestSimilarity) {
                  bestSimilarity = similarity;
                  matchingSegment = seg;
                }
              }
              // –ß–∞—Å—Ç–∫–æ–≤–µ —Å–ø—ñ–≤–ø–∞–¥—ñ–Ω–Ω—è
              else if (segText.includes(normalizedFragText) && normalizedFragText.length > 10) {
                const similarity = computeTextSimilarity(segText, normalizedFragText);
                if (similarity > bestSimilarity) {
                  bestSimilarity = similarity;
                  matchingSegment = seg;
                }
              }
              // –ê–±–æ –Ω–∞–≤–ø–∞–∫–∏
              else if (normalizedFragText.includes(segText) && segText.length > 10) {
                const similarity = computeTextSimilarity(segText, normalizedFragText);
                if (similarity > bestSimilarity) {
                  bestSimilarity = similarity;
                  matchingSegment = seg;
                }
              }
              // –°—Ö–æ–∂—ñ—Å—Ç—å –∑–∞ –∫–ª—é—á–æ–≤–∏–º–∏ —Å–ª–æ–≤–∞–º–∏
              else {
                const similarity = computeTextSimilarity(segText, normalizedFragText);
                if (similarity > bestSimilarity && similarity >= minSimilarity) {
                  bestSimilarity = similarity;
                  matchingSegment = seg;
                }
              }
            });
          }
          
          if (matchingSegment && bestSimilarity >= minSimilarity) {
            startTime = typeof matchingSegment.start === 'number' ? matchingSegment.start : parseFloat(matchingSegment.start);
            endTime = typeof matchingSegment.end === 'number' ? matchingSegment.end : parseFloat(matchingSegment.end);
            
            // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –≤–∞–ª—ñ–¥–Ω—ñ—Å—Ç—å –∑–Ω–∞—á–µ–Ω—å
            if (isNaN(startTime)) startTime = null;
            if (isNaN(endTime)) endTime = null;
            
            const segRole = matchingSegment.role || 'unknown';
            const segSpeaker = matchingSegment.speaker || 'unknown';
            console.log(`üîç [ANALYZE] Found matching segment for "${fragmentText.substring(0, 40)}...": start=${startTime}, end=${endTime}, speaker=${segSpeaker}, role=${segRole}, similarity=${(bestSimilarity * 100).toFixed(1)}%`);
          } else {
            // –õ–æ–≥—É—î–º–æ –¥–µ—Ç–∞–ª—å–Ω—É —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –¥–ª—è –≤—ñ–¥–ª–∞–≥–æ–¥–∂–µ–Ω–Ω—è
            const sampleSegments = sortedSegments.slice(0, 3).map(seg => ({
              text: (seg.text || '').substring(0, 50),
              role: seg.role,
              start: seg.start
            }));
            console.warn(`‚ö†Ô∏è [ANALYZE] No matching segment found for fragment: "${fragmentText.substring(0, 50)}..." (expected role: ${expectedRole || 'any'}, best similarity: ${(bestSimilarity * 100).toFixed(1)}%)`);
            console.warn(`‚ö†Ô∏è [ANALYZE] Sample primary segments:`, sampleSegments);
          }
        }
        
        // –§–æ—Ä–º—É—î–º–æ –ø—Ä–æ–º–ø—Ç –¥–ª—è —Ü—å–æ–≥–æ —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∞
        const prompt = basePromptTemplate + fragmentText;
        
        console.log(`üîÑ [ANALYZE] Processing line ${i + 1}/${dialogueLines.length}: ${fragmentText.substring(0, 50)}...`);
        
        // –í–∏–∫–ª–∏–∫–∞—î–º–æ callback –¥–ª—è –æ–Ω–æ–≤–ª–µ–Ω–Ω—è –ø—Ä–æ–≥—Ä–µ—Å—É
        if (progressCallback) {
          progressCallback(`Processing ${i + 1}/${dialogueLines.length}...`);
        }
        
        // –í—ñ–¥–ø—Ä–∞–≤–ª—è—î–º–æ –∑–∞–ø–∏—Ç –Ω–∞ —Å–µ—Ä–≤–µ—Ä
        const response = await fetch('/api/debug-llm-query', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            prompt: prompt
          })
        });
        
        if (!response.ok) {
          const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
          throw new Error(`HTTP ${response.status}: ${errorData.error || 'Unknown error'}`);
        }
        
        const result = await response.json();
        
        if (!result.success) {
          throw new Error(result.error || 'LLM query failed');
        }
        
        // –û—Ç—Ä–∏–º—É—î–º–æ —Ä–æ–ª—å –≤—ñ–¥ LLM
        const role = result.result.trim().toLowerCase();
        
        console.log(`‚úÖ [ANALYZE] Line ${i + 1} role: ${role}`, startTime !== null ? `(start: ${startTime}, end: ${endTime})` : '');
        
        // –î–æ–¥–∞—î–º–æ –¥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤ –∑ —á–∞—Å–æ–º
        dialogueAnalysis.push({
          dialogueNumber: dialogueNumber,
          fragmentNumber: i + 1,
          fragment: fragmentText,
          role: role,
          start: startTime,
          end: endTime
        });
      }
      
      console.log(`‚úÖ [ANALYZE] Completed processing ${dialogueAnalysis.length} lines`);
      
      // –í–∏–∑–Ω–∞—á–∞—î–º–æ —Ç–∏–ø –¥—ñ–∞–ª–æ–≥—É
      if (progressCallback) {
        progressCallback('Determining dialogue type...');
      }
      
      let dialogueType = null;
      
      // –ü—Ä—ñ–æ—Ä–∏—Ç–µ—Ç 1: –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ —Ä–æ–ª—å –∑ –º–µ—Ç–∞–¥–∞–Ω–∏—Ö —Ç—Ä–µ–∫—É (–Ω–∞–π–Ω–∞–¥—ñ–π–Ω—ñ—à–µ)
      if (trackRole) {
        // –ù–æ—Ä–º–∞–ª—ñ–∑—É—î–º–æ —Ä–æ–ª—å
        const normalizedRole = trackRole.toLowerCase();
        if (normalizedRole === 'operator' || normalizedRole === 'agent') {
          dialogueType = 'agent';
        } else if (normalizedRole === 'client' || normalizedRole === 'customer') {
          dialogueType = 'client';
        }
        console.log(`üìä [ANALYZE] Using track role from metadata: ${trackRole} ‚Üí ${dialogueType}`);
      }
      
      // –§—ñ–ª—å—Ç—Ä—É—î–º–æ —Å–µ–≥–º–µ–Ω—Ç–∏, –∑–∞–ª–∏—à–∞—é—á–∏ —Ç—ñ–ª—å–∫–∏ —Ç—ñ, —â–æ –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—é—Ç—å —Ä–æ–ª—ñ —Ç—Ä–µ–∫—É
      if (dialogueType) {
        const beforeFilterCount = dialogueAnalysis.length;
        const filteredAnalysis = dialogueAnalysis.filter(item => {
          return item.role === dialogueType;
        });
        
        // –û–Ω–æ–≤–ª—é—î–º–æ –Ω–æ–º–µ—Ä–∏ —Ñ—Ä–∞–≥–º–µ–Ω—Ç—ñ–≤ –ø—ñ—Å–ª—è —Ñ—ñ–ª—å—Ç—Ä–∞—Ü—ñ—ó
        filteredAnalysis.forEach((item, index) => {
          item.fragmentNumber = index + 1;
        });
        
        console.log(`üîç [ANALYZE] Filtered segments: ${beforeFilterCount} ‚Üí ${filteredAnalysis.length} (removed ${beforeFilterCount - filteredAnalysis.length} segments with role !== "${dialogueType}")`);
        
        // –ó–∞–º—ñ–Ω—é—î–º–æ dialogueAnalysis –Ω–∞ –≤—ñ–¥—Ñ—ñ–ª—å—Ç—Ä–æ–≤–∞–Ω–∏–π –º–∞—Å–∏–≤
        dialogueAnalysis.length = 0;
        dialogueAnalysis.push(...filteredAnalysis);
      } else {
        console.log(`‚ö†Ô∏è [ANALYZE] Cannot filter segments: dialogueType not determined`);
      }
      
      // –ü—Ä—ñ–æ—Ä–∏—Ç–µ—Ç 2: –Ø–∫—â–æ –Ω–µ–º–∞—î –º–µ—Ç–∞–¥–∞–Ω–∏—Ö, –ø—ñ–¥—Ä–∞—Ö–æ–≤—É—î–º–æ —Ä–æ–ª—ñ –∑ –∞–Ω–∞–ª—ñ–∑—É
      if (!dialogueType) {
        const roleCounts = dialogueAnalysis.reduce((acc, item) => {
          const role = item.role || 'unknown';
          acc[role] = (acc[role] || 0) + 1;
          return acc;
        }, {});
        
        const agentCount = roleCounts.agent || 0;
        const clientCount = roleCounts.client || 0;
        
        console.log(`üìä [ANALYZE] Role counts from analysis:`, {
          agent: agentCount,
          client: clientCount,
          total: dialogueAnalysis.length
        });
        
        // –í–∏–∑–Ω–∞—á–∞—î–º–æ —Ç–∏–ø –¥—ñ–∞–ª–æ–≥—É –Ω–∞ –æ—Å–Ω–æ–≤—ñ –ø–µ—Ä–µ–≤–∞–∂–∞—é—á–æ—ó —Ä–æ–ª—ñ
        // –Ø–∫—â–æ –∫—ñ–ª—å–∫—ñ—Å—Ç—å –æ–¥–Ω–∞–∫–æ–≤–∞, –ø–µ—Ä–µ–≤–∞–≥–∞ –Ω–∞–¥–∞—î—Ç—å—Å—è agent
        dialogueType = agentCount >= clientCount ? 'agent' : 'client';
        
        console.log(`‚úÖ [ANALYZE] Dialogue type determined from analysis: ${dialogueType} (agent: ${agentCount}, client: ${clientCount})`);
      }
      
      // Fallback: —è–∫—â–æ –≤—Å–µ —â–µ –Ω–µ –≤–∏–∑–Ω–∞—á–µ–Ω–æ, –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º
      if (!dialogueType) {
        dialogueType = 'agent'; // –ó–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º
        console.log(`‚ö†Ô∏è [ANALYZE] Dialogue type not determined, using default: ${dialogueType}`);
      }
      
      // –ü–æ—Å—Ç-–æ–±—Ä–æ–±–∫–∞: –≤–∏–ø—Ä–∞–≤–ª–µ–Ω–Ω—è –∫–æ–Ω—Ñ–ª—ñ–∫—Ç—ñ–≤ —á–µ—Ä–µ–∑ LLM
      if (progressCallback) {
        progressCallback('Fixing conflicts with LLM...');
      }
      await fixConflictsWithLLM(dialogueAnalysis, fullDialogueLines, dialogueNumber, progressCallback);
      
      // –§–æ—Ä–º—É—î–º–æ —Ñ—ñ–Ω–∞–ª—å–Ω–∏–π JSON –∑ —É—Å—ñ–º–∞ –¥–∞–Ω–∏–º–∏
      return {
        dialogueNumber: dialogueNumber,
        dialogueType: dialogueType,
        dialogueAnalysis: dialogueAnalysis
      };
    }
    
    // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –≤–∏–ø—Ä–∞–≤–ª–µ–Ω–Ω—è –∫–æ–Ω—Ñ–ª—ñ–∫—Ç—ñ–≤ —á–µ—Ä–µ–∑ LLM
    async function fixConflictsWithLLM(dialogueAnalysis, fullDialogueLines, dialogueNumber, progressCallback) {
      if (!dialogueAnalysis || dialogueAnalysis.length < 2) {
        return; // –ù–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ —Å–µ–≥–º–µ–Ω—Ç—ñ–≤ –¥–ª—è –∫–æ–Ω—Ñ–ª—ñ–∫—Ç—ñ–≤
      }
      
      // –ó–Ω–∞—Ö–æ–¥–∏–º–æ –∫–æ–Ω—Ñ–ª—ñ–∫—Ç–∏: –ø–µ—Ä–µ–∫—Ä–∏—Ç—Ç—è —Ç–∞–π–º—Å—Ç–µ–º–ø—ñ–≤ + —Å—Ö–æ–∂–∏–π —Ç–µ–∫—Å—Ç
      const conflicts = [];
      
      for (let i = 0; i < dialogueAnalysis.length; i++) {
        const segA = dialogueAnalysis[i];
        if (!segA.start || !segA.end) continue;
        
        const startA = parseFloat(segA.start);
        const endA = parseFloat(segA.end);
        const textA = (segA.fragment || '').trim().toLowerCase();
        
        for (let j = i + 1; j < dialogueAnalysis.length; j++) {
          const segB = dialogueAnalysis[j];
          if (!segB.start || !segB.end) continue;
          
          const startB = parseFloat(segB.start);
          const endB = parseFloat(segB.end);
          const textB = (segB.fragment || '').trim().toLowerCase();
          
          // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –ø–µ—Ä–µ–∫—Ä–∏—Ç—Ç—è —Ç–∞–π–º—Å—Ç–µ–º–ø—ñ–≤
          const overlapStart = Math.max(startA, startB);
          const overlapEnd = Math.min(endA, endB);
          const overlapDuration = Math.max(0, overlapEnd - overlapStart);
          
          if (overlapDuration <= 0) continue;
          
          // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —Å—Ö–æ–∂—ñ—Å—Ç—å —Ç–µ–∫—Å—Ç—É
          const textSimilarity = computeTextSimilarityForConflicts(textA, textB);
          const oneContainsOther = textA.includes(textB) || textB.includes(textA);
          
          // –Ø–∫—â–æ —î –ø–µ—Ä–µ–∫—Ä–∏—Ç—Ç—è —Ç–∞–π–º—Å—Ç–µ–º–ø—ñ–≤ —ñ —Å—Ö–æ–∂–∏–π —Ç–µ–∫—Å—Ç - —Ü–µ –∫–æ–Ω—Ñ–ª—ñ–∫—Ç
          if (overlapDuration > 0.1 && (textSimilarity > 0.5 || oneContainsOther)) {
            conflicts.push({
              segmentA: segA,
              segmentB: segB,
              overlapDuration: overlapDuration,
              textSimilarity: textSimilarity
            });
          }
        }
      }
      
      if (conflicts.length === 0) {
        console.log(`‚úÖ [FIX_CONFLICTS] No conflicts found`);
        return;
      }
      
      console.log(`üîç [FIX_CONFLICTS] Found ${conflicts.length} conflict(s), resolving with LLM...`);
      
      // –í–∏—Ä—ñ—à—É—î–º–æ –∫–æ–∂–µ–Ω –∫–æ–Ω—Ñ–ª—ñ–∫—Ç —á–µ—Ä–µ–∑ LLM
      const segmentsToRemove = new Set();
      
      for (let idx = 0; idx < conflicts.length; idx++) {
        const conflict = conflicts[idx];
        const { segmentA, segmentB } = conflict;
        
        if (progressCallback) {
          progressCallback(`Resolving conflict ${idx + 1}/${conflicts.length}...`);
        }
        
        // –§–æ—Ä–º—É—î–º–æ –∫–æ–º–ø–∞–∫—Ç–Ω–∏–π –ø—Ä–æ–º–ø—Ç –¥–ª—è LLM (–º—ñ–Ω—ñ–º—É–º —Ç–æ–∫–µ–Ω—ñ–≤, –º–∞–∫—Å–∏–º—É–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—É)
        // –ë–µ—Ä–µ–º–æ —Ç—ñ–ª—å–∫–∏ —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω–∏–π –∫–æ–Ω—Ç–µ–∫—Å—Ç –Ω–∞–≤–∫–æ–ª–æ –∫–æ–Ω—Ñ–ª—ñ–∫—Ç–Ω–∏—Ö —Å–µ–≥–º–µ–Ω—Ç—ñ–≤
        const contextWindow = 3; // –ö—ñ–ª—å–∫—ñ—Å—Ç—å —Å–µ–≥–º–µ–Ω—Ç—ñ–≤ –¥–æ —ñ –ø—ñ—Å–ª—è –∫–æ–Ω—Ñ–ª—ñ–∫—Ç—É –¥–ª—è –∫–æ–Ω—Ç–µ–∫—Å—Ç—É
        const conflictIndexA = dialogueAnalysis.indexOf(segmentA);
        const conflictIndexB = dialogueAnalysis.indexOf(segmentB);
        const minIndex = Math.max(0, Math.min(conflictIndexA, conflictIndexB) - contextWindow);
        const maxIndex = Math.min(dialogueAnalysis.length - 1, Math.max(conflictIndexA, conflictIndexB) + contextWindow);
        
        const relevantContext = dialogueAnalysis
          .slice(minIndex, maxIndex + 1)
          .map((seg, idx) => `${minIndex + idx + 1}. [${seg.start || '?'}-${seg.end || '?'}s] ${seg.role}: ${seg.fragment}`)
          .join('\n');
        
        const conflictPrompt = `Resolve conflict in customer support dialogue.

Context (nearby segments):
${relevantContext}

Conflict:
A: [${segmentA.start}-${segmentA.end}s] ${segmentA.role}: "${segmentA.fragment}"
B: [${segmentB.start}-${segmentB.end}s] ${segmentB.role}: "${segmentB.fragment}"

Task: Which segment is correct? If one is duplicate/partial of another, keep the complete one.

Return JSON only:
{"keep":"A"|"B","correctRole":"agent"|"client"}`;

        try {
          const response = await fetch('/api/debug-llm-query', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              prompt: conflictPrompt
            })
          });
          
          if (!response.ok) {
            console.warn(`‚ö†Ô∏è [FIX_CONFLICTS] Failed to resolve conflict ${idx + 1}: HTTP ${response.status}`);
            continue;
          }
          
          const result = await response.json();
          
          if (!result.success) {
            console.warn(`‚ö†Ô∏è [FIX_CONFLICTS] LLM query failed for conflict ${idx + 1}: ${result.error}`);
            continue;
          }
          
          // –ü–∞—Ä—Å–∏–º–æ –≤—ñ–¥–ø–æ–≤—ñ–¥—å LLM
          let llmResponse;
          try {
            // –°–ø—Ä–æ–±—É—î–º–æ –≤–∏—Ç—è–≥—Ç–∏ JSON –∑ –≤—ñ–¥–ø–æ–≤—ñ–¥—ñ
            const responseText = result.result.trim();
            const jsonMatch = responseText.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
              llmResponse = JSON.parse(jsonMatch[0]);
            } else {
              llmResponse = JSON.parse(responseText);
            }
          } catch (parseError) {
            console.warn(`‚ö†Ô∏è [FIX_CONFLICTS] Failed to parse LLM response for conflict ${idx + 1}:`, result.result);
            continue;
          }
          
          // –í–∏–¥–∞–ª—è—î–º–æ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∏–π —Å–µ–≥–º–µ–Ω—Ç
          const segmentToRemove = llmResponse.keep === 'A' ? segmentB : segmentA;
          const segmentToKeep = llmResponse.keep === 'A' ? segmentA : segmentB;
          
          // –û–Ω–æ–≤–ª—é—î–º–æ —Ä–æ–ª—å —Å–µ–≥–º–µ–Ω—Ç–∞, —è–∫—â–æ LLM –≤–∫–∞–∑–∞–≤ –ø—Ä–∞–≤–∏–ª—å–Ω—É
          if (llmResponse.correctRole && (llmResponse.correctRole === 'agent' || llmResponse.correctRole === 'client')) {
            segmentToKeep.role = llmResponse.correctRole;
          }
          
          segmentsToRemove.add(segmentToRemove);
          
          console.log(`‚úÖ [FIX_CONFLICTS] Resolved conflict ${idx + 1}: keeping segment ${llmResponse.keep}, reason: ${llmResponse.reason || 'N/A'}`);
        } catch (error) {
          console.error(`‚ùå [FIX_CONFLICTS] Error resolving conflict ${idx + 1}:`, error);
        }
      }
      
      // –í–∏–¥–∞–ª—è—î–º–æ —Å–µ–≥–º–µ–Ω—Ç–∏, —è–∫—ñ LLM –≤–∏–∑–Ω–∞—á–∏–≤ —è–∫ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ñ
      if (segmentsToRemove.size > 0) {
        const beforeCount = dialogueAnalysis.length;
        const filtered = dialogueAnalysis.filter(seg => !segmentsToRemove.has(seg));
        
        // –û–Ω–æ–≤–ª—é—î–º–æ –Ω–æ–º–µ—Ä–∏ —Ñ—Ä–∞–≥–º–µ–Ω—Ç—ñ–≤
        filtered.forEach((item, index) => {
          item.fragmentNumber = index + 1;
        });
        
        dialogueAnalysis.length = 0;
        dialogueAnalysis.push(...filtered);
        
        console.log(`‚úÖ [FIX_CONFLICTS] Removed ${beforeCount - filtered.length} conflicting segment(s)`);
      }
    }
    
    // –î–æ–ø–æ–º—ñ–∂–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—è –¥–ª—è –æ–±—á–∏—Å–ª–µ–Ω–Ω—è —Å—Ö–æ–∂–æ—Å—Ç—ñ —Ç–µ–∫—Å—Ç—É –¥–ª—è –∫–æ–Ω—Ñ–ª—ñ–∫—Ç—ñ–≤
    function computeTextSimilarityForConflicts(text1, text2) {
      if (!text1 || !text2) return 0;
      
      // –ù–æ—Ä–º–∞–ª—ñ–∑—É—î–º–æ —Ç–µ–∫—Å—Ç–∏
      const normalize = (t) => t.toLowerCase().replace(/[^\w\s]/g, ' ').replace(/\s+/g, ' ').trim();
      const norm1 = normalize(text1);
      const norm2 = normalize(text2);
      
      // –¢–æ—á–Ω–µ —Å–ø—ñ–≤–ø–∞–¥—ñ–Ω–Ω—è
      if (norm1 === norm2) return 1.0;
      
      // –û–¥–∏–Ω –º—ñ—Å—Ç–∏—Ç—å—Å—è –≤ —ñ–Ω—à–æ–º—É
      if (norm1.includes(norm2) || norm2.includes(norm1)) {
        const shorter = norm1.length < norm2.length ? norm1 : norm2;
        const longer = norm1.length >= norm2.length ? norm1 : norm2;
        return shorter.length / longer.length;
      }
      
      // –û–±—á–∏—Å–ª—é—î–º–æ —Å—Ö–æ–∂—ñ—Å—Ç—å –∑–∞ —Å–ø—ñ–ª—å–Ω–∏–º–∏ —Å–ª–æ–≤–∞–º–∏ (Jaccard)
      const words1 = new Set(norm1.split(/\s+/).filter(w => w.length > 2));
      const words2 = new Set(norm2.split(/\s+/).filter(w => w.length > 2));
      
      if (words1.size === 0 || words2.size === 0) return 0;
      
      const intersection = new Set([...words1].filter(w => words2.has(w)));
      const union = new Set([...words1, ...words2]);
      
      return intersection.size / union.size;
    }
    
    // –ù–æ–≤–∞ —Ñ—É–Ω–∫—Ü—ñ—è –¥–ª—è –¥–µ–±–∞–≥—É –∫–Ω–æ–ø–∫–∏ Run
    // –§—É–Ω–∫—Ü—ñ—ó –¥–ª—è –∫–µ—Ä—É–≤–∞–Ω–Ω—è –ø—Ä–æ–≥—Ä–µ—Å–±–∞—Ä–æ–º –≥–µ–Ω–µ—Ä–∞—Ü—ñ—ó —Ç–∞–±–ª–∏—Ü—ñ
    let tableGenerationProgressInterval = null;
    let tableGenerationStartTime = null;
    
    function showTableGenerationProgress() {
      const container = document.getElementById('markdownTableContainer');
      if (!container) return;
      
      // –û—á–∏—â–∞—î–º–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä
      container.innerHTML = '';
      
      // –°—Ç–≤–æ—Ä—é—î–º–æ –ø—Ä–æ–≥—Ä–µ—Å–±–∞—Ä
      const progressHTML = `
        <div id="tableGenerationProgress" style="padding: 20px; text-align: center;">
          <div style="font-size: 16px; font-weight: 600; color: #2c3e50; margin-bottom: 15px;">
            Generating table...
          </div>
          <div style="background: #e0e0e0; border-radius: 10px; height: 20px; overflow: hidden; position: relative; margin-bottom: 10px;">
            <div id="tableGenerationProgressBar" style="background: linear-gradient(90deg, #3498db, #2ecc71); height: 100%; width: 0%; transition: width 0.3s ease; border-radius: 10px;"></div>
          </div>
          <div id="tableGenerationProgressText" style="font-size: 12px; color: #7f8c8d;">
            0%
          </div>
        </div>
      `;
      container.innerHTML = progressHTML;
      
      // –ó–∞–ø—É—Å–∫–∞—î–º–æ —Ç–∞–π–º–µ—Ä
      tableGenerationStartTime = Date.now();
      const maxDuration = 90000; // 90 —Å–µ–∫—É–Ω–¥
      
      tableGenerationProgressInterval = setInterval(() => {
        const elapsed = Date.now() - tableGenerationStartTime;
        const progress = Math.min((elapsed / maxDuration) * 100, 100);
        
        const progressBar = document.getElementById('tableGenerationProgressBar');
        const progressText = document.getElementById('tableGenerationProgressText');
        
        if (progressBar) {
          progressBar.style.width = progress + '%';
        }
        if (progressText) {
          progressText.textContent = Math.round(progress) + '%';
        }
        
        // –Ø–∫—â–æ –¥–æ—Å—è–≥–ª–∏ 100%, –∑—É–ø–∏–Ω—è—î–º–æ —ñ–Ω—Ç–µ—Ä–≤–∞–ª
        if (progress >= 100) {
          clearInterval(tableGenerationProgressInterval);
          tableGenerationProgressInterval = null;
        }
      }, 100); // –û–Ω–æ–≤–ª—é—î–º–æ –∫–æ–∂–Ω—ñ 100–º—Å
    }
    
    function hideTableGenerationProgress() {
      if (tableGenerationProgressInterval) {
        clearInterval(tableGenerationProgressInterval);
        tableGenerationProgressInterval = null;
      }
      
      // –ó–∞–≤–µ—Ä—à—É—î–º–æ –ø—Ä–æ–≥—Ä–µ—Å–±–∞—Ä –¥–æ 100%, —è–∫—â–æ –≤—ñ–Ω —â–µ –Ω–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–π
      const progressBar = document.getElementById('tableGenerationProgressBar');
      const progressText = document.getElementById('tableGenerationProgressText');
      
      if (progressBar) {
        progressBar.style.width = '100%';
      }
      if (progressText) {
        progressText.textContent = '100%';
      }
      
      tableGenerationStartTime = null;
      
      // –ü—Ä–æ–≥—Ä–µ—Å–±–∞—Ä –±—É–¥–µ –∑–∞–º—ñ–Ω–µ–Ω–∏–π —Ç–∞–±–ª–∏—Ü–µ—é –≤ applyDebugMarkup, —Ç–æ–º—É –Ω–µ –ø–æ—Ç—Ä—ñ–±–Ω–æ –π–æ–≥–æ –≤–∏–¥–∞–ª—è—Ç–∏ —Ç—É—Ç
    }
    
    async function runDebugActionNew() {
      const startTime = Date.now();
      console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
      console.log('üöÄ [runDebugActionNew] STARTING');
      console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
      
      const btn = document.getElementById('runBtn');
      const debugTextarea = document.getElementById('debugTextarea');
      const groundTruthTextarea = document.getElementById('groundTruthTextarea');
      
      console.log('üìã [runDebugActionNew] Initial state:', {
        btn: !!btn,
        debugTextarea: !!debugTextarea,
        groundTruthTextarea: !!groundTruthTextarea,
        groundTruthValue: groundTruthTextarea ? {
          hasValue: !!groundTruthTextarea.value,
          length: groundTruthTextarea.value?.length || 0,
          preview: groundTruthTextarea.value?.substring(0, 50) || 'empty'
        } : 'not found'
      });
      
      // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ —Ñ—ñ–∫—Å–æ–≤–∞–Ω–∏–π —Ç–µ–∫—Å—Ç –¥–ª—è –∫–Ω–æ–ø–∫–∏ –∑–∞–º—ñ—Å—Ç—å innerHTML
      const originalText = '‚ñ∂Ô∏è Run';
      const isAutoRun = !btn || !debugTextarea; // Auto-run if elements not found (called from showResults)
      
      // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ —Ü–µ –≤–∏–∫–ª–∏–∫ –∑ –º–æ–¥–∞–ª—å–Ω–æ–≥–æ –≤—ñ–∫–Ω–∞ ground truth
      const isGroundTruthMode = groundTruthTextarea && groundTruthTextarea.value && groundTruthTextarea.value.trim();
      
      console.log('üìã [runDebugActionNew] Mode detection:', {
        isAutoRun: isAutoRun,
        isGroundTruthMode: isGroundTruthMode
      });
      
      if (isGroundTruthMode) {
        // –†–µ–∂–∏–º ground truth: –∫–æ–Ω–≤–µ—Ä—Ç—É—î–º–æ —Ç–µ–∫—Å—Ç —É –º–∞—Å–∏–≤ —Ä–µ–ø–ª—ñ–∫
        console.log('üìã [runDebugActionNew] Entering GROUND TRUTH MODE');
        try {
          if (btn) {
            console.log('üìã [runDebugActionNew] Updating button state...');
            btn.disabled = true;
            btn.style.opacity = '0.6';
            btn.style.cursor = 'not-allowed';
            btn.innerHTML = '‚è≥ Processing...';
          }
          
          const inputText = groundTruthTextarea.value.trim();
          console.log('üìã [runDebugActionNew] STEP 1: Processing ground truth text with LLM...', {
            textLength: inputText.length,
            preview: inputText.substring(0, 100)
          });
          
          // –†–æ–∑–±–∏–≤–∞—î–º–æ —Ç–µ–∫—Å—Ç –Ω–∞ —Ä—è–¥–∫–∏
          const lines = inputText.split('\n').filter(line => line.trim());
          
          if (lines.length === 0) {
            throw new Error('–¢–µ–∫—Å—Ç –ø–æ—Ä–æ–∂–Ω—ñ–π. –ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ —Ñ–æ—Ä–º–∞—Ç –≤–≤–æ–¥—É.');
          }
          
          console.log(`üîÑ [runDebugActionNew] Processing ${lines.length} lines with LLM...`);
          
          // –û–±—Ä–æ–±–ª—è—î–º–æ –∫–æ–∂–µ–Ω —Ä—è–¥–æ–∫ —á–µ—Ä–µ–∑ LLM
          const replicasArray = [];
          
          for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();
            if (!line) continue;
            
            if (btn) {
              btn.innerHTML = `‚è≥ Processing line ${i + 1}/${lines.length}...`;
            }
            
            console.log(`üîÑ [runDebugActionNew] Processing line ${i + 1}/${lines.length}:`, line.substring(0, 50) + '...');
            
            // –ü–µ—Ä—à–∏–π –ø—Ä–æ–º–ø—Ç: –≤–∏—Ç—è–≥—Ç–∏ —Ä–æ–ª—å –±–µ–∑ –∑–º—ñ–Ω (—è–∫ —É —Ñ–∞–π–ª—ñ)
            const rolePrompt = `Extract the speaker role/label from this dialogue line exactly as it appears in the original text.

Line: "${line}"

Find and return the speaker label/role exactly as written in the line (e.g., "Agent", "Client", "Operator", "Customer", "User", "Speaker 0", "Speaker 1", etc.). 
If the line contains a speaker label, return it exactly as written (preserve capitalization and format).
If no explicit speaker label is found, return "unknown".

Return ONLY the role/label text, nothing else.`;
            
            let role = null;
            try {
              const roleResponse = await fetch('/api/debug-llm-query', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  prompt: rolePrompt
                })
              });
              
              if (roleResponse.ok) {
                const roleResult = await roleResponse.json();
                if (roleResult.success) {
                  const roleText = roleResult.result.trim();
                  // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ —Ä–æ–ª—å –±–µ–∑ –∑–º—ñ–Ω (–Ω–µ –Ω–æ—Ä–º–∞–ª—ñ–∑—É—î–º–æ)
                  if (roleText && roleText !== 'unknown') {
                    role = roleText;
                  }
                }
              }
            } catch (error) {
              console.warn(`‚ö†Ô∏è [runDebugActionNew] Failed to extract role for line ${i + 1}:`, error);
            }
            
            // –î—Ä—É–≥–∏–π –ø—Ä–æ–º–ø—Ç: –≤–∏—Ç—è–≥—Ç–∏ —Ç–µ–∫—Å—Ç —Ä–µ–ø–ª—ñ–∫–∏ (–±–µ–∑ –∑–º—ñ–Ω)
            const textPrompt = `Extract the dialogue text from this line, removing any speaker labels or prefixes.

Line: "${line}"

Return ONLY the text of what was said, without any speaker labels, prefixes, or formatting. Return the text exactly as spoken.`;
            
            let text = line; // Fallback: –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –æ—Ä–∏–≥—ñ–Ω–∞–ª—å–Ω–∏–π —Ä—è–¥–æ–∫
            try {
              const textResponse = await fetch('/api/debug-llm-query', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  prompt: textPrompt
                })
              });
              
              if (textResponse.ok) {
                const textResult = await textResponse.json();
                if (textResult.success) {
                  const extractedText = textResult.result.trim();
                  if (extractedText) {
                    text = extractedText;
                  }
                }
              }
            } catch (error) {
              console.warn(`‚ö†Ô∏è [runDebugActionNew] Failed to extract text for line ${i + 1}:`, error);
            }
            
            // –°—Ç–≤–æ—Ä—é—î–º–æ JSON –æ–±'—î–∫—Ç
            replicasArray.push({
              replicaNumber: i + 1,
              role: role || null,
              text: text
            });
            
            console.log(`‚úÖ [runDebugActionNew] Line ${i + 1} processed:`, { role, text: text.substring(0, 50) });
          }
          
          console.log(`‚úÖ [runDebugActionNew] Processed ${replicasArray.length} replicas with LLM`);
          
          // –û—Ç—Ä–∏–º—É—î–º–æ –º–∞—Å–∏–≤ —Ä–µ–ø–ª—ñ–∫ NextLevel –∑ –∫–æ–ª–æ–Ω–∫–∏ "Text (NextLevel)" –∑ —Ç–∞–±–ª–∏—Ü—ñ –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è
          const nextLevelReplicas = [];
          
          // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –≤–∏—Ç—è–≥—É–≤–∞–Ω–Ω—è NextLevel —Ä–µ–ø–ª—ñ–∫
          const extractNextLevelReplicas = () => {
            const comparisonContainer = document.getElementById('comparisonTableContainer');
            console.log('üîç [runDebugActionNew] Looking for comparison table:', {
              containerFound: !!comparisonContainer,
              containerId: comparisonContainer?.id,
              containerHTML: comparisonContainer ? comparisonContainer.innerHTML.substring(0, 200) : null
            });
            
            if (comparisonContainer) {
              // –°–ø—Ä–æ–±—É—î–º–æ –∑–Ω–∞–π—Ç–∏ —Ç–∞–±–ª–∏—Ü—é –∑ —Ä—ñ–∑–Ω–∏–º–∏ —Å–µ–ª–µ–∫—Ç–æ—Ä–∞–º–∏
              let table = comparisonContainer.querySelector('table.comparison-table');
              if (!table) {
                table = comparisonContainer.querySelector('table');
              }
              
              console.log('üîç [runDebugActionNew] Table found:', {
                tableFound: !!table,
                tableClass: table?.className,
                tableTagName: table?.tagName
              });
              
              if (table) {
                const rows = table.querySelectorAll('tbody tr');
                if (rows.length === 0) {
                  // –°–ø—Ä–æ–±—É—î–º–æ –∑–Ω–∞–π—Ç–∏ —Ä—è–¥–∫–∏ –±–µ–∑ tbody
                  const allRows = table.querySelectorAll('tr');
                  console.log('üîç [runDebugActionNew] Found rows (no tbody):', allRows.length);
                  
                  allRows.forEach((row, index) => {
                    // –ü—Ä–æ–ø—É—Å–∫–∞—î–º–æ –∑–∞–≥–æ–ª–æ–≤–æ–∫
                    if (index === 0) return;
                    
                    const cells = row.querySelectorAll('td');
                    // –ü–æ—Ä—è–¥–æ–∫ –∫–æ–ª–æ–Ω–æ–∫: Segment ID | Role Original | Text Original | Speaker (Standard) | Text (Standard) | Speaker (NextLevel) | Text (NextLevel) | Start Time | End Time
                    // Text (NextLevel) - —Ü–µ 7-–º–∞ –∫–æ–ª–æ–Ω–∫–∞ (—ñ–Ω–¥–µ–∫—Å 6)
                    if (cells.length > 6) {
                      const nextLevelText = cells[6].textContent.trim();
                      // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ —Ü–µ –Ω–µ –ø–æ—Ä–æ–∂–Ω—è –∫–æ–º—ñ—Ä–∫–∞
                      if (nextLevelText && nextLevelText !== '‚Äî' && nextLevelText !== '') {
                        nextLevelReplicas.push({
                          rowNumber: nextLevelReplicas.length + 1,
                          text: nextLevelText
                        });
                      }
                    }
                  });
                } else {
                  rows.forEach((row, index) => {
                    const cells = row.querySelectorAll('td');
                    // –ü–æ—Ä—è–¥–æ–∫ –∫–æ–ª–æ–Ω–æ–∫: Segment ID | Role Original | Text Original | Speaker (Standard) | Text (Standard) | Speaker (NextLevel) | Text (NextLevel) | Start Time | End Time
                    // Text (NextLevel) - —Ü–µ 7-–º–∞ –∫–æ–ª–æ–Ω–∫–∞ (—ñ–Ω–¥–µ–∫—Å 6)
                    if (cells.length > 6) {
                      const nextLevelText = cells[6].textContent.trim();
                      // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ —Ü–µ –Ω–µ –ø–æ—Ä–æ–∂–Ω—è –∫–æ–º—ñ—Ä–∫–∞
                      if (nextLevelText && nextLevelText !== '‚Äî' && nextLevelText !== '') {
                        nextLevelReplicas.push({
                          rowNumber: nextLevelReplicas.length + 1,
                          text: nextLevelText
                        });
                      }
                    }
                  });
                }
                
                console.log(`‚úÖ [runDebugActionNew] Total NextLevel replicas extracted: ${nextLevelReplicas.length}`);
              } else {
                console.log('‚ö†Ô∏è [runDebugActionNew] No table found in comparison container');
              }
            } else {
              console.log('‚ö†Ô∏è [runDebugActionNew] comparisonTableContainer not found');
            }
          };
          
          // –°–ø—Ä–æ–±—É—î–º–æ –≤–∏—Ç—è–≥—Ç–∏ –≤—ñ–¥—Ä–∞–∑—É
          extractNextLevelReplicas();
          
          // –Ø–∫—â–æ –Ω–µ –∑–Ω–∞–π—à–ª–∏, —Å–ø—Ä–æ–±—É—î–º–æ —á–µ—Ä–µ–∑ –Ω–µ–≤–µ–ª–∏–∫—É –∑–∞—Ç—Ä–∏–º–∫—É (–Ω–∞ –≤–∏–ø–∞–¥–æ–∫, —è–∫—â–æ —Ç–∞–±–ª–∏—Ü—è —â–µ —Ä–µ–Ω–¥–µ—Ä–∏—Ç—å—Å—è)
          if (nextLevelReplicas.length === 0) {
            setTimeout(() => {
              extractNextLevelReplicas();
            }, 500);
          }
          
          // Fallback: —è–∫—â–æ —Ç–∞–±–ª–∏—Ü—è –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∞, —Å–ø—Ä–æ–±—É—î–º–æ –∑ window.currentTable
          if (nextLevelReplicas.length === 0 && window.currentTable && Array.isArray(window.currentTable) && window.currentTable.length > 0) {
            const allFragments = [];
            
            // –ó–±–∏—Ä–∞—î–º–æ –≤—Å—ñ —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∏ –∑ —É—Å—ñ—Ö —Ç—Ä–µ–∫—ñ–≤
            window.currentTable.forEach(track => {
              if (track.fragments && Array.isArray(track.fragments)) {
                track.fragments.forEach(fragment => {
                  if (fragment.text && fragment.text.trim()) {
                    allFragments.push({
                      text: fragment.text.trim(),
                      start: parseFloat(fragment.start) || 0,
                      end: parseFloat(fragment.end) || 0,
                      role: fragment.role || track.dialogueType || 'unknown'
                    });
                  }
                });
              }
            });
            
            // –°–æ—Ä—Ç—É—î–º–æ –∑–∞ —á–∞—Å–æ–º –ø–æ—á–∞—Ç–∫—É
            allFragments.sort((a, b) => a.start - b.start);
            
            // –î–æ–¥–∞—î–º–æ –Ω–æ–º–µ—Ä–∏ —Ä—è–¥–∫—ñ–≤
            nextLevelReplicas.push(...allFragments.map((fragment, index) => {
              return {
                rowNumber: index + 1,
                text: fragment.text
              };
            }));
          }
          
          // –§–æ—Ä–º—É—î–º–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∑ –æ–±–æ–º–∞ –º–∞—Å–∏–≤–∞–º–∏
          console.log('üìã [runDebugActionNew] STEP 3: Building result object...');
          const result = {
            originalReplicas: replicasArray,
            nextLevelReplicas: nextLevelReplicas
          };
          
          console.log('üìã [runDebugActionNew] Result object:', {
            originalReplicasCount: result.originalReplicas.length,
            nextLevelReplicasCount: result.nextLevelReplicas.length
          });
          
          // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –æ—Ä–∏–≥—ñ–Ω–∞–ª—å–Ω–∏–π —Ç–µ–∫—Å—Ç –ø–µ—Ä–µ–¥ –∑–∞–ø–∏—Å–æ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—É
          const originalText = groundTruthTextarea.value;
          console.log('üìã [runDebugActionNew] Original text saved:', {
            length: originalText.length,
            preview: originalText.substring(0, 50)
          });
          
          // –í–∏–≤–æ–¥–∏–º–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç —É groundTruthTextarea
          console.log('üìã [runDebugActionNew] STEP 4: Converting to JSON and writing to textarea...');
          const resultJson = JSON.stringify(result, null, 2);
          groundTruthTextarea.value = resultJson;
          
          console.log(`‚úÖ [runDebugActionNew] STEP 4: Converted ${replicasArray.length} original replicas and ${nextLevelReplicas.length} NextLevel replicas to JSON format`, {
            jsonLength: resultJson.length,
            jsonPreview: resultJson.substring(0, 100)
          });
          
          // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ JSON –≤ –æ–∫—Ä–µ–º—É –∑–º—ñ–Ω–Ω—É –¥–ª—è –º–æ–∂–ª–∏–≤–æ—Å—Ç—ñ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
          window.lastGroundTruthResult = resultJson;
          console.log('‚úÖ [runDebugActionNew] JSON stored in window.lastGroundTruthResult');
          
          // –ö—Ä–æ–∫ 1: –û—á—ñ–∫—É—î–º–æ –ø–æ—è–≤–∏ JSON –≤ groundTruthTextarea
          console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
          console.log('üîÑ [runDebugActionNew] STEP: Waiting for JSON to appear...');
          console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
          
          try {
            const jsonWaitStartTime = Date.now();
            const parsedJson = await waitForJSONInTextarea(groundTruthTextarea);
            const jsonWaitElapsed = Date.now() - jsonWaitStartTime;
            console.log(`‚úÖ [runDebugActionNew] JSON detected after ${jsonWaitElapsed}ms`);
            
            // –ö—Ä–æ–∫ 2: –û—á—ñ–∫—É—î–º–æ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç—ñ –∫–Ω–æ–ø–∫–∏ Apply
            console.log('üìã [runDebugActionNew] STEP: Waiting for Apply button...');
            const applyBtn = await waitForElement('#applyBtn', 10, 100);
            console.log('‚úÖ [runDebugActionNew] Apply button found');
            
            // –ö—Ä–æ–∫ 3: –ù–∞—Ç–∏—Å–∫–∞—î–º–æ –∫–Ω–æ–ø–∫—É Apply
            console.log('üìã [runDebugActionNew] STEP: Preparing to click Apply button...');
            console.log('üìã [runDebugActionNew] Apply button state before:', {
              innerHTML: applyBtn.innerHTML,
              disabled: applyBtn.disabled,
              opacity: applyBtn.style.opacity
            });
            
            applyBtn.disabled = false;
            applyBtn.style.opacity = '1';
            applyBtn.style.cursor = 'pointer';
            applyBtn.innerHTML = '‚úÖ Apply';
            
            console.log('üìã [runDebugActionNew] Apply button state after:', {
              innerHTML: applyBtn.innerHTML,
              disabled: applyBtn.disabled,
              opacity: applyBtn.style.opacity
            });
            
            // –ù–µ–≤–µ–ª–∏–∫–∞ –∑–∞—Ç—Ä–∏–º–∫–∞ –ø–µ—Ä–µ–¥ –Ω–∞—Ç–∏—Å–∫–∞–Ω–Ω—è–º
            await new Promise(resolve => setTimeout(resolve, 200));
            
            console.log('üîÑ [runDebugActionNew] STEP: Clicking Apply button...');
            applyBtn.click();
            console.log('‚úÖ [runDebugActionNew] Apply button clicked automatically');
            console.log('‚è≥ [runDebugActionNew] Now waiting for applyOriginalReplicas() to process...');
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            
            // –ö—Ä–æ–∫ 4: –ü—ñ—Å–ª—è Apply –≤—ñ–¥–Ω–æ–≤–ª—é—î–º–æ –æ—Ä–∏–≥—ñ–Ω–∞–ª—å–Ω–∏–π —Ç–µ–∫—Å—Ç (—è–∫—â–æ –ø–æ—Ç—Ä—ñ–±–Ω–æ)
            // –í–ê–ñ–õ–ò–í–û: –ù–ï –≤—ñ–¥–Ω–æ–≤–ª—é—î–º–æ —Ç–µ–∫—Å—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ, –±–æ Apply –≤–∂–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–≤ JSON
            // –ö–æ—Ä–∏—Å—Ç—É–≤–∞—á –º–æ–∂–µ –≤—Ä—É—á–Ω—É –≤—ñ–¥–Ω–æ–≤–∏—Ç–∏ —Ç–µ–∫—Å—Ç, —è–∫—â–æ –ø–æ—Ç—Ä—ñ–±–Ω–æ
            console.log('‚ÑπÔ∏è [runDebugActionNew] JSON applied successfully. Original text preserved in memory.');
            console.log('‚ÑπÔ∏è [runDebugActionNew] To restore original text, user can reload the file.');
            
          } catch (error) {
            console.error('‚ùå [runDebugActionNew] ERROR waiting for JSON or clicking Apply:', error);
            console.error('‚ùå [runDebugActionNew] Error stack:', error.stack);
          }
          
          if (btn) {
            btn.disabled = false;
            btn.style.opacity = '1';
            btn.style.cursor = 'pointer';
            btn.innerHTML = '‚ñ∂Ô∏è Run'; // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ —Ñ—ñ–∫—Å–æ–≤–∞–Ω–∏–π —Ç–µ–∫—Å—Ç
          }
          
          return;
        } catch (error) {
          console.error('‚ùå [runDebugActionNew] Error processing ground truth:', error);
          if (btn) {
            btn.disabled = false;
            btn.style.opacity = '1';
            btn.style.cursor = 'pointer';
            btn.innerHTML = originalText;
          }
          alert(`‚ùå –ü–æ–º–∏–ª–∫–∞: ${error.message}`);
          return;
        }
      }
      
      // –ü–æ–∫–∞–∑—É—î–º–æ –ø—Ä–æ–≥—Ä–µ—Å–±–∞—Ä –≥–µ–Ω–µ—Ä–∞—Ü—ñ—ó —Ç–∞–±–ª–∏—Ü—ñ
      showTableGenerationProgress();
      
      try {
        // –ü–æ–∫–∞–∑—É—î–º–æ —ñ–Ω–¥–∏–∫–∞—Ç–æ—Ä –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —Ç—ñ–ª—å–∫–∏ —è–∫—â–æ –µ–ª–µ–º–µ–Ω—Ç–∏ –¥–æ—Å—Ç—É–ø–Ω—ñ
        if (btn) {
          btn.disabled = true;
          btn.style.opacity = '0.6';
          btn.style.cursor = 'not-allowed';
          btn.innerHTML = '‚è≥ Running...';
        }
        
        // –Ø–∫—â–æ debugTextarea –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ, —Å—Ç–≤–æ—Ä—é—î–º–æ —Ç–∏–º—á–∞—Å–æ–≤–∏–π –µ–ª–µ–º–µ–Ω—Ç –¥–ª—è –∑–±–µ—Ä—ñ–≥–∞–Ω–Ω—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤
        let tempTextarea = null;
        if (!debugTextarea && isAutoRun) {
          // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ –≤–∂–µ —ñ—Å–Ω—É—î —Ç–∏–º—á–∞—Å–æ–≤–∏–π textarea
          tempTextarea = document.getElementById('debugTextarea');
          if (!tempTextarea) {
            tempTextarea = document.createElement('textarea');
            tempTextarea.id = 'debugTextarea';
            tempTextarea.style.display = 'none';
            document.body.appendChild(tempTextarea);
            console.log('‚úÖ [runDebugActionNew] Created temporary debugTextarea for auto-run');
          }
        }
        
        // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –¥–æ—Å—Ç—É–ø–Ω–∏–π textarea (–æ—Ä–∏–≥—ñ–Ω–∞–ª—å–Ω–∏–π –∞–±–æ —Ç–∏–º—á–∞—Å–æ–≤–∏–π)
        const activeTextarea = debugTextarea || tempTextarea;
        
        // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –Ω–∞—è–≤–Ω—ñ—Å—Ç—å –¥–∞–Ω–∏—Ö
        if (!currentAnalysisData) {
          throw new Error('No analysis data available');
        }
        
        // –û—Ç—Ä–∏–º—É—î–º–æ –ø–æ–≤–Ω–∏–π –¥—ñ–∞–ª–æ–≥ –¥–ª—è –∫–æ–Ω—Ç–µ–∫—Å—Ç—É LLM
        // –ü—Ä—ñ–æ—Ä–∏—Ç–µ—Ç: groundTruthTextarea > window.uploadedDialogueText > currentAnalysisData.uploadedDialogueText > formatDialog
        let dialogue1 = null;
        
        // 1. –°–ø–æ—á–∞—Ç–∫—É –ø–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ groundTruthTextarea (–Ω–∞–π–≤–∏—â–∏–π –ø—Ä—ñ–æ—Ä–∏—Ç–µ—Ç)
        if (groundTruthTextarea && groundTruthTextarea.value && groundTruthTextarea.value.trim()) {
          dialogue1 = groundTruthTextarea.value.trim();
          console.log('‚úÖ [runDebugActionNew] Using dialogue from groundTruthTextarea');
        }
        
        // 2. –Ø–∫—â–æ –Ω–µ–º–∞—î –≤ groundTruthTextarea, –ø–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ window.uploadedDialogueText
        if (!dialogue1 && window.uploadedDialogueText) {
          dialogue1 = window.uploadedDialogueText;
          console.log('‚úÖ [runDebugActionNew] Using dialogue from window.uploadedDialogueText');
        }
        
        // 3. –Ø–∫—â–æ –Ω–µ–º–∞—î, –ø–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ currentAnalysisData.uploadedDialogueText
        if (!dialogue1 && currentAnalysisData.uploadedDialogueText) {
          dialogue1 = currentAnalysisData.uploadedDialogueText;
          console.log('‚úÖ [runDebugActionNew] Using dialogue from currentAnalysisData.uploadedDialogueText');
        }
        
        // 4. –Ø–∫—â–æ –Ω–µ–º–∞—î, —Å–ø—Ä–æ–±—É—î–º–æ –æ—Ç—Ä–∏–º–∞—Ç–∏ –∑ formatDialog
        if (!dialogue1) {
          const jsonData = getGeneralJSON();
          if (jsonData) {
            const allSegments = extractSegments(jsonData);
            if (allSegments.length > 0) {
              dialogue1 = formatDialog(allSegments);
              console.log('‚úÖ [runDebugActionNew] Using dialogue from formatDialog');
            }
          }
        }
        
        if (!dialogue1) {
          throw new Error('Dialogue 1 not found. Please upload dialogue text or ensure diarization data is available.');
        }
        
        const dialogueLines = dialogue1.split('\n').filter(line => line.trim());
        
        if (dialogueLines.length === 0) {
          throw new Error('Dialogue is empty');
        }
        
        // –û—Ç—Ä–∏–º—É—î–º–æ voice tracks
        const voiceTracks = currentAnalysisData.voiceTracks || [];
        
        if (voiceTracks.length === 0) {
          throw new Error('No voice tracks available');
        }
        
        // –û—Ç—Ä–∏–º—É—î–º–æ —Å–µ–≥–º–µ–Ω—Ç–∏ –∑ primary diarization –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–∏—Ö —Ç–∞–π–º—Å—Ç–µ–º–ø—ñ–≤
        const generalJsonData = getGeneralJSON();
        const primarySegments = generalJsonData ? extractSegments(generalJsonData) : [];
        
        if (primarySegments.length === 0) {
          throw new Error('No primary segments available for timestamp extraction');
        }
        
        console.log(`üîç [DEBUG] Primary segments count: ${primarySegments.length}`);
        
        // –ú–∞—Å–∏–≤ –¥–ª—è –∑–±–µ—Ä—ñ–≥–∞–Ω–Ω—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤ –∞–Ω–∞–ª—ñ–∑—É –æ–±–æ—Ö —Ç—Ä–µ–∫—ñ–≤
        const results = [];
        
        // –ê–Ω–∞–ª—ñ–∑—É—î–º–æ –ø–µ—Ä—à–∏–π —Ç—Ä–µ–∫
        const speaker1JsonData = getSpeaker1JSON();
        if (speaker1JsonData) {
          const firstTrackSegments = extractSegments(speaker1JsonData);
          
          if (firstTrackSegments.length > 0) {
            // –í–∏–∑–Ω–∞—á–∞—î–º–æ –Ω–æ–º–µ—Ä –¥—ñ–∞–ª–æ–≥—É –∑ –ø–µ—Ä—à–æ–≥–æ —Ç—Ä–µ–∫—É
            let dialogueNumber1 = 0;
            if (voiceTracks.length > 0) {
              const firstTrack = voiceTracks[0];
              const trackSpeaker = firstTrack.speaker || 'SPEAKER_00';
              const speakerNumMatch = trackSpeaker.match(/SPEAKER_(\d+)/i);
              if (speakerNumMatch) {
                dialogueNumber1 = parseInt(speakerNumMatch[1], 10);
              }
            }
            
            console.log(`üîç [DEBUG] Processing first track (dialogue ${dialogueNumber1}) with ${firstTrackSegments.length} fragments`);
            
            // –§–æ—Ä–º—É—î–º–æ —Å–ø–∏—Å–æ–∫ —Ä—è–¥–∫—ñ–≤ –¥—ñ–∞–ª–æ–≥—É –∑ –ø–µ—Ä—à–æ–≥–æ —Ç—Ä–µ–∫—É
            const firstTrackDialogLines = formatDialog(firstTrackSegments).split('\n').filter(line => line.trim());
            
            if (firstTrackDialogLines.length > 0) {
              btn.innerHTML = '‚è≥ Analyzing first track...';
              
              // –û—Ç—Ä–∏–º—É—î–º–æ —Ä–æ–ª—å —Ç—Ä–µ–∫—É –∑ –º–µ—Ç–∞–¥–∞–Ω–∏—Ö
              const firstTrack = voiceTracks[0];
              const trackRole = firstTrack?.assignedRole || 
                                firstTrack?.roleAnalysis?.role || 
                                firstTrack?.role || 
                                null;
              
              console.log(`üîç [DEBUG] First track role from metadata:`, trackRole);
              
              // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ —É–Ω—ñ–≤–µ—Ä—Å–∞–ª—å–Ω—É —Ñ—É–Ω–∫—Ü—ñ—é –¥–ª—è –∞–Ω–∞–ª—ñ–∑—É –ø–µ—Ä—à–æ–≥–æ –¥—ñ–∞–ª–æ–≥—É
              // –ü–µ—Ä–µ–¥–∞—î–º–æ primarySegments –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–∏—Ö —Ç–∞–π–º—Å—Ç–µ–º–ø—ñ–≤
              const firstTrackResult = await analyzeDialogue(
                firstTrackDialogLines,  // –†—è–¥–∫–∏ –¥—ñ–∞–ª–æ–≥—É –¥–ª—è –∞–Ω–∞–ª—ñ–∑—É
                dialogueLines,           // –ü–æ–≤–Ω–∏–π –¥—ñ–∞–ª–æ–≥ –¥–ª—è –∫–æ–Ω—Ç–µ–∫—Å—Ç—É
                dialogueNumber1,         // –ù–æ–º–µ—Ä –¥—ñ–∞–ª–æ–≥—É
                (progress) => {          // Callback –¥–ª—è –æ–Ω–æ–≤–ª–µ–Ω–Ω—è –ø—Ä–æ–≥—Ä–µ—Å—É
                  btn.innerHTML = `‚è≥ First track: ${progress}`;
                },
                trackRole,               // –†–æ–ª—å —Ç—Ä–µ–∫—É –∑ –º–µ—Ç–∞–¥–∞–Ω–∏—Ö
                primarySegments          // –°–µ–≥–º–µ–Ω—Ç–∏ –∑ primary diarization –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–∏—Ö —Ç–∞–π–º—Å—Ç–µ–º–ø—ñ–≤
              );
              
              results.push(firstTrackResult);
              
              console.log(`‚úÖ [DEBUG] First track analysis completed:`, {
                dialogueNumber: firstTrackResult.dialogueNumber,
                dialogueType: firstTrackResult.dialogueType,
                fragmentsCount: firstTrackResult.dialogueAnalysis.length
              });
            }
          }
        }
        
        // –ê–Ω–∞–ª—ñ–∑—É—î–º–æ –¥—Ä—É–≥–∏–π —Ç—Ä–µ–∫ (—è–∫—â–æ —î)
        const speaker2JsonData = getSpeaker2JSON();
        if (speaker2JsonData && voiceTracks.length > 1) {
          const secondTrackSegments = extractSegments(speaker2JsonData);
          
          if (secondTrackSegments.length > 0) {
            // –í–∏–∑–Ω–∞—á–∞—î–º–æ –Ω–æ–º–µ—Ä –¥—ñ–∞–ª–æ–≥—É –∑ –¥—Ä—É–≥–æ–≥–æ —Ç—Ä–µ–∫—É
            let dialogueNumber2 = 1;
            if (voiceTracks.length > 1) {
              const secondTrack = voiceTracks[1];
              const trackSpeaker = secondTrack.speaker || 'SPEAKER_01';
              const speakerNumMatch = trackSpeaker.match(/SPEAKER_(\d+)/i);
              if (speakerNumMatch) {
                dialogueNumber2 = parseInt(speakerNumMatch[1], 10);
              }
            }
            
            console.log(`üîç [DEBUG] Processing second track (dialogue ${dialogueNumber2}) with ${secondTrackSegments.length} fragments`);
            
            // –§–æ—Ä–º—É—î–º–æ —Å–ø–∏—Å–æ–∫ —Ä—è–¥–∫—ñ–≤ –¥—ñ–∞–ª–æ–≥—É –∑ –¥—Ä—É–≥–æ–≥–æ —Ç—Ä–µ–∫—É
            const secondTrackDialogLines = formatDialog(secondTrackSegments).split('\n').filter(line => line.trim());
            
            if (secondTrackDialogLines.length > 0) {
              btn.innerHTML = '‚è≥ Analyzing second track...';
              
              // –û—Ç—Ä–∏–º—É—î–º–æ —Ä–æ–ª—å —Ç—Ä–µ–∫—É –∑ –º–µ—Ç–∞–¥–∞–Ω–∏—Ö
              const secondTrack = voiceTracks[1];
              const trackRole = secondTrack?.assignedRole || 
                                secondTrack?.roleAnalysis?.role || 
                                secondTrack?.role || 
                                null;
              
              console.log(`üîç [DEBUG] Second track role from metadata:`, trackRole);
              
              // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ —É–Ω—ñ–≤–µ—Ä—Å–∞–ª—å–Ω—É —Ñ—É–Ω–∫—Ü—ñ—é –¥–ª—è –∞–Ω–∞–ª—ñ–∑—É –¥—Ä—É–≥–æ–≥–æ –¥—ñ–∞–ª–æ–≥—É
              // –ü–µ—Ä–µ–¥–∞—î–º–æ primarySegments –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–∏—Ö —Ç–∞–π–º—Å—Ç–µ–º–ø—ñ–≤
              const secondTrackResult = await analyzeDialogue(
                secondTrackDialogLines,  // –†—è–¥–∫–∏ –¥—ñ–∞–ª–æ–≥—É –¥–ª—è –∞–Ω–∞–ª—ñ–∑—É
                dialogueLines,           // –ü–æ–≤–Ω–∏–π –¥—ñ–∞–ª–æ–≥ –¥–ª—è –∫–æ–Ω—Ç–µ–∫—Å—Ç—É
                dialogueNumber2,         // –ù–æ–º–µ—Ä –¥—ñ–∞–ª–æ–≥—É
                (progress) => {          // Callback –¥–ª—è –æ–Ω–æ–≤–ª–µ–Ω–Ω—è –ø—Ä–æ–≥—Ä–µ—Å—É
                  btn.innerHTML = `‚è≥ Second track: ${progress}`;
                },
                trackRole,               // –†–æ–ª—å —Ç—Ä–µ–∫—É –∑ –º–µ—Ç–∞–¥–∞–Ω–∏—Ö
                primarySegments          // –°–µ–≥–º–µ–Ω—Ç–∏ –∑ primary diarization –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–∏—Ö —Ç–∞–π–º—Å—Ç–µ–º–ø—ñ–≤
              );
              
              results.push(secondTrackResult);
              
              console.log(`‚úÖ [DEBUG] Second track analysis completed:`, {
                dialogueNumber: secondTrackResult.dialogueNumber,
                dialogueType: secondTrackResult.dialogueType,
                fragmentsCount: secondTrackResult.dialogueAnalysis.length
              });
            }
          }
        }
        
        if (results.length === 0) {
          throw new Error('No tracks were analyzed');
        }
        
        // –í–∏–≤–æ–¥–∏–º–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç —É debugTextarea —è–∫ JSON –º–∞—Å–∏–≤ –∑ –æ–±'—î–∫—Ç–∞–º–∏ –¥–ª—è –∫–æ–∂–Ω–æ–≥–æ —Ç—Ä–µ–∫—É
        const output = JSON.stringify(results, null, 2);
        if (activeTextarea) {
          activeTextarea.value = output;
          console.log('‚úÖ [runDebugActionNew] Results saved to textarea');
        } else {
          console.warn('‚ö†Ô∏è [runDebugActionNew] debugTextarea not found, results not saved to textarea');
        }
        
        console.log(`‚úÖ [DEBUG] Final result prepared:`, {
          tracksAnalyzed: results.length,
          results: results.map(r => ({
            dialogueNumber: r.dialogueNumber,
            dialogueType: r.dialogueType,
            fragmentsCount: r.dialogueAnalysis.length
          }))
        });
        
        // –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –∑–∞–ø—É—Å–∫–∞—î–º–æ –ø–æ—Å—Ç-–æ–±—Ä–æ–±–∫—É –ø—ñ—Å–ª—è —É—Å–ø—ñ—à–Ω–æ–≥–æ –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è –∞–Ω–∞–ª—ñ–∑—É
        console.log('üîÑ [DEBUG] Auto-starting post-processing...');
        if (btn) {
          btn.innerHTML = '‚è≥ Running post-processing...';
        }
        try {
          await testPostProcessing(true); // –ü–µ—Ä–µ–¥–∞—î–º–æ true, —â–æ–± –ø—Ä–∏—Ö–æ–≤–∞—Ç–∏ UI —ñ–Ω–¥–∏–∫–∞—Ç–æ—Ä–∏
          // testPostProcessing() –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –≤–∏–∫–ª–∏–∫–∞—î applyDebugMarkup() –ø—ñ—Å–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è
          console.log('‚úÖ [DEBUG] Post-processing completed successfully');
        } catch (postProcessingError) {
          console.error('‚ùå [DEBUG] Post-processing error:', postProcessingError);
          // –ù–µ –ø–æ–∫–∞–∑—É—î–º–æ –ø–æ–º–∏–ª–∫—É –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—É, –±–æ –æ—Å–Ω–æ–≤–Ω–∏–π –∞–Ω–∞–ª—ñ–∑ –∑–∞–≤–µ—Ä—à–∏–≤—Å—è —É—Å–ø—ñ—à–Ω–æ
        }
        
      } catch (error) {
        console.error('‚ùå [DEBUG] Error:', error);
        const errorMessage = `Error: ${error.message}\n\n` +
          `Stack: ${error.stack || 'N/A'}`;
        if (activeTextarea) {
          activeTextarea.value = errorMessage;
        }
        if (!isAutoRun) {
          alert(`Error: ${error.message}`);
        }
      } finally {
        // –í—ñ–¥–Ω–æ–≤–ª—é—î–º–æ –∫–Ω–æ–ø–∫—É —Ç—ñ–ª—å–∫–∏ —è–∫—â–æ –≤–æ–Ω–∞ –¥–æ—Å—Ç—É–ø–Ω–∞
        if (btn) {
          btn.disabled = false;
          btn.style.opacity = '1';
          btn.style.cursor = 'pointer';
          btn.innerHTML = '‚ñ∂Ô∏è Run'; // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ —Ñ—ñ–∫—Å–æ–≤–∞–Ω–∏–π —Ç–µ–∫—Å—Ç
        }
        
        // –ù–µ –≤–∏–¥–∞–ª—è—î–º–æ —Ç–∏–º—á–∞—Å–æ–≤–∏–π textarea, –±–æ –≤—ñ–Ω –º–æ–∂–µ –±—É—Ç–∏ –ø–æ—Ç—Ä—ñ–±–µ–Ω –¥–ª—è testPostProcessing()
        // –í—ñ–Ω –±—É–¥–µ –≤–∏–¥–∞–ª–µ–Ω–∏–π –ø—ñ—Å–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è –≤—Å—å–æ–≥–æ –ø—Ä–æ—Ü–µ—Å—É
      }
    }
    
    // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è —Ç–µ—Å—Ç—É –ø–æ—Å—Ç-–æ–±—Ä–æ–±–∫–∏
    // autoRun: —è–∫—â–æ true, –Ω–µ –ø–æ–∫–∞–∑—É—î UI —ñ–Ω–¥–∏–∫–∞—Ç–æ—Ä–∏ (–≤–∏–∫–ª–∏–∫–∞—î—Ç—å—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ)
    async function testPostProcessing(autoRun = false) {
      const btn = document.getElementById('testPostProcessingBtn');
      const originalText = btn ? btn.innerHTML : '‚è≥ Processing...';
      const debugTextarea = document.getElementById('debugTextarea');
      const resultTextarea = document.getElementById('postProcessingResult');
      
      // –ü–æ–∫–∞–∑—É—î–º–æ —ñ–Ω–¥–∏–∫–∞—Ç–æ—Ä –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —Ç—ñ–ª—å–∫–∏ —è–∫—â–æ –Ω–µ autoRun —ñ –∫–Ω–æ–ø–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–∞
      if (!autoRun && btn) {
        btn.disabled = true;
        btn.style.opacity = '0.6';
        btn.style.cursor = 'not-allowed';
        btn.innerHTML = '‚è≥ Processing...';
      }
      if (resultTextarea) {
        resultTextarea.value = 'Processing...';
      }
      
      try {
        if (!debugTextarea) {
          throw new Error('Debug textarea not found. Cannot run post-processing.');
        }
        
        const debugText = debugTextarea.value;
        if (!debugText || debugText.trim() === '') {
          alert('‚ö†Ô∏è Debug textarea is empty. Please run the analysis first.');
          return;
        }
        
        // –ü–∞—Ä—Å–∏–º–æ JSON –∑ debugTextarea
        let analysisResults = null;
        try {
          analysisResults = JSON.parse(debugText);
        } catch (parseError) {
          throw new Error('Failed to parse JSON from debug textarea. Please run the analysis first.');
        }
        
        if (!Array.isArray(analysisResults) || analysisResults.length === 0) {
          throw new Error('Invalid analysis results format. Expected array with dialogue analysis.');
        }
        
        console.log('üîß [TEST_POST] Starting LLM-based post-processing...');
        
        // –û—Ç—Ä–∏–º—É—î–º–æ –ø–æ–≤–Ω–∏–π –¥—ñ–∞–ª–æ–≥ –¥–ª—è –∫–æ–Ω—Ç–µ–∫—Å—Ç—É
        const generalJsonData = getGeneralJSON();
        const primarySegments = generalJsonData ? extractSegments(generalJsonData) : [];
        const fullDialogueLines = primarySegments.length > 0 
          ? formatDialog(primarySegments).split('\n').filter(line => line.trim())
          : [];
        
        // –û–±'—î–¥–Ω—É—î–º–æ –≤—Å—ñ —Å–µ–≥–º–µ–Ω—Ç–∏ –∑ —É—Å—ñ—Ö —Ç—Ä–µ–∫—ñ–≤
        const allSegments = [];
        analysisResults.forEach((track, trackIdx) => {
          const dialogueAnalysis = track.dialogueAnalysis || [];
          dialogueAnalysis.forEach(seg => {
            allSegments.push({
              ...seg,
              _trackIndex: trackIdx,
              _trackDialogueNumber: track.dialogueNumber || trackIdx,
              _originalIndex: allSegments.length
            });
          });
        });
        
        console.log(`üîß [TEST_POST] Total segments across all tracks: ${allSegments.length}`);
        
        // –°—Ç–≤–æ—Ä—é—î–º–æ –∫–æ–ø—ñ—ó –≤—Å—ñ—Ö —Ç—Ä–µ–∫—ñ–≤ –¥–ª—è –æ–±—Ä–æ–±–∫–∏
        const processedResults = analysisResults.map(track => ({
          ...track,
          dialogueAnalysis: JSON.parse(JSON.stringify(track.dialogueAnalysis || []))
        }));
        
        // –°–æ—Ä—Ç—É—î–º–æ –≤—Å—ñ —Å–µ–≥–º–µ–Ω—Ç–∏ –∑–∞ —á–∞—Å–æ–º –ø–æ—á–∞—Ç–∫—É
        const sortedSegments = allSegments
          .filter(seg => seg.start !== null && seg.end !== null)
          .sort((a, b) => parseFloat(a.start) - parseFloat(b.start));
        
        console.log(`üîç [TEST_POST] Sorted ${sortedSegments.length} segments by start time`);
        
        // –§–æ—Ä–º—É—î–º–æ –ø–∞—Ä–∏ —Å—É—Å—ñ–¥–Ω—ñ—Ö —Å–µ–≥–º–µ–Ω—Ç—ñ–≤ –¥–ª—è –∞–Ω–∞–ª—ñ–∑—É
        const segmentPairs = [];
        for (let i = 0; i < sortedSegments.length - 1; i++) {
          const segA = sortedSegments[i];
          const segB = sortedSegments[i + 1];
          
          // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ —Å–µ–≥–º–µ–Ω—Ç–∏ –ø–µ—Ä–µ–∫—Ä–∏–≤–∞—é—Ç—å—Å—è –∞–±–æ –¥—É–∂–µ –±–ª–∏–∑—å–∫—ñ (–≤ –º–µ–∂–∞—Ö 2 —Å–µ–∫—É–Ω–¥)
          const startA = parseFloat(segA.start);
          const endA = parseFloat(segA.end);
          const startB = parseFloat(segB.start);
          const endB = parseFloat(segB.end);
          
          const overlapStart = Math.max(startA, startB);
          const overlapEnd = Math.min(endA, endB);
          const overlapDuration = Math.max(0, overlapEnd - overlapStart);
          const gap = startB - endA;
          
          // –î–æ–¥–∞—î–º–æ –ø–∞—Ä—É, —è–∫—â–æ —î –ø–µ—Ä–µ–∫—Ä–∏—Ç—Ç—è –∞–±–æ –≤–æ–Ω–∏ –¥—É–∂–µ –±–ª–∏–∑—å–∫—ñ (gap < 2 —Å–µ–∫—É–Ω–¥)
          if (overlapDuration > 0 || gap < 2.0) {
            segmentPairs.push({
              segmentA: segA,
              segmentB: segB,
              overlapDuration: overlapDuration,
              gap: gap
            });
          }
        }
        
        console.log(`üîç [TEST_POST] Found ${segmentPairs.length} adjacent pairs to analyze`);
        
        if (segmentPairs.length === 0) {
          console.log(`‚úÖ [TEST_POST] No adjacent pairs found. No conflicts to analyze.`);
          resultTextarea.value = JSON.stringify(processedResults, null, 2) + '\n\n// No adjacent pairs found. No conflicts to analyze.';
          return;
        }
        
        // –ê–Ω–∞–ª—ñ–∑—É—î–º–æ –ø–∞—Ä–∏ —á–µ—Ä–µ–∑ LLM
        const segmentsToRemove = []; // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ —Å–µ–≥–º–µ–Ω—Ç–∏ –¥–ª—è –≤–∏–¥–∞–ª–µ–Ω–Ω—è (–ø–æ—Å–∏–ª–∞–Ω–Ω—è –Ω–∞ –æ—Ä–∏–≥—ñ–Ω–∞–ª—å–Ω—ñ –æ–±'—î–∫—Ç–∏)
        const batchSize = 5; // –û–±—Ä–æ–±–ª—è—î–º–æ –ø–æ 5 –ø–∞—Ä –∑–∞ —Ä–∞–∑
        
        for (let batchIdx = 0; batchIdx < segmentPairs.length; batchIdx += batchSize) {
          const batch = segmentPairs.slice(batchIdx, Math.min(batchIdx + batchSize, segmentPairs.length));
          
          if (!autoRun) {
            btn.innerHTML = `‚è≥ LLM analyzing pairs ${batchIdx + 1}-${Math.min(batchIdx + batchSize, segmentPairs.length)}/${segmentPairs.length}...`;
          }
          
          // –î–ª—è –∫–æ–∂–Ω–æ—ó –ø–∞—Ä–∏ —Ñ–æ—Ä–º—É—î–º–æ –æ–∫—Ä–µ–º–∏–π –ø—Ä–æ–º–ø—Ç
          for (let pairIdx = 0; pairIdx < batch.length; pairIdx++) {
            const pair = batch[pairIdx];
            const { segmentA, segmentB } = pair;
            
            // –ó–Ω–∞—Ö–æ–¥–∏–º–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç (—Å—É—Å—ñ–¥–Ω—ñ —Å–µ–≥–º–µ–Ω—Ç–∏)
            const segAIndex = sortedSegments.indexOf(segmentA);
            const segBIndex = sortedSegments.indexOf(segmentB);
            const contextWindow = 3;
            const minContextIdx = Math.max(0, Math.min(segAIndex, segBIndex) - contextWindow);
            const maxContextIdx = Math.min(sortedSegments.length - 1, Math.max(segAIndex, segBIndex) + contextWindow);
            const contextSegments = sortedSegments.slice(minContextIdx, maxContextIdx + 1);
            
            // –§–æ—Ä–º—É—î–º–æ –ø–æ–≤–Ω–∏–π –¥—ñ–∞–ª–æ–≥ –¥–ª—è –∫–æ–Ω—Ç–µ–∫—Å—Ç—É
            const fullDialogueContext = fullDialogueLines.length > 0 
              ? fullDialogueLines.join('\n')
              : contextSegments.map(seg => `${seg.role}: ${seg.fragment}`).join('\n');
            
            // –ü—Ä–æ–º–ø—Ç –¥–ª—è –∞–Ω–∞–ª—ñ–∑—É –ø–∞—Ä–∏
            const pairAnalysisPrompt = `Analyze a customer support dialogue between an agent and a client to identify and filter out erroneous replicas caused by voice overlap, echo, or incorrect diarization.

CRITICAL RULES:
1. DO NOT filter out correct phrases. Only identify TRUE duplicates caused by technical issues (voice overlap, echo, incorrect diarization).
2. Segments with DIFFERENT roles (agent vs client) are normally NOT duplicates, even if they have overlapping timestamps. Different roles mean different speakers, and overlapping speech is normal in conversations.
3. EXCEPTION: If one segment's text is semantically a SUBSTRING or PART of another segment's text AND they have overlapping timestamps, this might indicate a duplicate or partial fragment.
4. Keep the segment that is more complete and correctly matches its role according to the dialogue context.

Full dialogue context:
${fullDialogueContext}

Nearby segments for context:
${contextSegments.map((seg, idx) => `${minContextIdx + idx + 1}. [${seg.start || '?'}-${seg.end || '?'}s] ${seg.role}: "${seg.fragment}"`).join('\n')}

Two adjacent fragments to analyze:
- Fragment A [${segmentA.start}-${segmentA.end}s] ${segmentA.role}: "${segmentA.fragment}"
- Fragment B [${segmentB.start}-${segmentB.end}s] ${segmentB.role}: "${segmentB.fragment}"
- Time overlap: ${pair.overlapDuration.toFixed(2)}s
- Gap between segments: ${pair.gap >= 0 ? pair.gap.toFixed(2) + 's' : 'overlapping'}

Task: Are these two adjacent fragments semantic duplicates? Which one is more complete and correctly matches its role according to the dialogue context?

Return ONLY a JSON object in this exact format (no markdown, no explanations):
{
  "isDuplicate": true/false,
  "keepFragment": "A" or "B" or "both",
  "reason": "brief explanation"
}`;
            
            try {
              console.log(`üì§ [TEST_POST] Sending pair ${batchIdx + pairIdx + 1}/${segmentPairs.length} to LLM...`);
              
              const response = await fetch('/api/debug-llm-query', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  prompt: pairAnalysisPrompt
                })
              });
              
              if (!response.ok) {
                console.warn(`‚ö†Ô∏è [TEST_POST] Failed to analyze pair ${batchIdx + pairIdx + 1}: HTTP ${response.status}`);
                continue;
              }
              
              const result = await response.json();
              
              if (!result.success) {
                console.warn(`‚ö†Ô∏è [TEST_POST] LLM query failed for pair ${batchIdx + pairIdx + 1}: ${result.error}`);
                continue;
              }
              
              // –ü–∞—Ä—Å–∏–º–æ –≤—ñ–¥–ø–æ–≤—ñ–¥—å LLM
              let llmResponse = null;
              try {
                const responseText = result.result.trim();
                // –®—É–∫–∞—î–º–æ JSON –æ–±'—î–∫—Ç —É –≤—ñ–¥–ø–æ–≤—ñ–¥—ñ
                const jsonMatch = responseText.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                  llmResponse = JSON.parse(jsonMatch[0]);
                } else {
                  llmResponse = JSON.parse(responseText);
                }
              } catch (parseError) {
                console.warn(`‚ö†Ô∏è [TEST_POST] Failed to parse LLM response for pair ${batchIdx + pairIdx + 1}:`, result.result);
                continue;
              }
              
              // –û–±—Ä–æ–±–ª—è—î–º–æ –≤—ñ–¥–ø–æ–≤—ñ–¥—å
              if (llmResponse && llmResponse.isDuplicate === true) {
                const segmentToRemove = llmResponse.keepFragment === 'A' ? segmentB : segmentA;
                
                // –î–æ–¥–∞—î–º–æ —Å–µ–≥–º–µ–Ω—Ç –¥–æ —Å–ø–∏—Å–∫—É –¥–ª—è –≤–∏–¥–∞–ª–µ–Ω–Ω—è (–∑–±–µ—Ä—ñ–≥–∞—î–º–æ –ø–æ—Å–∏–ª–∞–Ω–Ω—è)
                segmentsToRemove.push(segmentToRemove);
                
                console.log(`‚úÖ [TEST_POST] Pair ${batchIdx + pairIdx + 1}: Duplicate detected. Keeping ${llmResponse.keepFragment}. Reason: ${llmResponse.reason || 'N/A'}`);
                console.log(`   Removing: [${segmentToRemove.start}-${segmentToRemove.end}s] ${segmentToRemove.role}: "${segmentToRemove.fragment.substring(0, 50)}..."`);
              } else {
                console.log(`‚ÑπÔ∏è [TEST_POST] Pair ${batchIdx + pairIdx + 1}: Not a duplicate. Keeping both.`);
              }
            } catch (error) {
              console.error(`‚ùå [TEST_POST] Error analyzing pair ${batchIdx + pairIdx + 1}:`, error);
            }
          }
        }
        
        console.log(`üîç [TEST_POST] Found ${segmentsToRemove.length} segments to remove`);
        
        // –í–∏–¥–∞–ª—è—î–º–æ –¥—É–±–ª—ñ–∫–∞—Ç–∏ –∑—ñ —Å–ø–∏—Å–∫—É —Å–µ–≥–º–µ–Ω—Ç—ñ–≤ –¥–ª—è –≤–∏–¥–∞–ª–µ–Ω–Ω—è (—è–∫—â–æ –æ–¥–∏–Ω —Å–µ–≥–º–µ–Ω—Ç –±—É–≤ –≤–∏–∑–Ω–∞—á–µ–Ω–∏–π —è–∫ –¥—É–±–ª—ñ–∫–∞—Ç —É –∫—ñ–ª—å–∫–æ—Ö –ø–∞—Ä–∞—Ö)
        const uniqueSegmentsToRemove = [];
        const seenSegments = new Set();
        segmentsToRemove.forEach(seg => {
          const key = `${seg._trackIndex}_${seg.start}_${seg.end}_${seg.fragment.substring(0, 50)}`;
          if (!seenSegments.has(key)) {
            seenSegments.add(key);
            uniqueSegmentsToRemove.push(seg);
          }
        });
        
        if (uniqueSegmentsToRemove.length < segmentsToRemove.length) {
          console.log(`üîç [TEST_POST] Deduplicated segments: ${segmentsToRemove.length} -> ${uniqueSegmentsToRemove.length}`);
        }
        
        // –í–∏–¥–∞–ª—è—î–º–æ —Å–µ–≥–º–µ–Ω—Ç–∏ –∑ processedResults
        uniqueSegmentsToRemove.forEach((segmentToRemove, removeIdx) => {
          const trackIndex = segmentToRemove._trackIndex;
          const trackToUpdate = processedResults[trackIndex];
          
          if (!trackToUpdate || !trackToUpdate.dialogueAnalysis) {
            console.warn(`‚ö†Ô∏è [TEST_POST] Track ${trackIndex + 1} not found or has no dialogueAnalysis`);
            return;
          }
          
          // –ù–æ—Ä–º–∞–ª—ñ–∑—É—î–º–æ —Ç–µ–∫—Å—Ç –¥–ª—è –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è
          const normalizeText = (text) => {
            return (text || '').trim().toLowerCase().replace(/\s+/g, ' ');
          };
          
          const targetText = normalizeText(segmentToRemove.fragment);
          const targetStart = parseFloat(segmentToRemove.start);
          const targetEnd = parseFloat(segmentToRemove.end);
          const targetRole = segmentToRemove.role;
          
          console.log(`üîç [TEST_POST] Searching for segment to remove (${removeIdx + 1}/${segmentsToRemove.length}):`, {
            fragment: segmentToRemove.fragment.substring(0, 60),
            start: targetStart,
            end: targetEnd,
            role: targetRole,
            trackIndex: trackIndex + 1,
            availableSegments: trackToUpdate.dialogueAnalysis.length
          });
          
          // –°—Ç—Ä–∞—Ç–µ–≥—ñ—è 1: –¢–æ—á–Ω–µ –∑—ñ—Å—Ç–∞–≤–ª–µ–Ω–Ω—è –∑–∞ —Ç–∞–π–º—Å—Ç–µ–º–ø–∞–º–∏ —Ç–∞ —Ç–µ–∫—Å—Ç–æ–º
          let segmentIndex = trackToUpdate.dialogueAnalysis.findIndex(
            seg => {
              if (seg.start === null || seg.end === null) return false;
              
              const timeMatch = Math.abs(parseFloat(seg.start) - targetStart) < 0.1 &&
                                Math.abs(parseFloat(seg.end) - targetEnd) < 0.1;
              const textMatch = normalizeText(seg.fragment) === targetText;
              const roleMatch = seg.role === targetRole;
              
              return timeMatch && textMatch && roleMatch;
            }
          );
          
          // –°—Ç—Ä–∞—Ç–µ–≥—ñ—è 2: –ó—ñ—Å—Ç–∞–≤–ª–µ–Ω–Ω—è –∑–∞ —Ç–∞–π–º—Å—Ç–µ–º–ø–∞–º–∏ —Ç–∞ —Ä–æ–ª–ª—é (—è–∫—â–æ —Ç–µ–∫—Å—Ç –Ω–µ –∑–±—ñ–≥—Å—è —á–µ—Ä–µ–∑ –Ω–µ–≤–µ–ª–∏–∫—ñ –≤—ñ–¥–º—ñ–Ω–Ω–æ—Å—Ç—ñ)
          if (segmentIndex === -1) {
            segmentIndex = trackToUpdate.dialogueAnalysis.findIndex(
              seg => {
                if (seg.start === null || seg.end === null) return false;
                
                const timeMatch = Math.abs(parseFloat(seg.start) - targetStart) < 0.1 &&
                                  Math.abs(parseFloat(seg.end) - targetEnd) < 0.1;
                const roleMatch = seg.role === targetRole;
                const textSimilar = normalizeText(seg.fragment).includes(targetText) || 
                                   targetText.includes(normalizeText(seg.fragment));
                
                return timeMatch && roleMatch && textSimilar;
              }
            );
          }
          
          // –°—Ç—Ä–∞—Ç–µ–≥—ñ—è 3: –ó—ñ—Å—Ç–∞–≤–ª–µ–Ω–Ω—è —Ç—ñ–ª—å–∫–∏ –∑–∞ —Ç–∞–π–º—Å—Ç–µ–º–ø–∞–º–∏ (—è–∫—â–æ —Ä–æ–ª—ñ –∑–±—ñ–≥–∞—é—Ç—å—Å—è)
          if (segmentIndex === -1) {
            segmentIndex = trackToUpdate.dialogueAnalysis.findIndex(
              seg => {
                if (seg.start === null || seg.end === null) return false;
                
                const timeMatch = Math.abs(parseFloat(seg.start) - targetStart) < 0.1 &&
                                  Math.abs(parseFloat(seg.end) - targetEnd) < 0.1;
                const roleMatch = seg.role === targetRole;
                
                return timeMatch && roleMatch;
              }
            );
          }
          
          if (segmentIndex !== -1) {
            const removedSegment = trackToUpdate.dialogueAnalysis[segmentIndex];
            trackToUpdate.dialogueAnalysis.splice(segmentIndex, 1);
            console.log(`‚úÖ [TEST_POST] Successfully removed segment ${removeIdx + 1}/${segmentsToRemove.length} from track ${trackIndex + 1}:`, {
              fragment: removedSegment.fragment.substring(0, 60),
              start: removedSegment.start,
              end: removedSegment.end,
              role: removedSegment.role
            });
          } else {
            // –í–∏–≤–æ–¥–∏–º–æ –¥–µ—Ç–∞–ª—å–Ω—É —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –ø—Ä–æ –¥–æ—Å—Ç—É–ø–Ω—ñ —Å–µ–≥–º–µ–Ω—Ç–∏ –¥–ª—è –¥—ñ–∞–≥–Ω–æ—Å—Ç–∏–∫–∏
            console.error(`‚ùå [TEST_POST] Could not find segment to remove in track ${trackIndex + 1}:`, {
              target: {
                fragment: segmentToRemove.fragment.substring(0, 60),
                start: targetStart,
                end: targetEnd,
                role: targetRole
              },
              availableSegments: trackToUpdate.dialogueAnalysis.map((seg, idx) => ({
                index: idx,
                fragment: seg.fragment.substring(0, 60),
                start: seg.start,
                end: seg.end,
                role: seg.role,
                timeDiff: seg.start !== null && seg.end !== null ? {
                  startDiff: Math.abs(parseFloat(seg.start) - targetStart),
                  endDiff: Math.abs(parseFloat(seg.end) - targetEnd)
                } : null
              }))
            });
          }
        });
        
        // –û–Ω–æ–≤–ª—é—î–º–æ –Ω–æ–º–µ—Ä–∏ —Ñ—Ä–∞–≥–º–µ–Ω—Ç—ñ–≤ –ø—ñ—Å–ª—è –≤–∏–¥–∞–ª–µ–Ω–Ω—è
        processedResults.forEach(track => {
          if (track.dialogueAnalysis) {
            track.dialogueAnalysis.forEach((item, index) => {
              item.fragmentNumber = index + 1;
            });
          }
        });
        
        // –í–∏–≤–æ–¥–∏–º–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç
        const output = JSON.stringify(processedResults, null, 2);
        if (resultTextarea) {
          resultTextarea.value = output;
        } else {
          console.log('‚ÑπÔ∏è [TEST_POST] postProcessingResult textarea not found, result not displayed');
        }
        
        console.log('‚úÖ [TEST_POST] Post-processing completed');
        console.log(`üìä [TEST_POST] Removed ${uniqueSegmentsToRemove.length} duplicate segments`);
        
        // –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –∑–∞—Å—Ç–æ—Å–æ–≤—É—î–º–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –¥–æ —Ç–∞–±–ª–∏—Ü—ñ
        console.log('üîÑ [TEST_POST] Auto-applying filtered results to table...');
        try {
          await applyDebugMarkup(true); // –ü–µ—Ä–µ–¥–∞—î–º–æ true –¥–ª—è autoRun
          console.log('‚úÖ [TEST_POST] Filtered results applied to table successfully');
        } catch (applyError) {
          console.error('‚ùå [TEST_POST] Error applying filtered results to table:', applyError);
          // –ù–µ –∑—É–ø–∏–Ω—è—î–º–æ –≤–∏–∫–æ–Ω–∞–Ω–Ω—è, –±–æ –ø–æ—Å—Ç-–ø—Ä–æ—Ü–µ—Å–∏–Ω–≥ –∑–∞–≤–µ—Ä—à–∏–≤—Å—è —É—Å–ø—ñ—à–Ω–æ
        }
        
        // –ü–æ–∫–∞–∑—É—î–º–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –ø—Ä–æ —É—Å–ø—ñ—Ö —Ç—ñ–ª—å–∫–∏ —è–∫—â–æ –Ω–µ autoRun
        if (!autoRun) {
          const successMsg = document.createElement('div');
          successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #9b59b6; color: white; padding: 12px 20px; border-radius: 8px; z-index: 10000; box-shadow: 0 4px 6px rgba(0,0,0,0.1);';
          successMsg.innerHTML = `‚úÖ Post-processing completed! Removed ${uniqueSegmentsToRemove.length} duplicate(s). Table updated.`;
          document.body.appendChild(successMsg);
          setTimeout(() => successMsg.remove(), 3000);
        }
        
      } catch (error) {
        console.error('‚ùå [TEST_POST] Error:', error);
        const errorMessage = `Error: ${error.message}\n\nStack: ${error.stack || 'N/A'}`;
        if (resultTextarea) {
          resultTextarea.value = errorMessage;
        }
        if (!autoRun) {
          alert(`Error: ${error.message}`);
        }
      } finally {
        // –í—ñ–¥–Ω–æ–≤–ª—é—î–º–æ –∫–Ω–æ–ø–∫—É —Ç—ñ–ª—å–∫–∏ —è–∫—â–æ –Ω–µ autoRun —ñ –∫–Ω–æ–ø–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–∞
        if (!autoRun && btn) {
          btn.disabled = false;
          btn.style.opacity = '1';
          btn.style.cursor = 'pointer';
          btn.innerHTML = originalText;
        }
      }
    }
    
    // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –∑–∞—Å—Ç–æ—Å—É–≤–∞–Ω–Ω—è —Ä–æ–∑–º—ñ—Ç–∫–∏ –∑ debug –ø–æ–ª—è
    async function applyDebugMarkup(autoRun = false) {
      const btn = document.getElementById('applyBtn');
      const originalText = btn ? btn.innerHTML : '‚è≥ Applying...';
      const debugTextarea = document.getElementById('debugTextarea');
      const postProcessingResult = document.getElementById('postProcessingResult');
      
      // –ü–æ–∫–∞–∑—É—î–º–æ —ñ–Ω–¥–∏–∫–∞—Ç–æ—Ä –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —Ç—ñ–ª—å–∫–∏ —è–∫—â–æ –Ω–µ autoRun —ñ –∫–Ω–æ–ø–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–∞
      if (!autoRun && btn) {
        btn.disabled = true;
        btn.style.opacity = '0.6';
        btn.style.cursor = 'not-allowed';
        btn.innerHTML = '‚è≥ Applying...';
      }
      
      try {
        // –ü—Ä—ñ–æ—Ä–∏—Ç–µ—Ç: window.currentTable > debugTextarea > postProcessingResult
        // –¶–µ –∑–∞–±–µ–∑–ø–µ—á—É—î, —â–æ –æ–Ω–æ–≤–ª–µ–Ω—ñ –¥–∞–Ω—ñ –∑ –º—É–ª—å—Ç–∏–º–æ–¥–∞–ª—å–Ω–æ–≥–æ –∞–Ω–∞–ª—ñ–∑—É –º–∞—é—Ç—å –Ω–∞–π–≤–∏—â–∏–π –ø—Ä—ñ–æ—Ä–∏—Ç–µ—Ç
        let sourceText = null;
        let sourceName = 'debug textarea';
        
        // 1. –ù–∞–π–≤–∏—â–∏–π –ø—Ä—ñ–æ—Ä–∏—Ç–µ—Ç: window.currentTable (–æ–Ω–æ–≤–ª–µ–Ω—ñ –¥–∞–Ω—ñ)
        if (window.currentTable && Array.isArray(window.currentTable) && window.currentTable.length > 0) {
          sourceText = JSON.stringify(window.currentTable, null, 2);
          sourceName = 'window.currentTable';
          console.log('‚úÖ [applyDebugMarkup] Using window.currentTable as source (highest priority)');
        }
        
        // 2. –°–µ—Ä–µ–¥–Ω—ñ–π –ø—Ä—ñ–æ—Ä–∏—Ç–µ—Ç: debugTextarea (–º–æ–∂–µ –º—ñ—Å—Ç–∏—Ç–∏ –æ–Ω–æ–≤–ª–µ–Ω—ñ –¥–∞–Ω—ñ)
        if (!sourceText && debugTextarea && debugTextarea.value && debugTextarea.value.trim() !== '') {
          const debugText = debugTextarea.value.trim();
          // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ —Ü–µ –≤–∞–ª—ñ–¥–Ω–∏–π JSON
          try {
            const testParse = JSON.parse(debugText);
            if (Array.isArray(testParse) && testParse.length > 0) {
              sourceText = debugText;
              sourceName = 'debug textarea';
              console.log('‚ÑπÔ∏è [applyDebugMarkup] Using debug textarea as source');
            }
          } catch (e) {
            console.log('‚ÑπÔ∏è [applyDebugMarkup] Debug textarea is not valid JSON');
          }
        }
        
        // 3. –ù–∞–π–Ω–∏–∂—á–∏–π –ø—Ä—ñ–æ—Ä–∏—Ç–µ—Ç: postProcessingResult (—Å—Ç–∞—Ä–∏–π –ø–æ—Å—Ç-–ø—Ä–æ—Ü–µ—Å–∏–Ω–≥)
        if (!sourceText && postProcessingResult && postProcessingResult.value && postProcessingResult.value.trim() !== '') {
          const postProcessingText = postProcessingResult.value.trim();
          // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ —Ü–µ –≤–∞–ª—ñ–¥–Ω–∏–π JSON (–Ω–µ –ø–æ–º–∏–ª–∫–∞)
          try {
            const testParse = JSON.parse(postProcessingText);
            if (Array.isArray(testParse) && testParse.length > 0) {
              sourceText = postProcessingText;
              sourceName = 'post-processing result';
              console.log('‚úÖ [applyDebugMarkup] Using post-processing result (fallback)');
            }
          } catch (e) {
            console.log('‚ÑπÔ∏è [applyDebugMarkup] Post-processing result is not valid JSON');
          }
        }
        
        if (!sourceText || sourceText.trim() === '') {
          if (!autoRun) {
            alert('‚ö†Ô∏è Both debug textarea and post-processing result are empty. Please run the analysis first.');
          }
          console.warn('‚ö†Ô∏è [applyDebugMarkup] No source text available');
          return;
        }
        
        // –ü–∞—Ä—Å–∏–º–æ JSON
        let analysisResults = null;
        try {
          analysisResults = JSON.parse(sourceText);
        } catch (parseError) {
          throw new Error(`Failed to parse JSON from ${sourceName}. Please run the analysis first.`);
        }
        
        if (!Array.isArray(analysisResults) || analysisResults.length === 0) {
          throw new Error(`Invalid analysis results format in ${sourceName}. Expected array with dialogue analysis.`);
        }
        
        // Store analysis results in global variable for inter-module communication
        window.currentTable = analysisResults;
        console.log('‚úÖ [applyDebugMarkup] Saved to window.currentTable:', analysisResults);
        
        console.log(`üîç [applyDebugMarkup] Using data from ${sourceName}:`, {
          tracksCount: analysisResults.length,
          tracks: analysisResults.map(t => ({
            dialogueNumber: t.dialogueNumber,
            dialogueType: t.dialogueType,
            fragmentsCount: t.dialogueAnalysis?.length || 0
          }))
        });
        
        // –û–±'—î–¥–Ω—É—î–º–æ –≤—Å—ñ dialogueAnalysis –∑ –æ–±–æ—Ö —Ç—Ä–µ–∫—ñ–≤
        const allFragments = [];
        analysisResults.forEach(track => {
          if (track.dialogueAnalysis && Array.isArray(track.dialogueAnalysis)) {
            track.dialogueAnalysis.forEach(fragment => {
              allFragments.push({
                ...fragment,
                dialogueType: track.dialogueType
              });
            });
          }
        });
        
        if (allFragments.length === 0) {
          throw new Error('No fragments found in analysis results.');
        }
        
        // –°–æ—Ä—Ç—É—î–º–æ –∑–∞ start time (—è–∫—â–æ —î)
        allFragments.sort((a, b) => {
          const startA = a.start !== null && a.start !== undefined ? parseFloat(a.start) : Infinity;
          const startB = b.start !== null && b.start !== undefined ? parseFloat(b.start) : Infinity;
          return startA - startB;
        });
        
        console.log(`üìä [applyDebugMarkup] Total fragments: ${allFragments.length}`);
        
        // –§–æ—Ä–º—É—î–º–æ markdown —Ç–∞–±–ª–∏—Ü—é
        let markdownTable = '| Segment ID | Speaker | Text | Start Time | End Time |\n';
        markdownTable += '|------------|---------|------|------------|----------|\n';
        
        allFragments.forEach((fragment, index) => {
          const segmentId = index + 1;
          const speaker = fragment.role === 'agent' ? 'Agent' : 
                         fragment.role === 'client' ? 'Client' : 
                         'Unknown';
          const text = (fragment.fragment || '').trim();
          const startTime = fragment.start !== null && fragment.start !== undefined ? parseFloat(fragment.start).toFixed(2) : '0.00';
          const endTime = fragment.end !== null && fragment.end !== undefined ? parseFloat(fragment.end).toFixed(2) : startTime;
          
          if (text) {
            markdownTable += `| ${segmentId} | ${speaker} | ${text} | ${startTime} | ${endTime} |\n`;
          }
        });
        
        console.log('üìã [applyDebugMarkup] Generated markdown table:', {
          rows: allFragments.length,
          tableLength: markdownTable.length
        });
        
        // –ó–Ω–∞—Ö–æ–¥–∏–º–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è —Ç–∞–±–ª–∏—Ü—ñ
        let markdownContainer = document.getElementById('markdownTableContainer');
        
        // –Ø–∫—â–æ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ, —à—É–∫–∞—î–º–æ –≤ results-card
        if (!markdownContainer) {
          const resultsCard = document.querySelector('.results-card');
          if (resultsCard) {
            markdownContainer = resultsCard.querySelector('#markdownTableContainer') || 
                               resultsCard.querySelector('.markdown-table-container');
          }
        }
        
        // –Ø–∫—â–æ –≤—Å–µ —â–µ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ, —Å—Ç–≤–æ—Ä—é—î–º–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä
        if (!markdownContainer) {
          const resultsEl = document.getElementById('resultsInfo');
          if (resultsEl) {
            // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ —î legacy-markdown-details
            let legacyDetails = resultsEl.querySelector('.legacy-markdown-details');
            if (!legacyDetails) {
              // –°—Ç–≤–æ—Ä—é—î–º–æ legacy-markdown-details
              legacyDetails = document.createElement('details');
              legacyDetails.className = 'legacy-markdown-details';
              const summary = document.createElement('summary');
              summary.textContent = 'Legacy Markdown Table (debug)';
              legacyDetails.appendChild(summary);
              const note = document.createElement('div');
              note.className = 'legacy-note';
              note.textContent = 'Legacy view of the markdown output is preserved for debugging purposes.';
              legacyDetails.appendChild(note);
              markdownContainer = document.createElement('div');
              markdownContainer.id = 'markdownTableContainer';
              markdownContainer.className = 'markdown-table-container';
              legacyDetails.appendChild(markdownContainer);
              resultsEl.appendChild(legacyDetails);
            } else {
              markdownContainer = legacyDetails.querySelector('#markdownTableContainer') || 
                                 legacyDetails.querySelector('.markdown-table-container');
              if (!markdownContainer) {
                markdownContainer = document.createElement('div');
                markdownContainer.id = 'markdownTableContainer';
                markdownContainer.className = 'markdown-table-container';
                legacyDetails.appendChild(markdownContainer);
              }
            }
          } else {
            throw new Error('Results container not found. Please make sure the results are displayed first.');
          }
        }
        
        console.log('üîç [applyDebugMarkup] markdownContainer found:', markdownContainer);
        
        // –û—á–∏—â–∞—î–º–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –ø–µ—Ä–µ–¥ –ø–µ—Ä–µ–º–∞–ª—å–æ–≤—É–≤–∞–Ω–Ω—è–º
        markdownContainer.innerHTML = '';
        
        // –û—Ç—Ä–∏–º—É—î–º–æ originalSegments –¥–ª—è –≤–∏–¥—ñ–ª–µ–Ω–Ω—è (—è–∫—â–æ –ø–æ—Ç—Ä—ñ–±–Ω–æ)
        const { originalSegments } = extractSegments(currentAnalysisData || {});
        console.log('üîç [applyDebugMarkup] originalSegments count:', originalSegments?.length || 0);
        
        // –ü—Ä–∏—Ö–æ–≤—É—î–º–æ –ø—Ä–æ–≥—Ä–µ—Å–±–∞—Ä –ø–µ—Ä–µ–¥ —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–æ–º —Ç–∞–±–ª–∏—Ü—ñ
        hideTableGenerationProgress();
        
        // –†–µ–Ω–¥–µ—Ä–∏–º–æ —Ç–∞–±–ª–∏—Ü—é (–±–µ–∑ textAnalysis, –æ—Å–∫—ñ–ª—å–∫–∏ –º–∏ –Ω–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –≤–∏–¥—ñ–ª–µ–Ω–Ω—è)
        renderMarkdownTable(markdownTable, markdownContainer, originalSegments || [], null);
        
        console.log('‚úÖ [applyDebugMarkup] Table rendered successfully');
        
        // –†–æ–∑–∫—Ä–∏–≤–∞—î–º–æ details, —è–∫—â–æ –≤–æ–Ω–æ –∑–∞–∫—Ä–∏—Ç–µ
        const legacyDetails = markdownContainer.closest('.legacy-markdown-details');
        if (legacyDetails && !legacyDetails.open) {
          legacyDetails.open = true;
        }
        
        // –ö–æ–ø—ñ—é—î–º–æ markdown —Ç–∞–±–ª–∏—Ü—é –≤ –±—É—Ñ–µ—Ä –æ–±–º—ñ–Ω—É
        try {
          await navigator.clipboard.writeText(markdownTable);
          console.log('‚úÖ [applyDebugMarkup] Markdown table copied to clipboard');
        } catch (clipboardError) {
          console.warn('‚ö†Ô∏è [applyDebugMarkup] Failed to copy to clipboard:', clipboardError);
          // Fallback: –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ —Å—Ç–∞—Ä–∏–π –º–µ—Ç–æ–¥
          const textArea = document.createElement('textarea');
          textArea.value = markdownTable;
          textArea.style.position = 'fixed';
          textArea.style.opacity = '0';
          document.body.appendChild(textArea);
          textArea.select();
          try {
            document.execCommand('copy');
            console.log('‚úÖ [applyDebugMarkup] Markdown table copied to clipboard (fallback method)');
          } catch (fallbackError) {
            console.error('‚ùå [applyDebugMarkup] Failed to copy to clipboard (fallback):', fallbackError);
          }
          document.body.removeChild(textArea);
        }
        
        // –ó–∞–∫—Ä–∏–≤–∞—î–º–æ –≤—ñ–∫–Ω–æ –¥–µ–±–∞–≥—É —Ç—ñ–ª—å–∫–∏ —è–∫—â–æ –Ω–µ autoRun
        if (!autoRun) {
          closeDebugModal();
        }
        
        // –ü–æ–∫–∞–∑—É—î–º–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –ø—Ä–æ —É—Å–ø—ñ—Ö —Ç—ñ–ª—å–∫–∏ —è–∫—â–æ –Ω–µ autoRun
        if (!autoRun) {
          const successMsg = document.createElement('div');
          successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #10b981; color: white; padding: 12px 20px; border-radius: 8px; z-index: 10000; box-shadow: 0 4px 6px rgba(0,0,0,0.1);';
          successMsg.innerHTML = `‚úÖ Table rendered and copied! Fragments: ${allFragments.length}`;
          document.body.appendChild(successMsg);
          setTimeout(() => successMsg.remove(), 3000);
        }
        
        console.log('‚úÖ [applyDebugMarkup] Table applied:', {
          fragmentsCount: allFragments.length,
          tracksCount: analysisResults.length,
          autoRun: autoRun
        });
        
        // –Ø–∫—â–æ autoRun —ñ —î –∞—É–¥—ñ–æ —Ñ–∞–π–ª, –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –∑–∞–ø—É—Å–∫–∞—î–º–æ –º—É–ª—å—Ç–∏–º–æ–¥–∞–ª—å–Ω—É –æ–±—Ä–æ–±–∫—É
        // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ —Ü–µ –Ω–µ –≤–∏–∫–ª–∏–∫ –∑ –º—É–ª—å—Ç–∏–º–æ–¥–∞–ª—å–Ω–æ—ó –æ–±—Ä–æ–±–∫–∏ (—â–æ–± —É–Ω–∏–∫–Ω—É—Ç–∏ —Ä–µ–∫—É—Ä—Å—ñ—ó)
        // –¢–∞–∫–æ–∂ –ø–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ –¥–∞–Ω—ñ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω—ñ –∑ –∫–µ—à—É - —è–∫—â–æ —Ç–∞–∫, –Ω–µ –∑–∞–ø—É—Å–∫–∞—î–º–æ –æ–±—Ä–æ–±–∫—É
        if (autoRun && window.currentTable && window.currentTable.length > 0 && !window.multimodalProcessingInProgress) {
          // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ –¥–∞–Ω—ñ –∑ –∫–µ—à—É
          if (window.dataLoadedFromCache) {
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('üì¶ [applyDebugMarkup] Data loaded from cache - skipping automatic multimodal processing');
            console.log('‚ÑπÔ∏è [applyDebugMarkup] No Gemini request will be made');
            console.log('‚ÑπÔ∏è [applyDebugMarkup] No merge analysis will be performed');
            console.log('‚ÑπÔ∏è [applyDebugMarkup] "Applying merged results" will not be executed');
            console.log('‚ÑπÔ∏è [applyDebugMarkup] Request to server will NOT be sent');
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            // –ù–ï —Å–∫–∏–¥–∞—î–º–æ –ø—Ä–∞–ø–æ—Ä–µ—Ü—å —Ç—É—Ç - –≤—ñ–Ω –±—É–¥–µ —Å–∫–∏–Ω—É—Ç–∏–π –≤ loadLastFile –ø—ñ—Å–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è
          } else {
            console.log('üîÑ [applyDebugMarkup] Checking for automatic multimodal processing...');
            // –ù–µ–≤–µ–ª–∏–∫–∞ –∑–∞—Ç—Ä–∏–º–∫–∞, —â–æ–± —Ç–∞–±–ª–∏—Ü—è –≤—Å—Ç–∏–≥–ª–∞ –≤—ñ–¥—Ä–µ–Ω–¥–µ—Ä–∏—Ç–∏—Å—è
            setTimeout(() => {
              runAutomaticMultimodalProcessing().catch(err => {
                console.warn('‚ö†Ô∏è [applyDebugMarkup] Automatic multimodal processing failed:', err);
                // –ù–µ –ø–æ–∫–∞–∑—É—î–º–æ –ø–æ–º–∏–ª–∫—É –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—É, –±–æ —Ü–µ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–∏–π –ø—Ä–æ—Ü–µ—Å
              });
            }, 500);
          }
        }
        
      } catch (error) {
        console.error('‚ùå [applyDebugMarkup] Error:', error);
        // –ü—Ä–∏—Ö–æ–≤—É—î–º–æ –ø—Ä–æ–≥—Ä–µ—Å–±–∞—Ä –ø—Ä–∏ –ø–æ–º–∏–ª—Ü—ñ
        hideTableGenerationProgress();
        if (!autoRun) {
          alert(`‚ùå Failed to apply markup: ${error.message}`);
        }
      } finally {
        // –í—ñ–¥–Ω–æ–≤–ª—é—î–º–æ –∫–Ω–æ–ø–∫—É —Ç—ñ–ª—å–∫–∏ —è–∫—â–æ –Ω–µ autoRun
        if (!autoRun) {
          btn.disabled = false;
          btn.style.opacity = '1';
          btn.style.cursor = 'pointer';
          btn.innerHTML = originalText;
        }
      }
    }
    
    // –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–∞ –º—É–ª—å—Ç–∏–º–æ–¥–∞–ª—å–Ω–∞ –æ–±—Ä–æ–±–∫–∞ –ø—ñ—Å–ª—è overlap-–¥—ñ–∞—Ä–∏–∑–∞—Ü—ñ—ó
    async function runAutomaticMultimodalProcessing() {
      // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ –¥–∞–Ω—ñ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω—ñ –∑ –∫–µ—à—É - —è–∫—â–æ —Ç–∞–∫, –ø—Ä–æ–ø—É—Å–∫–∞—î–º–æ –æ–±—Ä–æ–±–∫—É
      if (window.dataLoadedFromCache) {
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        console.log('üì¶ [AUTO MULTIMODAL] Data loaded from cache - skipping multimodal processing');
        console.log('‚ÑπÔ∏è [AUTO MULTIMODAL] Multimodal results already available in cached data');
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        // –°–∫–∏–¥–∞—î–º–æ –ø—Ä–∞–ø–æ—Ä–µ—Ü—å –ø—ñ—Å–ª—è –ø–µ—Ä—à–æ—ó –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏
        window.dataLoadedFromCache = false;
        return;
      }
      
      // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ –≤–∂–µ –≤–∏–∫–æ–Ω—É—î—Ç—å—Å—è –º—É–ª—å—Ç–∏–º–æ–¥–∞–ª—å–Ω–∞ –æ–±—Ä–æ–±–∫–∞ (—â–æ–± —É–Ω–∏–∫–Ω—É—Ç–∏ –ø–æ–¥–≤—ñ–π–Ω–æ–≥–æ –≤–∏–∫–ª–∏–∫—É)
      if (window.multimodalProcessingInProgress) {
        console.log('‚ÑπÔ∏è [AUTO MULTIMODAL] Multimodal processing already in progress, skipping');
        return;
      }
      
      window.multimodalProcessingInProgress = true;
      
      try {
        // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –Ω–∞—è–≤–Ω—ñ—Å—Ç—å –∞—É–¥—ñ–æ —Ñ–∞–π–ª—É –∞–±–æ URL
        let audioFile = null;
        let audioUrl = null;
        
        const audioFileInput = document.getElementById('audioFile');
        if (audioFileInput && audioFileInput.files && audioFileInput.files.length > 0) {
          audioFile = audioFileInput.files[0];
          console.log('‚úÖ [AUTO MULTIMODAL] Found audio file in input');
        } else {
          // –°–ø—Ä–æ–±—É—î–º–æ –æ—Ç—Ä–∏–º–∞—Ç–∏ URL –∑—ñ –∑–±–µ—Ä–µ–∂–µ–Ω–∏—Ö –¥–∞–Ω–∏—Ö
          if (currentAnalysisData && currentAnalysisData.fileUrl) {
            audioUrl = currentAnalysisData.fileUrl;
            console.log('‚úÖ [AUTO MULTIMODAL] Found audio URL in currentAnalysisData:', audioUrl);
          } else {
            // –°–ø—Ä–æ–±—É—î–º–æ –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ —Ñ–∞–π–ª –∑ localStorage
            const savedAudioFile = loadAudioFileFromStorage();
            if (savedAudioFile) {
              audioFile = savedAudioFile;
              console.log('‚úÖ [AUTO MULTIMODAL] Loaded audio file from storage');
            } else {
              // –ü–æ–∫–∞–∑—É—î–º–æ –º–æ–¥–∞–ª—å–Ω–µ –≤—ñ–∫–Ω–æ –¥–ª—è –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —Ñ–∞–π–ª—É
              console.log('‚ÑπÔ∏è [AUTO MULTIMODAL] No audio file found, showing upload modal');
              showAudioUploadModal(() => {
                // –ü—ñ—Å–ª—è –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è —Ñ–∞–π–ª—É, –ø–æ–≤—Ç–æ—Ä–Ω–æ –≤–∏–∫–ª–∏–∫–∞—î–º–æ –æ–±—Ä–æ–±–∫—É
                console.log('üîÑ [AUTO MULTIMODAL] File saved, retrying multimodal processing...');
                runAutomaticMultimodalProcessing();
              });
              window.multimodalProcessingInProgress = false;
          return;
        }
          }
        }
        
        // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ —î window.currentTable
        if (!window.currentTable || !Array.isArray(window.currentTable) || window.currentTable.length === 0) {
          console.log('‚ÑπÔ∏è [AUTO MULTIMODAL] window.currentTable not available, skipping');
          window.multimodalProcessingInProgress = false;
          return;
        }
        
        console.log('üîÑ [AUTO MULTIMODAL] Starting automatic multimodal processing...');
        
        // –ö–æ–Ω–≤–µ—Ä—Ç—É—î–º–æ currentTable –≤ transcript —Ñ–æ—Ä–º–∞—Ç
        const transcriptLines = [];
        window.currentTable.forEach(track => {
          const dialogueType = track.dialogueType || 'unknown';
          const dialogueNumber = track.dialogueNumber || 0;
          const speakerLabel = dialogueType === 'agent' ? `SPEAKER_${dialogueNumber === 1 ? '01' : '00'}` : 
                               dialogueType === 'client' ? `SPEAKER_${dialogueNumber === 1 ? '01' : '00'}` : 
                               `SPEAKER_${dialogueNumber === 1 ? '01' : '00'}`;
          
          if (track.dialogueAnalysis && Array.isArray(track.dialogueAnalysis)) {
            track.dialogueAnalysis.forEach(fragment => {
              const text = fragment.fragment || '';
              if (text.trim()) {
                transcriptLines.push(`${speakerLabel}: ${text}`);
              }
            });
          }
        });
        
        const transcript = transcriptLines.join('\n');
        console.log(`‚úÖ [AUTO MULTIMODAL] Converted currentTable to transcript (${transcriptLines.length} lines)`);
        
        // –Ø–∫—â–æ –Ω–µ–º–∞—î –Ω—ñ —Ñ–∞–π–ª—É, –Ω—ñ URL, –∞–ª–µ —î transcript - –≤—Å–µ –æ–¥–Ω–æ –∑–∞–ø—É—Å–∫–∞—î–º–æ –æ–±—Ä–æ–±–∫—É
        if (!audioFile && !audioUrl && !transcript.trim()) {
          console.log('‚ÑπÔ∏è [AUTO MULTIMODAL] No audio file, URL, or transcript available, skipping');
          window.multimodalProcessingInProgress = false;
          return;
        }
        
        // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ —î —Ö–æ—á–∞ –± –æ–¥–∏–Ω –æ–±–æ–≤'—è–∑–∫–æ–≤–∏–π –ø–∞—Ä–∞–º–µ—Ç—Ä
        if (!audioFile && !audioUrl && !transcript.trim()) {
          console.warn('‚ö†Ô∏è [AUTO MULTIMODAL] No audio file, URL, or transcript available, skipping');
          window.multimodalProcessingInProgress = false;
          return;
        }
        
        // –§–æ—Ä–º—É—î–º–æ FormData –¥–ª—è –≤—ñ–¥–ø—Ä–∞–≤–∫–∏
        const formData = new FormData();
        
        // –î–æ–¥–∞—î–º–æ –∞—É–¥—ñ–æ —Ñ–∞–π–ª —è–∫—â–æ —î
        if (audioFile) {
          formData.append('audio', audioFile);
          console.log(`‚úÖ [AUTO MULTIMODAL] Added audio file: ${audioFile.name} (${audioFile.size} bytes)`);
        }
        
        // –î–æ–¥–∞—î–º–æ URL —è–∫—â–æ —î
        if (audioUrl) {
          formData.append('url', audioUrl);
          console.log(`‚úÖ [AUTO MULTIMODAL] Added audio URL: ${audioUrl}`);
        }
        
        formData.append('pipelineMode', 'multimodal');
        const language = document.getElementById('language')?.value || 'en';
        formData.append('language', language);
        console.log(`‚úÖ [AUTO MULTIMODAL] Added language: ${language}`);
        
        if (transcript.trim()) {
          formData.append('plainTranscript', transcript);
          console.log(`‚úÖ [AUTO MULTIMODAL] Added transcript (${transcript.length} chars) to request`);
        } else {
          console.warn('‚ö†Ô∏è [AUTO MULTIMODAL] No transcript available, request may fail');
        }
        
        // –õ–æ–≥—É—î–º–æ –≤—Å—ñ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ FormData –¥–ª—è –¥–µ–±–∞–≥—É
        console.log('üìã [AUTO MULTIMODAL] FormData contents:', {
          hasAudio: formData.has('audio'),
          hasUrl: formData.has('url'),
          hasTranscript: formData.has('plainTranscript'),
          pipelineMode: formData.get('pipelineMode'),
          language: formData.get('language')
        });
        
        // –í—ñ–¥–ø—Ä–∞–≤–ª—è—î–º–æ –∑–∞–ø–∏—Ç –Ω–∞ —Å–µ—Ä–≤–µ—Ä
        console.log('üì§ [AUTO MULTIMODAL] Sending request to server...', {
          hasAudioFile: !!audioFile,
          hasAudioUrl: !!audioUrl,
          hasTranscript: !!transcript.trim(),
          transcriptLength: transcript.length,
          audioFileName: audioFile?.name,
          audioFileSize: audioFile?.size
        });
        
        const response = await fetch('/api/diarize-combined', {
          method: 'POST',
          body: formData
        });
        
        if (!response.ok) {
          // –°–ø—Ä–æ–±—É—î–º–æ –æ—Ç—Ä–∏–º–∞—Ç–∏ –¥–µ—Ç–∞–ª—å–Ω—É —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –ø—Ä–æ –ø–æ–º–∏–ª–∫—É
          let errorMessage = `HTTP ${response.status}`;
          let errorDetails = null;
          
          try {
            const errorText = await response.text();
            console.error('‚ùå [AUTO MULTIMODAL] Server error response:', errorText);
            
            try {
              errorDetails = JSON.parse(errorText);
              errorMessage = errorDetails.error || errorDetails.message || errorMessage;
            } catch (e) {
              // –Ø–∫—â–æ –Ω–µ JSON, –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ —Ç–µ–∫—Å—Ç —è–∫ —î
              errorMessage = errorText || errorMessage;
            }
          } catch (e) {
            console.error('‚ùå [AUTO MULTIMODAL] Failed to read error response:', e);
          }
          
          console.error('‚ùå [AUTO MULTIMODAL] Request failed:', {
            status: response.status,
            statusText: response.statusText,
            errorMessage: errorMessage,
            errorDetails: errorDetails
          });
          
          throw new Error(`LLM diarization failed: ${errorMessage}`);
        }
        
        // –û—Ç—Ä–∏–º—É—î–º–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç —è–∫ JSON (—è–∫ –≤ runMultimodalDiarization)
        console.log('üì• [AUTO MULTIMODAL] Processing response...');
        const result = await response.json();
        
        console.log('‚úÖ [AUTO MULTIMODAL] Raw result received:', result);
        
        // –í–∏—Ç—è–≥—É—î–º–æ —Å–µ–≥–º–µ–Ω—Ç–∏ –∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—É (–≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ —Ç—É –∂ –ª–æ–≥—ñ–∫—É, —â–æ —ñ –≤ runMultimodalDiarization)
        let segments = [];
        
        // –°–ø—Ä–æ–±—É—î–º–æ –∑–Ω–∞–π—Ç–∏ —Å–µ–≥–º–µ–Ω—Ç–∏ –≤ —Ä—ñ–∑–Ω–∏—Ö –º–æ–∂–ª–∏–≤–∏—Ö –º—ñ—Å—Ü—è—Ö
        if (result?.recordings?.[0]?.results?.['text-service']?.segments) {
          segments = result.recordings[0].results['text-service'].segments;
          console.log('‚úÖ [AUTO MULTIMODAL] Found segments in text-service');
        } else if (result?.recordings?.[0]?.results?.speechmatics?.segments) {
          segments = result.recordings[0].results.speechmatics.segments;
          console.log('‚úÖ [AUTO MULTIMODAL] Found segments in speechmatics');
        } else if (result?.recordings?.[0]?.results?.combined?.segments) {
          segments = result.recordings[0].results.combined.segments;
          console.log('‚úÖ [AUTO MULTIMODAL] Found segments in combined');
        } else if (result?.segments && Array.isArray(result.segments)) {
          segments = result.segments;
          console.log('‚úÖ [AUTO MULTIMODAL] Found segments at top level');
        } else {
          // –†–µ–∫—É—Ä—Å–∏–≤–Ω–∏–π –ø–æ—à—É–∫ —Å–µ–≥–º–µ–Ω—Ç—ñ–≤
          function findSegments(obj, path = '') {
            if (Array.isArray(obj) && obj.length > 0) {
              if (obj[0] && (obj[0].text || obj[0].transcript || obj[0].speaker)) {
                return obj;
              }
            }
            
            if (typeof obj === 'object' && obj !== null) {
              for (const key in obj) {
                if (key === 'segments' && Array.isArray(obj[key]) && obj[key].length > 0) {
                  return obj[key];
                }
                const found = findSegments(obj[key], path + '.' + key);
                if (found) return found;
              }
            }
            return null;
          }
          
          const foundSegments = findSegments(result);
          if (foundSegments) {
            segments = foundSegments;
            console.log('‚úÖ [AUTO MULTIMODAL] Found segments via recursive search');
          }
        }
        
        if (segments.length === 0) {
          console.warn('‚ö†Ô∏è [AUTO MULTIMODAL] No segments found in multimodal result');
          return;
        }
        
        console.log(`‚úÖ [AUTO MULTIMODAL] Found ${segments.length} segments from multimodal diarization`);
        
        // –ö–æ–Ω–≤–µ—Ä—Ç—É—î–º–æ —Å–µ–≥–º–µ–Ω—Ç–∏ –≤ —Ñ–æ—Ä–º–∞—Ç —Ä–µ–ø–ª—ñ–∫ (–≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ —Ç—É –∂ –ª–æ–≥—ñ–∫—É, —â–æ —ñ –≤ runMultimodalDiarization)
        const multimodalReplicas = segments.map((seg, index) => {
          const replica = {
            index: index + 1,
            speaker: seg.speaker || seg.speaker_id || seg.speakerLabel || 'UNKNOWN',
            text: seg.text || seg.transcript || seg.content || '',
            start: parseFloat(seg.start) || parseFloat(seg.startTime) || 0,
            end: parseFloat(seg.end) || parseFloat(seg.endTime) || parseFloat(seg.start) || 0,
            duration: 0
          };
          
          // –û–±—á–∏—Å–ª—é—î–º–æ —Ç—Ä–∏–≤–∞–ª—ñ—Å—Ç—å
          replica.duration = replica.end - replica.start;
          
          // –í–∞–ª—ñ–¥–∞—Ü—ñ—è —Ç–∞ –Ω–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—è —Ä–æ–ª—ñ –≤—ñ–¥ Gemini (–ø—Ä—ñ–æ—Ä–∏—Ç–µ—Ç Gemini)
          if (seg.role) {
            const geminiRole = (seg.role || '').toLowerCase().trim();
            
            // –ù–æ—Ä–º–∞–ª—ñ–∑—É—î–º–æ —Ä–æ–ª—å –≤—ñ–¥ Gemini
            let normalizedRole = null;
            if (geminiRole === 'operator' || geminiRole === 'agent') {
              normalizedRole = 'operator';
            } else if (geminiRole === 'client' || geminiRole === 'customer') {
              normalizedRole = 'client';
            }
            
            // –Ø–∫—â–æ —Ä–æ–ª—å –≤–∞–ª—ñ–¥–Ω–∞, –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ —ó—ó (–ø—Ä—ñ–æ—Ä–∏—Ç–µ—Ç Gemini)
            if (normalizedRole) {
              replica.role = normalizedRole;
              replica.roleSource = 'gemini';
            } else {
              // –Ø–∫—â–æ —Ä–æ–ª—å –Ω–µ –≤–∞–ª—ñ–¥–Ω–∞, —Å–ø—Ä–æ–±—É—î–º–æ –≤–∏–∑–Ω–∞—á–∏—Ç–∏ –Ω–∞ –æ—Å–Ω–æ–≤—ñ —Å–ø—ñ–∫–µ—Ä–∞ (fallback)
              const speaker = replica.speaker;
              if (speaker.includes('SPEAKER_00') || speaker.includes('SPEAKER_0')) {
                replica.role = 'operator';
                replica.roleSource = 'fallback-speaker';
              } else if (speaker.includes('SPEAKER_01') || speaker.includes('SPEAKER_1')) {
                replica.role = 'client';
                replica.roleSource = 'fallback-speaker';
              }
            }
          } else {
            // –Ø–∫—â–æ —Ä–æ–ª—å –≤—ñ–¥—Å—É—Ç–Ω—è, –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ fallback –Ω–∞ –æ—Å–Ω–æ–≤—ñ —Å–ø—ñ–∫–µ—Ä–∞
            const speaker = replica.speaker;
            if (speaker.includes('SPEAKER_00') || speaker.includes('SPEAKER_0')) {
              replica.role = 'operator';
              replica.roleSource = 'fallback-speaker';
            } else if (speaker.includes('SPEAKER_01') || speaker.includes('SPEAKER_1')) {
              replica.role = 'client';
              replica.roleSource = 'fallback-speaker';
            }
          }
          
          return replica;
        });
        
        console.log(`‚úÖ [AUTO MULTIMODAL] Converted to ${multimodalReplicas.length} replicas`);
        
        // –û–±'—î–¥–Ω—É—î–º–æ –∑ overlap-–¥—ñ–∞—Ä–∏–∑–∞—Ü—ñ—î—é
        // –°—Ç–≤–æ—Ä—é—î–º–æ —Ç–∏–º—á–∞—Å–æ–≤—ñ –µ–ª–µ–º–µ–Ω—Ç–∏ –¥–ª—è mergeReplicasWithLLM
        const tempResultEl = document.createElement('textarea');
        tempResultEl.id = 'tempMultimodalResult';
        tempResultEl.style.display = 'none';
        document.body.appendChild(tempResultEl);
        
        const tempStatusEl = document.createElement('div');
        tempStatusEl.id = 'tempMultimodalStatus';
        tempStatusEl.style.display = 'none';
        document.body.appendChild(tempStatusEl);
        
        console.log('üîÑ [AUTO MULTIMODAL] Starting merge with overlap-diarization...');
        await mergeReplicasWithLLM(multimodalReplicas, tempResultEl, tempStatusEl);
        
        // –û—Ç—Ä–∏–º—É—î–º–æ –æ–±'—î–¥–Ω–∞–Ω—ñ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏
        const mergeData = JSON.parse(tempResultEl.value);
        
        // –ó–∞—Å—Ç–æ—Å–æ–≤—É—î–º–æ –æ–±'—î–¥–Ω–∞–Ω—ñ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏ –¥–æ —Ç–∞–±–ª–∏—Ü—ñ
        console.log('üîÑ [AUTO MULTIMODAL] Applying merged results to table...');
        
        // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ —Ç—É –∂ –ª–æ–≥—ñ–∫—É, —â–æ —ñ –≤ applyMultimodalResults
        const mergedTracks = {};
        
        mergeData.replicas.forEach((replica, idx) => {
          let selectedText = null;
          let selectedSource = null;
          let role = null;
          let speaker = null;
          
          if (replica.decision && replica.decision.selectedText) {
            selectedText = replica.decision.selectedText;
            selectedSource = replica.decision.selectedSource;
            
            // –í–∏–∑–Ω–∞—á–∞—î–º–æ —Ä–æ–ª—å: –ø–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ —Ä–æ–ª—ñ —Å–ø—ñ–≤–ø–∞–¥–∞—é—Ç—å
            const overlapRole = replica.versions?.overlap?.role;
            const multimodalRole = replica.versions?.multimodal?.role;
            const roleMatch = overlapRole === multimodalRole;
            
            // –Ø–∫—â–æ —Ä–æ–ª—ñ —Å–ø—ñ–≤–ø–∞–¥–∞—é—Ç—å, –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ —ó—Ö
            // –Ø–∫—â–æ –Ω–µ —Å–ø—ñ–≤–ø–∞–¥–∞—é—Ç—å, –ø—Ä—ñ–æ—Ä–∏—Ç–µ—Ç overlap-–¥—ñ–∞—Ä–∏–∑–∞—Ü—ñ—ó (–≤–æ–Ω–∞ –∑–∞–∑–≤–∏—á–∞–π —Ç–æ—á–Ω—ñ—à–∞ –¥–ª—è —Ä–æ–ª–µ–π)
            if (roleMatch) {
              role = overlapRole || multimodalRole || 'unknown';
            } else {
              // –†–æ–ª—ñ –Ω–µ —Å–ø—ñ–≤–ø–∞–¥–∞—é—Ç—å - –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ —Ä–æ–ª—å –∑ overlap (—Ç–æ—á–Ω—ñ—à–∞)
              if (selectedSource === 'merged') {
                // –î–ª—è merged: –ø–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –º–µ—Ç—Ä–∏–∫–∏
                const hasRoleMatch = replica.metrics?.roleMatch;
                if (hasRoleMatch === false && overlapRole) {
                  role = overlapRole;
                } else if (multimodalRole) {
                  role = multimodalRole;
                } else {
                  role = overlapRole || 'unknown';
                }
              } else {
                role = overlapRole || multimodalRole || 'unknown';
              }
            }
            
            // –í–∏–∑–Ω–∞—á–∞—î–º–æ —Å–ø—ñ–∫–µ—Ä–∞ –∞–Ω–∞–ª–æ–≥—ñ—á–Ω–æ
            const overlapSpeaker = replica.versions?.overlap?.speaker;
            const multimodalSpeaker = replica.versions?.multimodal?.speaker;
            const speakerMatch = overlapSpeaker === multimodalSpeaker;
            
            if (speakerMatch) {
              speaker = overlapSpeaker || multimodalSpeaker || 'SPEAKER_00';
            } else {
              speaker = overlapSpeaker || multimodalSpeaker || 'SPEAKER_00';
            }
          } else if (replica.note && replica.note.includes('No overlap-diarization counterpart')) {
            selectedText = replica.versions?.multimodal?.text || '';
            selectedSource = 'multimodal-diarization';
            role = replica.versions?.multimodal?.role || 'unknown';
            speaker = replica.versions?.multimodal?.speaker || 'SPEAKER_00';
          } else {
            return;
          }
          
          if (!selectedText || selectedText.trim() === '') {
            return;
          }
          
          const dialogueType = role === 'operator' || role === 'agent' ? 'agent' : 
                              role === 'client' || role === 'customer' ? 'client' : 'unknown';
          const dialogueNumber = speaker === 'SPEAKER_01' ? 1 : 0;
          
          if (!mergedTracks[dialogueNumber]) {
            mergedTracks[dialogueNumber] = {
              dialogueNumber: dialogueNumber,
              dialogueType: dialogueType,
              dialogueAnalysis: []
            };
          }
          
          let start = null;
          let end = null;
          if (selectedSource === 'merged' && replica.versions?.overlap && replica.versions?.multimodal) {
            start = Math.min(replica.versions.overlap.start || Infinity, replica.versions.multimodal.start || Infinity);
            end = Math.max(replica.versions.overlap.end || 0, replica.versions.multimodal.end || 0);
          } else if (selectedSource === 'overlap-diarization' && replica.versions?.overlap) {
            start = replica.versions.overlap.start;
            end = replica.versions.overlap.end;
          } else if (selectedSource === 'multimodal-diarization' && replica.versions?.multimodal) {
            start = replica.versions.multimodal.start;
            end = replica.versions.multimodal.end;
          } else if (replica.versions?.multimodal) {
            start = replica.versions.multimodal.start;
            end = replica.versions.multimodal.end;
          } else if (replica.versions?.overlap) {
            start = replica.versions.overlap.start;
            end = replica.versions.overlap.end;
          }
          
          const fragmentRole = role === 'operator' || role === 'agent' ? 'agent' : 'client';
          
          mergedTracks[dialogueNumber].dialogueAnalysis.push({
            fragmentNumber: mergedTracks[dialogueNumber].dialogueAnalysis.length + 1,
            fragment: selectedText,
            role: fragmentRole,
            start: start,
            end: end
          });
        });
        
        // –°–æ—Ä—Ç—É—î–º–æ —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∏ –∑–∞ —á–∞—Å–æ–º –ø–æ—á–∞—Ç–∫—É
        Object.values(mergedTracks).forEach(track => {
          track.dialogueAnalysis.sort((a, b) => (a.start || 0) - (b.start || 0));
          track.dialogueAnalysis.forEach((frag, idx) => {
            frag.fragmentNumber = idx + 1;
          });
        });
        
        const newTable = Object.values(mergedTracks).sort((a, b) => a.dialogueNumber - b.dialogueNumber);
        
        // –û–Ω–æ–≤–ª—é—î–º–æ window.currentTable
        window.currentTable = newTable;
        console.log(`‚úÖ [AUTO MULTIMODAL] Updated window.currentTable with ${newTable.length} tracks`);
        
        // –û–Ω–æ–≤–ª—é—î–º–æ debugTextarea
        const debugTextarea = document.getElementById('debugTextarea');
        if (debugTextarea) {
          debugTextarea.value = JSON.stringify(newTable, null, 2);
        }
        
        // –û–Ω–æ–≤–ª—é—î–º–æ —Ç–∞–±–ª–∏—Ü—é
        await applyDebugMarkup(true);
        
        // –í–∏–¥–∞–ª—è—î–º–æ —Ç–∏–º—á–∞—Å–æ–≤—ñ –µ–ª–µ–º–µ–Ω—Ç–∏
        document.body.removeChild(tempResultEl);
        document.body.removeChild(tempStatusEl);
        
        // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –æ–Ω–æ–≤–ª–µ–Ω—ñ –¥–∞–Ω—ñ –≤ –∫–µ—à –ø—ñ—Å–ª—è —É—Å–ø—ñ—à–Ω–æ–≥–æ –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        console.log('üíæ [AUTO MULTIMODAL] Starting cache update after successful processing...');
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        
        try {
          // –û–Ω–æ–≤–ª—é—î–º–æ currentAnalysisData –∑ –Ω–æ–≤–∏–º–∏ –¥–∞–Ω–∏–º–∏
          if (currentAnalysisData) {
            console.log('üìã [AUTO MULTIMODAL] Updating currentAnalysisData...');
            
            // –û–Ω–æ–≤–ª—é—î–º–æ currentTable –≤ currentAnalysisData
            currentAnalysisData.currentTable = newTable;
            
            // –û–Ω–æ–≤–ª—é—î–º–æ multimodalResult —è–∫—â–æ —î
            const multimodalResultEl = document.getElementById('multimodalResult');
            if (multimodalResultEl && multimodalResultEl.value) {
              currentAnalysisData.multimodalResult = multimodalResultEl.value;
              console.log('‚úÖ [AUTO MULTIMODAL] Multimodal result found and added to cache data');
            }
            
            // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –æ–Ω–æ–≤–ª–µ–Ω–∏–π —Å—Ç–∞–Ω
            console.log('üìã [AUTO MULTIMODAL] Calling savePageState() to save to localStorage...');
            savePageState(currentAnalysisData);
            
            console.log('‚úÖ [AUTO MULTIMODAL] ‚úÖ CACHE UPDATE SUCCESSFUL ‚úÖ', {
              tracksCount: newTable.length,
              hasMultimodalResult: !!currentAnalysisData.multimodalResult,
              cacheTimestamp: new Date().toISOString(),
              dataSize: JSON.stringify(newTable).length
            });
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
          } else {
            console.log('‚ö†Ô∏è [AUTO MULTIMODAL] currentAnalysisData not found, creating minimal state...');
            
            // –Ø–∫—â–æ currentAnalysisData –Ω–µ–º–∞—î, —Å—Ç–≤–æ—Ä—é—î–º–æ –º—ñ–Ω—ñ–º–∞–ª—å–Ω–∏–π —Å—Ç–∞–Ω –¥–ª—è –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è
            const minimalState = {
              timestamp: Date.now(),
              currentTable: newTable,
              multimodalResult: document.getElementById('multimodalResult')?.value || null
            };
            
            // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –º—ñ–Ω—ñ–º–∞–ª—å–Ω–∏–π —Å—Ç–∞–Ω
            try {
              const state = {
                timestamp: Date.now(),
                data: minimalState,
                fileName: 'multimodal-processed',
                fileUrl: null,
                currentTable: newTable,
                multimodalResult: minimalState.multimodalResult
              };
              
              console.log('üìã [AUTO MULTIMODAL] Saving minimal state to localStorage...');
              localStorage.setItem('lastFileState', JSON.stringify(state));
              
              console.log('‚úÖ [AUTO MULTIMODAL] ‚úÖ MINIMAL CACHE UPDATE SUCCESSFUL ‚úÖ', {
                tracksCount: newTable.length,
                hasMultimodalResult: !!minimalState.multimodalResult,
                cacheTimestamp: new Date().toISOString(),
                dataSize: JSON.stringify(newTable).length
              });
              console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            } catch (cacheError) {
              console.error('‚ùå [AUTO MULTIMODAL] ‚ùå CACHE UPDATE FAILED ‚ùå', {
                error: cacheError.message,
                errorName: cacheError.name
              });
              console.error('‚ùå [AUTO MULTIMODAL] Failed to save minimal state to cache:', cacheError);
              console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            }
          }
        } catch (cacheError) {
          console.error('‚ùå [AUTO MULTIMODAL] ‚ùå CACHE UPDATE FAILED ‚ùå', {
            error: cacheError.message,
            errorName: cacheError.name,
            errorStack: cacheError.stack
          });
          console.error('‚ùå [AUTO MULTIMODAL] Failed to save updated state to cache:', cacheError);
          console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        }
        
        console.log('‚úÖ [AUTO MULTIMODAL] Automatic multimodal processing completed successfully');
        
      } catch (error) {
        console.error('‚ùå [AUTO MULTIMODAL] Error during automatic multimodal processing:', error);
        console.error('‚ùå [AUTO MULTIMODAL] Error stack:', error.stack);
        
        // –ü–æ–∫–∞–∑—É—î–º–æ –ø–æ–º–∏–ª–∫—É —Ç—ñ–ª—å–∫–∏ —è–∫—â–æ —Ü–µ –Ω–µ —Ç–∏—Ö–∞ –ø–æ–º–∏–ª–∫–∞ (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, –≤—ñ–¥—Å—É—Ç–Ω—ñ—Å—Ç—å —Ñ–∞–π–ª—É)
        if (error.message && !error.message.includes('skipping') && !error.message.includes('not available')) {
          // –°—Ç–≤–æ—Ä—é—î–º–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –ø—Ä–æ –ø–æ–º–∏–ª–∫—É, –∞–ª–µ –Ω–µ –±–ª–æ–∫—É—î–º–æ —ñ–Ω—Ç–µ—Ä—Ñ–µ–π—Å
          const errorMsg = document.createElement('div');
          errorMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #ef4444; color: white; padding: 12px 20px; border-radius: 8px; z-index: 10000; box-shadow: 0 4px 6px rgba(0,0,0,0.1); max-width: 400px;';
          errorMsg.innerHTML = `
            <div style="font-weight: 600; margin-bottom: 5px;">‚ö†Ô∏è Multimodal Processing Failed</div>
            <div style="font-size: 13px;">${error.message}</div>
          `;
          document.body.appendChild(errorMsg);
          setTimeout(() => errorMsg.remove(), 5000);
        }
      } finally {
        // –°–∫–∏–¥–∞—î–º–æ –ø—Ä–∞–ø–æ—Ä–µ—Ü—å –ø—ñ—Å–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è
        window.multimodalProcessingInProgress = false;
      }
    }
    
    // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥—É —Ä–æ–∑–º—ñ—Ç–∫–∏ –∑ debug —Ç–µ–∫—Å—Ç—É
    function parseDebugMarkup(debugText) {
      const blue = [];
      const green = [];
      const red = [];
      
      console.log('üîç [parseDebugMarkup] Starting parse, text length:', debugText.length);
      
      // –†–æ–∑–±–∏–≤–∞—î–º–æ —Ç–µ–∫—Å—Ç –Ω–∞ –±–ª–æ–∫–∏ —Ä–µ–ø–ª—ñ–∫ (—Ä–æ–∑–¥—ñ–ª–µ–Ω—ñ –ø–æ–¥–≤—ñ–π–Ω–∏–º–∏ –ø–µ—Ä–µ–Ω–æ—Å–∞–º–∏ —Ä—è–¥–∫—ñ–≤)
      const replicaBlocks = debugText.split(/\n\n+/).filter(block => block.trim().length > 0);
      console.log('üîç [parseDebugMarkup] Found replica blocks:', replicaBlocks.length);
      
      for (const block of replicaBlocks) {
        const lines = block.split('\n').map(l => l.trim()).filter(l => l.length > 0);
        if (lines.length === 0) continue;
        
        // –ü–µ—Ä—à–∏–π —Ä—è–¥–æ–∫ - "–†–µ–ø–ª—ñ–∫–∞ - [—Ç–µ–∫—Å—Ç] (Role)"
        const replicaMatch = lines[0].match(/^–†–µ–ø–ª—ñ–∫–∞\s*-\s*(.+?)(?:\s*\(([^)]+)\))?$/);
        if (!replicaMatch) continue;
        
        const phraseText = replicaMatch[1].trim();
        const role = replicaMatch[2] || null;
        
        // –î—Ä—É–≥–∏–π —Ä—è–¥–æ–∫ - "yes" –∞–±–æ "no"
        let found = false;
        let classification = null;
        let roleMatch = null;
        let matchingSegments = [];
        let nonMatchingSegments = [];
        
        for (let i = 1; i < lines.length; i++) {
          const line = lines[i];
          
          if (line === 'yes') {
            found = true;
          } else if (line === 'no') {
            found = false;
          } else if (line === 'blue') {
            classification = 'blue';
          } else if (line === 'green') {
            classification = 'green';
          } else if (line === 'Red' || line === 'red') {
            classification = 'red';
          } else if (line.startsWith('Role match')) {
            roleMatch = true;
          } else if (line.startsWith('Role mismatch')) {
            roleMatch = false;
          } else if (line === '–°–ø—ñ–≤–ø–∞–¥–∞—é—Ç—å:') {
            // –ù–∞—Å—Ç—É–ø–Ω—ñ —Ä—è–¥–∫–∏ –¥–æ "–ù–µ —Å–ø—ñ–≤–ø–∞–¥–∞—é—Ç—å:" –∞–±–æ –∫—ñ–Ω—Ü—è - —Ü–µ —Å–ø—ñ–≤–ø–∞–¥–∞—é—á—ñ —Å–µ–≥–º–µ–Ω—Ç–∏
            i++;
            while (i < lines.length && lines[i] !== '–ù–µ —Å–ø—ñ–≤–ø–∞–¥–∞—é—Ç—å:' && !lines[i].startsWith('–ù–µ –∑–Ω–∞–π–¥–µ–Ω–æ')) {
              if (lines[i].trim() && !lines[i].startsWith('Role') && lines[i] !== 'green' && lines[i] !== 'Red' && lines[i] !== 'red') {
                matchingSegments.push(lines[i].trim());
              }
              i++;
            }
            i--; // –ü–æ–≤–µ—Ä—Ç–∞—î–º–æ—Å—è –Ω–∞–∑–∞–¥, –±–æ —Ü–∏–∫–ª –∑–±—ñ–ª—å—à–∏—Ç—å i
          } else if (line === '–ù–µ —Å–ø—ñ–≤–ø–∞–¥–∞—é—Ç—å:') {
            i++;
            let currentSegment = null;
            while (i < lines.length) {
              const segmentLine = lines[i];
              
              if (segmentLine.startsWith('–°–ø—ñ–≤–ø–∞–¥–∞—é—Ç—å:') || segmentLine.startsWith('–†–µ–ø–ª—ñ–∫–∞ -') || segmentLine.startsWith('Result is') || segmentLine.startsWith('Result')) {
                if (currentSegment) {
                  nonMatchingSegments.push(currentSegment);
                  currentSegment = null;
                }
                i--; // –ø–µ—Ä–µ—Ö–æ–¥–∏–º–æ –Ω–∞–∑–∞–¥, —â–æ–± –æ–±—Ä–æ–±–∏—Ç–∏ —Ü–µ–π —Ä—è–¥–æ–∫ —É –∑–æ–≤–Ω—ñ—à–Ω—å–æ–º—É —Ü–∏–∫–ª—ñ
                break;
              }
              
              if (segmentLine.startsWith('–ù–µ –∑–Ω–∞–π–¥–µ–Ω–æ')) {
                if (currentSegment) {
                  nonMatchingSegments.push(currentSegment);
                  currentSegment = null;
                }
                i--;
                break;
              }
              
              if (segmentLine.startsWith('Speaker1 JSON') || segmentLine.startsWith('Speaker2 JSON')) {
                // –î–ª—è –∫–ª–∞—Å–∏—Ñ—ñ–∫–∞—Ü—ñ—ó –∫–æ–ª—å–æ—Ä—ñ–≤ –Ω–∞—Ä–∞–∑—ñ –∑–±–µ—Ä—ñ–≥–∞—Ç–∏ –Ω–µ –æ–±–æ–≤'—è–∑–∫–æ–≤–æ
                i++;
                continue;
              }
              
              if (segmentLine.startsWith('Color:')) {
                if (currentSegment) {
                  currentSegment.color = segmentLine.split(':')[1].trim().toLowerCase();
                }
                i++;
                continue;
              }
              
              if (segmentLine.trim().length > 0) {
                if (currentSegment) {
                  nonMatchingSegments.push(currentSegment);
                }
                currentSegment = {
                  text: segmentLine.trim(),
                  color: null
                };
              }
              
              i++;
            }
            
            if (currentSegment) {
              nonMatchingSegments.push(currentSegment);
            }
            
            i--; // –∫–æ–º–ø–µ–Ω—Å—É—î–º–æ –∑–±—ñ–ª—å—à–µ–Ω–Ω—è –≤ –æ—Å–Ω–æ–≤–Ω–æ–º—É —Ü–∏–∫–ª—ñ
          } else if (line.startsWith('–ù–µ –∑–Ω–∞–π–¥–µ–Ω–æ –≤ –∂–æ–¥–Ω–æ–º—É –¥–∂–µ—Ä–µ–ª—ñ')) {
            // –ü–æ–∑–Ω–∞—á–∞—î–º–æ, —â–æ —Ä–µ–ø–ª—ñ–∫–∞ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∞
            found = false;
          }
        }
        
        // –ö–ª–∞—Å–∏—Ñ—ñ–∫—É—î–º–æ —Ä–µ–ø–ª—ñ–∫—É –Ω–∞ –æ—Å–Ω–æ–≤—ñ –∑–Ω–∞–π–¥–µ–Ω–æ—ó —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—ó
        // –ü—Ä—ñ–æ—Ä–∏—Ç–µ—Ç: —è–≤–Ω–∞ –∫–ª–∞—Å–∏—Ñ—ñ–∫–∞—Ü—ñ—è > —Å–µ–≥–º–µ–Ω—Ç–∏ > –∑–∞–≥–∞–ª—å–Ω–∞ —Ä–µ–ø–ª—ñ–∫–∞
        
        if (classification === 'blue' && found) {
          // Blue - –∑–Ω–∞–π–¥–µ–Ω–∞ –≤ general —ñ —î –≤ Blue
          blue.push({
            text: phraseText,
            speaker: role || null
          });
        } else if (classification === 'green' && !found) {
          // Green - —î –≤ —Ç—Ä–µ–∫–∞—Ö, –∞–ª–µ –Ω–µ –≤ general
          green.push({
            text: phraseText,
            speaker: role || null
          });
        } else if (classification === 'red') {
          // Red - —è–≤–Ω–æ –ø–æ–∑–Ω–∞—á–µ–Ω–æ —è–∫ Red
          if (nonMatchingSegments.length > 0) {
            // –î–æ–¥–∞—î–º–æ –Ω–µ—Å–ø—ñ–≤–ø–∞–¥–∞—é—á—ñ —Å–µ–≥–º–µ–Ω—Ç–∏
            nonMatchingSegments.forEach(seg => {
              const segmentText = typeof seg === 'string' ? seg : seg.text;
              if (segmentText && segmentText.trim().length > 0) {
                red.push({
                  text: segmentText.trim(),
                  speaker: role || null
                });
              }
            });
          } else {
            // –í—Å—è —Ä–µ–ø–ª—ñ–∫–∞ - Red
            red.push({
              text: phraseText,
              speaker: role || null
            });
          }
        } else {
          // –Ø–∫—â–æ —î —Å–µ–≥–º–µ–Ω—Ç–∏, –¥–æ–¥–∞—î–º–æ —Å–ø—ñ–≤–ø–∞–¥–∞—é—á—ñ –¥–æ Blue, –Ω–µ—Å–ø—ñ–≤–ø–∞–¥–∞—é—á—ñ –¥–æ –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–æ–≥–æ –∫–æ–ª—å–æ—Ä—É
          if (matchingSegments.length > 0) {
            matchingSegments.forEach(seg => {
              if (seg.trim().length > 0) {
                blue.push({
                  text: seg.trim(),
                  speaker: role || null
                });
              }
            });
          }
          
          if (nonMatchingSegments.length > 0) {
            nonMatchingSegments.forEach(seg => {
              const segmentText = typeof seg === 'string' ? seg : seg.text;
              const segmentColor = (seg && typeof seg === 'object' && seg.color) ? seg.color.toLowerCase() : 'red';
              const targetArray = segmentColor === 'green' ? green : red;
              
              if (segmentText && segmentText.trim().length > 0) {
                targetArray.push({
                  text: segmentText.trim(),
                  speaker: role || null
                });
              }
            });
          } else if (!found && !classification) {
            // –Ø–∫—â–æ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∞ —ñ –Ω–µ–º–∞—î –∫–ª–∞—Å–∏—Ñ—ñ–∫–∞—Ü—ñ—ó —Ç–∞ —Å–µ–≥–º–µ–Ω—Ç—ñ–≤ - Red (–≥–∞–ª—é—Ü–∏–Ω–∞—Ü—ñ—ó)
            red.push({
              text: phraseText,
              speaker: role || null
            });
          }
        }
      }
      
      console.log('üîç [parseDebugMarkup] Parse result:', {
        blueCount: blue.length,
        greenCount: green.length,
        redCount: red.length,
        blueSamples: blue.slice(0, 3).map(item => item.text?.substring(0, 50)),
        greenSamples: green.slice(0, 3).map(item => item.text?.substring(0, 50)),
        redSamples: red.slice(0, 3).map(item => item.text?.substring(0, 50))
      });
      
      return {
        Blue: blue,
        Green: green,
        Red: red
      };
    }
    
    // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è —Ç–∞–±–ª–∏—Ü—ñ –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è —É —Ñ–æ—Ä–º–∞—Ç—ñ JSON
    function copyComparisonTableToJSON() {
      try {
        const comparisonContainer = document.getElementById('comparisonTableContainer');
        if (!comparisonContainer) {
          alert('‚ö†Ô∏è –¢–∞–±–ª–∏—Ü—è –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∞.');
          return;
        }
        
        const table = comparisonContainer.querySelector('table.comparison-table') || 
                      comparisonContainer.querySelector('table');
        
        if (!table) {
          alert('‚ö†Ô∏è –¢–∞–±–ª–∏—Ü—è –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∞ –≤ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—ñ –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è.');
          return;
        }
        
        // –ó–Ω–∞—Ö–æ–¥–∏–º–æ –≤—Å—ñ —Ä—è–¥–∫–∏ —Ç–∞–±–ª–∏—Ü—ñ
        const tbody = table.querySelector('tbody');
        const allRows = tbody ? tbody.querySelectorAll('tr') : table.querySelectorAll('tr');
        
        // –í–∏–∑–Ω–∞—á–∞—î–º–æ, —á–∏ –ø–µ—Ä—à–∏–π —Ä—è–¥–æ–∫ - —Ü–µ –∑–∞–≥–æ–ª–æ–≤–æ–∫
        let dataRowStartIndex = 0;
        if (allRows.length > 0) {
          const firstRow = allRows[0];
          if (firstRow.querySelector('th')) {
            dataRowStartIndex = 1; // –ü—Ä–æ–ø—É—Å–∫–∞—î–º–æ –∑–∞–≥–æ–ª–æ–≤–æ–∫
          }
        }
        
        const tableData = [];
        
        // –ü—Ä–æ—Ö–æ–¥–∏–º–æ –ø–æ —Ä—è–¥–∫–∞—Ö –¥–∞–Ω–∏—Ö —Ç–∞–±–ª–∏—Ü—ñ
        for (let i = dataRowStartIndex; i < allRows.length; i++) {
          const row = allRows[i];
          const cells = row.querySelectorAll('td');
          
          // –ü–æ—Ä—è–¥–æ–∫ –∫–æ–ª–æ–Ω–æ–∫: Segment ID (0) | Role Original (1) | Text Original (2) | Speaker (Standard) (3) | Text (Standard) (4) | Speaker (NextLevel) (5) | Text (NextLevel) (6) | Start Time (7) | End Time (8)
          if (cells.length >= 9) {
            const rowData = {
              segmentId: cells[0].textContent.trim(),
              roleOriginal: cells[1].textContent.trim() !== '‚Äî' ? cells[1].textContent.trim() : null,
              textOriginal: cells[2].textContent.trim() !== '‚Äî' ? cells[2].textContent.trim() : null,
              speakerStandard: cells[3].textContent.trim() !== '‚Äî' ? cells[3].textContent.trim() : null,
              textStandard: cells[4].textContent.trim() !== '‚Äî' ? cells[4].textContent.trim() : null,
              speakerNextLevel: cells[5].textContent.trim() !== '‚Äî' ? cells[5].textContent.trim() : null,
              textNextLevel: cells[6].textContent.trim() !== '‚Äî' ? cells[6].textContent.trim() : null,
              startTime: cells[7].textContent.trim() !== '‚Äî' ? cells[7].textContent.trim() : null,
              endTime: cells[8].textContent.trim() !== '‚Äî' ? cells[8].textContent.trim() : null
            };
            
            tableData.push(rowData);
          }
        }
        
        if (tableData.length === 0) {
          alert('‚ö†Ô∏è –¢–∞–±–ª–∏—Ü—è –ø–æ—Ä–æ–∂–Ω—è –∞–±–æ –Ω–µ –º—ñ—Å—Ç–∏—Ç—å –¥–∞–Ω–∏—Ö.');
          return;
        }
        
        // –ö–æ–Ω–≤–µ—Ä—Ç—É—î–º–æ –≤ JSON
        const jsonString = JSON.stringify(tableData, null, 2);
        
        // –ö–æ–ø—ñ—é—î–º–æ –≤ –±—É—Ñ–µ—Ä –æ–±–º—ñ–Ω—É
        copyToClipboard(jsonString, null, null);
        
        // –ü–æ–∫–∞–∑—É—î–º–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –ø—Ä–æ —É—Å–ø—ñ—Ö
        const successMsg = document.createElement('div');
        successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #3498db; color: white; padding: 12px 20px; border-radius: 8px; z-index: 10000; box-shadow: 0 4px 6px rgba(0,0,0,0.1);';
        successMsg.innerHTML = `‚úÖ –°–∫–æ–ø—ñ–π–æ–≤–∞–Ω–æ ${tableData.length} —Ä—è–¥–∫—ñ–≤ —É —Ñ–æ—Ä–º–∞—Ç—ñ JSON`;
        document.body.appendChild(successMsg);
        setTimeout(() => successMsg.remove(), 3000);
        
        console.log('‚úÖ [copyComparisonTableToJSON] Copied table to JSON:', tableData.length, 'rows');
        
      } catch (error) {
        console.error('‚ùå [copyComparisonTableToJSON] Error:', error);
        alert(`‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—ñ: ${error.message}`);
      }
    }
    
    // –î–æ–ø–æ–º—ñ–∂–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—è –¥–ª—è –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è –≤ –±—É—Ñ–µ—Ä –æ–±–º—ñ–Ω—É
    function copyToClipboard(text, button, originalColor) {
      // –°–ø—Ä–æ–±—É—î–º–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞—Ç–∏ —Å—É—á–∞—Å–Ω–∏–π API
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(text).then(() => {
          if (button && originalColor) {
            const originalText = button.innerHTML;
            button.innerHTML = '‚úÖ Copied!';
            button.style.background = '#27ae60';
            setTimeout(() => {
              button.innerHTML = originalText;
              button.style.background = originalColor;
            }, 2000);
          }
        }).catch(err => {
          console.error('Failed to copy using clipboard API:', err);
          // Fallback –¥–æ —Å—Ç–∞—Ä–æ–≥–æ –º–µ—Ç–æ–¥—É
          fallbackCopyToClipboard(text, button, originalColor);
        });
      } else {
        // Fallback –¥–æ —Å—Ç–∞—Ä–æ–≥–æ –º–µ—Ç–æ–¥—É
        fallbackCopyToClipboard(text, button, originalColor);
      }
    }
    
    function fallbackCopyToClipboard(text, button, originalColor) {
      // –°—Ç–≤–æ—Ä—é—î–º–æ —Ç–∏–º—á–∞—Å–æ–≤–∏–π textarea –¥–ª—è –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è
      const tempTextarea = document.createElement('textarea');
      tempTextarea.value = text;
      tempTextarea.style.position = 'fixed';
      tempTextarea.style.opacity = '0';
      document.body.appendChild(tempTextarea);
      tempTextarea.select();
      document.execCommand('copy');
      document.body.removeChild(tempTextarea);
      
      // –ü–æ–∫–∞–∑—É—î–º–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –ø—Ä–æ —É—Å–ø—ñ—à–Ω–µ –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è
      const originalText = button.innerHTML;
      button.innerHTML = '‚úÖ Copied!';
      button.style.background = '#27ae60';
      setTimeout(() => {
        button.innerHTML = originalText;
        button.style.background = originalColor;
      }, 2000);
    }
    
    // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –∑–±–æ—Ä—É –≤—Å—ñ—Ö debug –¥–∞–Ω–∏—Ö
    function collectDebugData() {
      if (!currentAnalysisData) {
        return 'No data available';
      }
      
      let output = '';
      
      // –î—ñ–∞–≥–Ω–æ—Å—Ç–∏—á–Ω–∞ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è –ø—Ä–æ —Å—Ç—Ä—É–∫—Ç—É—Ä—É –¥–∞–Ω–∏—Ö
      output += '=== DEBUG: Data Structure Info ===\n\n';
      output += `Keys in currentAnalysisData: ${Object.keys(currentAnalysisData).join(', ')}\n`;
      output += `Has primaryDiarization: ${!!currentAnalysisData.primaryDiarization}\n`;
      output += `Has general: ${!!currentAnalysisData.general}\n`;
      output += `Has voiceTracks: ${!!currentAnalysisData.voiceTracks}\n`;
      output += `Has markdownTable: ${!!currentAnalysisData.markdownTable}\n`;
      output += `Has correctedDiarization: ${!!currentAnalysisData.correctedDiarization}\n`;
      output += `Has textAnalysis: ${!!currentAnalysisData.textAnalysis}\n`;
      if (currentAnalysisData.textAnalysis) {
        output += `textAnalysis keys: ${Object.keys(currentAnalysisData.textAnalysis).join(', ')}\n`;
        output += `Blue count: ${currentAnalysisData.textAnalysis.Blue?.length || 0}\n`;
        output += `Green count: ${currentAnalysisData.textAnalysis.Green?.length || 0}\n`;
        output += `Red count: ${currentAnalysisData.textAnalysis.Red?.length || 0}\n`;
      }
      output += '\n\n';
      
      // 1. –ü–µ—Ä—à–∏–π JSON (general/primaryDiarization)
      output += '=== 1. PRIMARY DIARIZATION (General JSON) ===\n\n';
      let primaryDiarization = currentAnalysisData.primaryDiarization || currentAnalysisData.general;
      
      // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –≤–∫–ª–∞–¥–µ–Ω—ñ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏
      if (!primaryDiarization && currentAnalysisData.primaryDiarization) {
        const primary = currentAnalysisData.primaryDiarization;
        if (primary.recordings && Array.isArray(primary.recordings) && primary.recordings[0]) {
          primaryDiarization = primary.recordings[0];
        } else {
          primaryDiarization = primary;
        }
      }
      
      if (primaryDiarization) {
        output += JSON.stringify(primaryDiarization, null, 2);
      } else {
        output += 'No primary diarization data found\n';
        output += 'Available keys: ' + Object.keys(currentAnalysisData).join(', ') + '\n';
      }
      output += '\n\n';
      
      // 2. JSON –∞—É–¥—ñ–æ —Ç—Ä–µ–∫—ñ–≤ (speaker1, speaker2)
      output += '=== 2. VOICE TRACK 1 (Speaker1 JSON) ===\n\n';
      const voiceTracks = currentAnalysisData.voiceTracks || [];
      
      if (voiceTracks.length > 0) {
        const speaker1Track = voiceTracks.find(t => 
          t.speaker === 'SPEAKER_00' || 
          t.role === 'operator' || 
          t.role === 'agent' ||
          (t.roleAnalysis && (t.roleAnalysis.role === 'operator' || t.roleAnalysis.role === 'agent'))
        ) || voiceTracks[0];
        
        if (speaker1Track) {
          // –í–∏—Ç—è–≥—É—î–º–æ transcription —è–∫—â–æ —î, –∞–±–æ –ø–æ–≤–Ω–∏–π –æ–±'—î–∫—Ç
          let trackData = speaker1Track;
          
          // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —Ä—ñ–∑–Ω—ñ –º–æ–∂–ª–∏–≤—ñ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏
          if (speaker1Track.transcription) {
            trackData = speaker1Track.transcription;
          } else if (speaker1Track.recordings && Array.isArray(speaker1Track.recordings) && speaker1Track.recordings[0]) {
            trackData = speaker1Track.recordings[0];
          } else if (speaker1Track.speechmatics) {
            trackData = speaker1Track.speechmatics;
          }
          
          output += JSON.stringify(trackData, null, 2);
        } else {
          output += 'No speaker1 track found\n';
          output += `Available tracks: ${voiceTracks.length}\n`;
          if (voiceTracks.length > 0) {
            output += `First track keys: ${Object.keys(voiceTracks[0]).join(', ')}\n`;
          }
        }
      } else {
        output += 'No voice tracks found\n';
      }
      output += '\n\n';
      
      output += '=== 3. VOICE TRACK 2 (Speaker2 JSON) ===\n\n';
      if (voiceTracks.length > 1) {
        const speaker2Track = voiceTracks.find(t => 
          t.speaker === 'SPEAKER_01' || 
          t.role === 'client' || 
          t.role === 'customer' ||
          (t.roleAnalysis && (t.roleAnalysis.role === 'client' || t.roleAnalysis.role === 'customer'))
        ) || voiceTracks[1];
        
        if (speaker2Track) {
          // –í–∏—Ç—è–≥—É—î–º–æ transcription —è–∫—â–æ —î, –∞–±–æ –ø–æ–≤–Ω–∏–π –æ–±'—î–∫—Ç
          let trackData = speaker2Track;
          
          // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —Ä—ñ–∑–Ω—ñ –º–æ–∂–ª–∏–≤—ñ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏
          if (speaker2Track.transcription) {
            trackData = speaker2Track.transcription;
          } else if (speaker2Track.recordings && Array.isArray(speaker2Track.recordings) && speaker2Track.recordings[0]) {
            trackData = speaker2Track.recordings[0];
          } else if (speaker2Track.speechmatics) {
            trackData = speaker2Track.speechmatics;
          }
          
          output += JSON.stringify(trackData, null, 2);
        } else {
          output += 'No speaker2 track found\n';
        }
      } else {
        output += 'No second voice track found\n';
      }
      output += '\n\n';
      
      // 3. –ú–∞—Ä–∫–¥–∞—É–Ω —Ç–∞–±–ª–∏—Ü—è
      output += '=== 4. MARKDOWN TABLE ===\n\n';
      let markdownTable = currentAnalysisData.markdownTable;
      
      // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —Ä—ñ–∑–Ω—ñ –º–æ–∂–ª–∏–≤—ñ –º—ñ—Å—Ü—è
      if (!markdownTable && currentAnalysisData.correctedDiarization) {
        const corrected = currentAnalysisData.correctedDiarization;
        
        // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –≤ recordings[0].results['overlap-corrected'].rawData.markdownTable
        if (corrected.recordings && Array.isArray(corrected.recordings) && corrected.recordings[0]) {
          const recording = corrected.recordings[0];
          if (recording.results && recording.results['overlap-corrected']) {
            const rawData = recording.results['overlap-corrected'].rawData;
            if (rawData && rawData.markdownTable) {
              markdownTable = rawData.markdownTable;
            }
          }
        }
        
        // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –≤ rawData.markdownTable
        if (!markdownTable && corrected.rawData && corrected.rawData.markdownTable) {
          markdownTable = corrected.rawData.markdownTable;
        }
      }
      
      if (markdownTable) {
        output += markdownTable;
      } else {
        output += 'No markdown table found\n';
      }
      output += '\n\n';
      
      // 4-6. –°–∏–Ω—ñ, –∑–µ–ª–µ–Ω—ñ, —á–µ—Ä–≤–æ–Ω—ñ —Ñ—Ä–∞–∑–∏
      // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –≤—Å—ñ –º–æ–∂–ª–∏–≤—ñ –º—ñ—Å—Ü—è, –¥–µ –º–æ–∂–µ –±—É—Ç–∏ textAnalysis
      let textAnalysis = currentAnalysisData.textAnalysis;
      
      // –Ø–∫—â–æ –Ω–µ–º–∞—î –Ω–∞ –≤–µ—Ä—Ö–Ω—å–æ–º—É —Ä—ñ–≤–Ω—ñ, –ø–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –≤ correctedDiarization
      if (!textAnalysis && currentAnalysisData.correctedDiarization) {
        const corrected = currentAnalysisData.correctedDiarization;
        if (corrected.textAnalysis) {
          textAnalysis = corrected.textAnalysis;
        }
        // –¢–∞–∫–æ–∂ –ø–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –≤ rawData
        if (!textAnalysis && corrected.rawData && corrected.rawData.textAnalysis) {
          textAnalysis = corrected.rawData.textAnalysis;
        }
        // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –≤ recordings[0].results
        if (!textAnalysis && corrected.recordings && Array.isArray(corrected.recordings) && corrected.recordings[0]) {
          const recording = corrected.recordings[0];
          if (recording.results && recording.results['overlap-corrected']) {
            const result = recording.results['overlap-corrected'];
            if (result.textAnalysis) {
              textAnalysis = result.textAnalysis;
            }
            if (!textAnalysis && result.rawData && result.rawData.textAnalysis) {
              textAnalysis = result.rawData.textAnalysis;
            }
          }
        }
      }
      
      // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –≤ primaryDiarization
      if (!textAnalysis && currentAnalysisData.primaryDiarization) {
        const primary = currentAnalysisData.primaryDiarization;
        if (primary.textAnalysis) {
          textAnalysis = primary.textAnalysis;
        }
        if (!textAnalysis && primary.recordings && Array.isArray(primary.recordings) && primary.recordings[0]) {
          const recording = primary.recordings[0];
          if (recording.results && recording.results.speechmatics && recording.results.speechmatics.textAnalysis) {
            textAnalysis = recording.results.speechmatics.textAnalysis;
          }
        }
      }
      
      // –Ø–∫—â–æ –≤—Å–µ —â–µ –Ω–µ–º–∞—î, —Å–ø—Ä–æ–±—É—î–º–æ –≤–∏—Ç—è–≥—Ç–∏ –∑ –≥–ª–æ–±–∞–ª—å–Ω–æ—ó –∑–º—ñ–Ω–Ω–æ—ó –∞–±–æ –∑ DOM
      if (!textAnalysis) {
        // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ —î textAnalysis –≤ –≥–ª–æ–±–∞–ª—å–Ω–æ–º—É –æ–±'—î–∫—Ç—ñ (—è–∫—â–æ –≤—ñ–Ω –±—É–≤ –∑–±–µ—Ä–µ–∂–µ–Ω–∏–π)
        if (window.lastTextAnalysis) {
          textAnalysis = window.lastTextAnalysis;
        } else {
          textAnalysis = {};
        }
      }
      
      output += '=== 5. BLUE PHRASES (Normal Diarization) ===\n\n';
      if (textAnalysis.Blue && Array.isArray(textAnalysis.Blue) && textAnalysis.Blue.length > 0) {
        output += JSON.stringify(textAnalysis.Blue, null, 2);
        output += `\n\nTotal: ${textAnalysis.Blue.length} phrases\n`;
      } else {
        output += 'No blue phrases found\n';
        if (textAnalysis.Blue) {
          output += `Blue type: ${typeof textAnalysis.Blue}, isArray: ${Array.isArray(textAnalysis.Blue)}\n`;
        }
      }
      output += '\n\n';
      
      output += '=== 6. GREEN PHRASES (Overlap Recognition) ===\n\n';
      if (textAnalysis.Green && Array.isArray(textAnalysis.Green) && textAnalysis.Green.length > 0) {
        output += JSON.stringify(textAnalysis.Green, null, 2);
        output += `\n\nTotal: ${textAnalysis.Green.length} phrases\n`;
      } else {
        output += 'No green phrases found\n';
        if (textAnalysis.Green) {
          output += `Green type: ${typeof textAnalysis.Green}, isArray: ${Array.isArray(textAnalysis.Green)}\n`;
        }
      }
      output += '\n\n';
      
      output += '=== 7. RED PHRASES (Hallucinations/Missing) ===\n\n';
      if (textAnalysis.Red && Array.isArray(textAnalysis.Red) && textAnalysis.Red.length > 0) {
        output += JSON.stringify(textAnalysis.Red, null, 2);
        output += `\n\nTotal: ${textAnalysis.Red.length} phrases\n`;
      } else {
        output += 'No red phrases found\n';
        if (textAnalysis.Red) {
          output += `Red type: ${typeof textAnalysis.Red}, isArray: ${Array.isArray(textAnalysis.Red)}\n`;
        }
      }
      
      return output;
    }
    
    // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –∑–∞–ø—É—Å–∫—É –∞–Ω–∞–ª—ñ–∑—É —Ç–µ–∫—Å—Ç—É (LLM –∞–±–æ script —Ä–µ–∂–∏–º)
    async function runTextAnalysis() {
      if (!currentAnalysisData) {
        alert('‚ö†Ô∏è No data available for analysis. Please process audio first.');
        return;
      }
      
      const analyseBtn = document.getElementById('analyseBtn');
      const originalText = analyseBtn.innerHTML;
      
      try {
        // –ë–ª–æ–∫—É—î–º–æ –∫–Ω–æ–ø–∫—É
        analyseBtn.disabled = true;
        analyseBtn.innerHTML = '‚è≥ Analysing...';
        analyseBtn.style.opacity = '0.6';
        analyseBtn.style.cursor = 'not-allowed';
        
        // –û—Ç—Ä–∏–º—É—î–º–æ –¥–∞–Ω—ñ –¥–ª—è –∞–Ω–∞–ª—ñ–∑—É
        const { originalSegments, correctedSegments } = extractSegments(currentAnalysisData);
        let markdownTable = null;
        
        // –û—Ç—Ä–∏–º—É—î–º–æ markdown —Ç–∞–±–ª–∏—Ü—é
        if (currentAnalysisData.markdownTable) {
          markdownTable = currentAnalysisData.markdownTable;
        } else if (currentAnalysisData.correctedDiarization) {
          const corrected = currentAnalysisData.correctedDiarization;
          if (corrected.recordings && Array.isArray(corrected.recordings) && corrected.recordings[0]) {
            const recording = corrected.recordings[0];
            if (recording.results && recording.results['overlap-corrected']) {
              const rawData = recording.results['overlap-corrected'].rawData;
              if (rawData && rawData.markdownTable) {
                markdownTable = rawData.markdownTable;
              }
            }
          } else if (corrected.rawData && corrected.rawData.markdownTable) {
            markdownTable = corrected.rawData.markdownTable;
          }
        }
        
        if (!markdownTable) {
          alert('‚ö†Ô∏è Markdown table is not available. Cannot perform analysis.');
          analyseBtn.disabled = false;
          analyseBtn.innerHTML = originalText;
          analyseBtn.style.opacity = '1';
          analyseBtn.style.cursor = 'pointer';
          return;
        }
        
        // –û—Ç—Ä–∏–º—É—î–º–æ —Å–µ–≥–º–µ–Ω—Ç–∏ –∑ primary diarization
        let primarySegments = [];
        if (currentAnalysisData.primaryDiarization) {
          const primary = currentAnalysisData.primaryDiarization;
          if (primary.recordings && Array.isArray(primary.recordings) && primary.recordings[0]) {
            const recording = primary.recordings[0];
            if (recording.results && recording.results.speechmatics) {
              primarySegments = recording.results.speechmatics.segments || [];
            }
          }
        }
        
        // –û—Ç—Ä–∏–º—É—î–º–æ —Å–µ–≥–º–µ–Ω—Ç–∏ –∑ voice tracks
        let speaker1Segments = [];
        let speaker2Segments = [];
        if (currentAnalysisData.voiceTracks && Array.isArray(currentAnalysisData.voiceTracks)) {
          currentAnalysisData.voiceTracks.forEach(track => {
            if (track.transcription && track.transcription.recordings && track.transcription.recordings[0]) {
              const recording = track.transcription.recordings[0];
              if (recording.results && recording.results.speechmatics) {
                const segments = recording.results.speechmatics.segments || [];
                if (track.speaker === 'SPEAKER_00' || track.roleAnalysis?.role === 'operator') {
                  speaker1Segments = segments;
                } else {
                  speaker2Segments = segments;
                }
              }
            }
          });
        }
        
        // –í–∏–∑–Ω–∞—á–∞—î–º–æ —Ä–µ–∂–∏–º LLM –∑ demoConfig
        const llmMode = demoConfig.llmMode || 'smart';
        const isLocal = demoConfig.isLocal || false;
        
        // –§–æ—Ä–º—É—î–º–æ payload –¥–ª—è –∞–Ω–∞–ª—ñ–∑—É
        const analysisPayload = {
          general: {
            segments: primarySegments,
            speechmatics: {
              segments: primarySegments
            }
          },
          speaker1: {
            segments: speaker1Segments,
            speechmatics: {
              segments: speaker1Segments
            },
            speaker: currentAnalysisData.voiceTracks?.[0]?.speaker || 'SPEAKER_00',
            role: currentAnalysisData.voiceTracks?.[0]?.roleAnalysis?.role || null
          },
          speaker2: {
            segments: speaker2Segments,
            speechmatics: {
              segments: speaker2Segments
            },
            speaker: currentAnalysisData.voiceTracks?.[1]?.speaker || 'SPEAKER_01',
            role: currentAnalysisData.voiceTracks?.[1]?.roleAnalysis?.role || null
          },
          markdown: markdownTable,
          mode: llmMode, // –ü–µ—Ä–µ–¥–∞—î–º–æ —Ä–µ–∂–∏–º –¥–ª—è –≤–∏–∑–Ω–∞—á–µ–Ω–Ω—è –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ/–≤—ñ–¥–¥–∞–ª–µ–Ω–æ–≥–æ LLM
          isLocal: isLocal
        };
        
        console.log('üîç [runTextAnalysis] Sending analysis request:', {
          hasMarkdown: !!markdownTable,
          markdownLength: markdownTable?.length || 0,
          primarySegmentsCount: primarySegments.length,
          speaker1SegmentsCount: speaker1Segments.length,
          speaker2SegmentsCount: speaker2Segments.length,
          payloadKeys: Object.keys(analysisPayload)
        });
        
        console.log('üì§ [runTextAnalysis] Calling /api/analyze-text...');
        
        // –í–∏–∫–ª–∏–∫–∞—î–º–æ API –¥–ª—è –∞–Ω–∞–ª—ñ–∑—É
        const response = await fetch('/api/analyze-text', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(analysisPayload)
        });
        
        console.log('üì• [runTextAnalysis] Response received:', {
          status: response.status,
          statusText: response.statusText,
          ok: response.ok
        });
        
        if (!response.ok) {
          const errorText = await response.text();
          console.error('‚ùå [runTextAnalysis] Response error:', errorText);
          let errorMessage = `Analysis failed: ${response.status} ${response.statusText}`;
          try {
            const errorJson = JSON.parse(errorText);
            if (errorJson.details) {
              errorMessage += `. ${errorJson.details}`;
            } else if (errorJson.error) {
              errorMessage += `. ${errorJson.error}`;
            }
          } catch (e) {
            errorMessage += `. ${errorText.substring(0, 200)}`;
          }
          throw new Error(errorMessage);
        }
        
        const analysisResult = await response.json();
        console.log('‚úÖ [runTextAnalysis] Analysis completed:', {
          blueCount: analysisResult.Blue?.length || 0,
          greenCount: analysisResult.Green?.length || 0,
          redCount: analysisResult.Red?.length || 0,
          hasBlue: !!analysisResult.Blue,
          hasGreen: !!analysisResult.Green,
          hasRed: !!analysisResult.Red,
          hasError: !!analysisResult.error,
          resultKeys: Object.keys(analysisResult)
        });
        
        // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ —î –ø–æ–º–∏–ª–∫–∞ –≤ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ
        if (analysisResult.error) {
          throw new Error(`LLM analysis error: ${analysisResult.error}`);
        }
        
        // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ –≤—Å—ñ –º–∞—Å–∏–≤–∏ –ø–æ—Ä–æ–∂–Ω—ñ (–º–æ–∂–µ –æ–∑–Ω–∞—á–∞—Ç–∏, —â–æ LLM –Ω–µ —Å–ø—Ä–∞—Ü—é–≤–∞–≤)
        if ((!analysisResult.Blue || analysisResult.Blue.length === 0) &&
            (!analysisResult.Green || analysisResult.Green.length === 0) &&
            (!analysisResult.Red || analysisResult.Red.length === 0)) {
          console.warn('‚ö†Ô∏è [runTextAnalysis] All result arrays are empty. This might indicate LLM did not process the request correctly.');
        }
        
        // –û–Ω–æ–≤–ª—é—î–º–æ –¥–∞–Ω—ñ –∑ –Ω–æ–≤–∏–º textAnalysis
        currentAnalysisData.textAnalysis = analysisResult;
        // –¢–∞–∫–æ–∂ –∑–±–µ—Ä—ñ–≥–∞—î–º–æ –≤ –≥–ª–æ–±–∞–ª—å–Ω—É –∑–º—ñ–Ω–Ω—É –¥–ª—è debug
        window.lastTextAnalysis = analysisResult;
        
        // –ü–µ—Ä–µ–º–∞–ª—å–æ–≤—É—î–º–æ —Ç–∞–±–ª–∏—Ü—é –∑ –Ω–æ–≤–∏–º textAnalysis
        const markdownContainer = document.getElementById('markdownTableContainer');
        if (markdownContainer && markdownTable) {
          renderMarkdownTable(markdownTable, markdownContainer, originalSegments, analysisResult);
        }
        
        // –ü–æ–∫–∞–∑—É—î–º–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –ø—Ä–æ —É—Å–ø—ñ—Ö
        const successMsg = document.createElement('div');
        successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #10b981; color: white; padding: 12px 20px; border-radius: 8px; z-index: 10000; box-shadow: 0 4px 6px rgba(0,0,0,0.1);';
        successMsg.innerHTML = `‚úÖ Analysis completed! Blue: ${analysisResult.Blue?.length || 0}, Green: ${analysisResult.Green?.length || 0}, Red: ${analysisResult.Red?.length || 0}`;
        document.body.appendChild(successMsg);
        setTimeout(() => successMsg.remove(), 5000);
        
      } catch (error) {
        console.error('‚ùå [runTextAnalysis] Error:', error);
        alert(`‚ùå Analysis failed: ${error.message}`);
      } finally {
        // –†–æ–∑–±–ª–æ–∫–æ–≤—É—î–º–æ –∫–Ω–æ–ø–∫—É
        analyseBtn.disabled = false;
        analyseBtn.innerHTML = originalText;
        analyseBtn.style.opacity = '1';
        analyseBtn.style.cursor = 'pointer';
      }
    }
    
    // Show results with markdown table
    function showResults(data) {
      console.log('üîç [showResults] Called with data:', {
        dataType: typeof data,
        isNull: data === null,
        isUndefined: data === undefined,
        keys: data ? Object.keys(data) : [],
        fullData: data
      });
      
      if (!data) {
        console.error('‚ùå [showResults] Data is null or undefined!');
        const resultsEl = document.getElementById('resultsInfo');
        if (resultsEl) {
          resultsEl.innerHTML = '<div class="error-label">Error: No data received from server</div>';
        }
        return;
      }
      
      // Set currentAnalysisData for use by other modules
      currentAnalysisData = data;
      
      const resultsEl = document.getElementById('resultsInfo');
      if (!resultsEl) {
        console.error('‚ùå [showResults] resultsInfo element not found!');
        return;
      }
      
      // OLD LOGIC REMOVED: Markdown table generation is now handled by runDebugActionNew() + applyDebugMarkup()
      // The old logic that searched for markdownTable in nested structures has been replaced
      // with automatic LLM-based analysis and table generation
      
      // Extract segments for comparison table (if ground truth is available)
      const segmentsResult = extractSegments(data);
      const originalSegments = segmentsResult?.originalSegments || [];
      const correctedSegments = segmentsResult?.correctedSegments || [];
      const textAnalysis = data.textAnalysis || null;
      
      // Always show results container with markdown table container
      let html = '<div class="results-card"><h3>Results</h3>';
      
      // Add ground truth metrics display - will be calculated from comparison table
      // Check if we have ground truth data (either from backend or from table)
      const hasGroundTruthData = !!data.groundTruthMetrics || !!window.uploadedDialogueText;
      
      if (hasGroundTruthData) {
        html += `
          <div id="groundTruthMetricsContainer" class="ground-truth-metrics" style="background: #1a1a1a; border: 1px solid #333; border-radius: 8px; padding: 16px; margin-bottom: 20px;">
            <h4 style="margin: 0 0 12px 0; color: #fff; font-size: 16px;">üìä Ground Truth Match (Word-Level)</h4>
            <div id="groundTruthMetricsContent" style="color: #aaa; font-style: italic;">
              –û–±—á–∏—Å–ª–µ–Ω–Ω—è –º–µ—Ç—Ä–∏–∫ –ø—ñ—Å–ª—è –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —Ç–∞–±–ª–∏—Ü—ñ...
              </div>
            </div>
          `;
      }
      
      // Show comparison table only if ground truth is available
      const hasGroundTruth = hasGroundTruthData;
      
      if (hasGroundTruth) {
        // Show new comparison table with metrics
        html += '<div id="comparisonTableContainer" class="comparison-table-container">';
        html += '<div style="margin-bottom: 10px;">';
        html += '<button class="btn btn-primary" onclick="copyComparisonTableToJSON()" style="padding: 8px 16px; font-size: 14px; border-radius: 6px; background: #3498db; color: white; border: none; cursor: pointer; font-weight: 600;">';
        html += 'üìã Copy JSON';
        html += '</button>';
        html += '</div>';
        html += '</div>';
        html += `
          <details class="legacy-markdown-details">
            <summary>Legacy Markdown Table (debug)</summary>
            <div class="legacy-note">Legacy view of the markdown output is preserved for debugging purposes.</div>
            <div id="markdownTableContainer" class="markdown-table-container"></div>
          </details>
        `;
      } else {
        // Show only legacy table if no ground truth
        html += `
          <div id="markdownTableContainer" class="markdown-table-container"></div>
        `;
      }
      
      resultsEl.innerHTML = html;
      
      // Render comparison table only if ground truth is available
      if (hasGroundTruth) {
        const comparisonContainer = document.getElementById('comparisonTableContainer');
        if (comparisonContainer && data.markdownTable) {
          // Extract Original segments from uploaded dialogue for highlighting
          const uploadedDialogueText = window.uploadedDialogueText || data.uploadedDialogueText || null;
          
          // Extract ALL ORIGINAL segments from primaryDiarization for Standard column
          // IMPORTANT: Get directly from primaryDiarization.recordings[0].results.speechmatics.segments
          // This is the raw, unprocessed data from Speechmatics (first stage)
          let allPrimarySegments = [];
          if (data.primaryDiarization) {
            const primary = data.primaryDiarization;
            
            // Try: primaryDiarization.recordings[0].results.speechmatics.segments
            if (primary.recordings && Array.isArray(primary.recordings) && primary.recordings[0]) {
              const recording = primary.recordings[0];
              if (recording.results) {
                // First try speechmatics directly
                if (recording.results.speechmatics && recording.results.speechmatics.segments) {
                  allPrimarySegments = recording.results.speechmatics.segments;
                  console.log('‚úÖ [Comparison] Extracted Standard segments from recordings[0].results.speechmatics.segments:', allPrimarySegments.length);
                } else {
                  // Fallback: try first result key
                  const resultKey = Object.keys(recording.results)[0];
                  if (recording.results[resultKey] && recording.results[resultKey].segments) {
                    allPrimarySegments = recording.results[resultKey].segments;
                    console.log('‚úÖ [Comparison] Extracted Standard segments from recordings[0].results[' + resultKey + '].segments:', allPrimarySegments.length);
                  }
                }
              }
            } else if (primary.segments) {
              // Fallback: direct segments
              allPrimarySegments = primary.segments;
              console.log('‚úÖ [Comparison] Extracted Standard segments from primary.segments:', allPrimarySegments.length);
            }
            
            // Ensure all segments are arrays
            if (!Array.isArray(allPrimarySegments)) {
              allPrimarySegments = [];
            }
          }
          
          // Also keep filtered segments for speaker labels (but use allPrimarySegments for text)
          const standardSegments = extractStandardSegments(data);
          
          // Get NextLevel markdown table from markdownTableContainer (Legacy Markdown Table)
          // This table contains Agent/Client data from correctedDiarization
          // We'll extract it after a delay to ensure it's rendered
          let nextLevelMarkdownTable = null;
          
          // Function to extract and render comparison table
          const renderComparisonTableWithNextLevel = () => {
            // Try to get from markdownTableContainer (Legacy Markdown Table)
            const markdownContainer = document.getElementById('markdownTableContainer');
            if (markdownContainer) {
              const table = markdownContainer.querySelector('table.markdown-table');
              if (table) {
                // Extract markdown table from rendered HTML table
                const rows = table.querySelectorAll('tbody tr');
                let markdown = '| Segment ID | Speaker | Text | Start Time | End Time |\n';
                markdown += '|------------|---------|------|------------|----------|\n';
                
                rows.forEach((row, index) => {
                  const cells = row.querySelectorAll('td');
                  if (cells.length >= 5) {
                    const segmentId = cells[0].textContent.trim();
                    const speaker = cells[1].textContent.trim();
                    const text = cells[2].textContent.trim();
                    const startTime = cells[3].textContent.trim();
                    const endTime = cells[4].textContent.trim();
                    markdown += `| ${segmentId} | ${speaker} | ${text} | ${startTime} | ${endTime} |\n`;
                  }
                });
                
                nextLevelMarkdownTable = markdown;
                console.log('‚úÖ [Comparison] Extracted NextLevel markdown table from markdownTableContainer:', {
                  rowsCount: rows.length,
                  markdownLength: markdown.length
                });
              }
            }
            
            // Fallback: generate from window.currentTable if markdownTableContainer not ready
            if (!nextLevelMarkdownTable && window.currentTable && Array.isArray(window.currentTable) && window.currentTable.length > 0) {
              let markdown = '| Segment ID | Speaker | Text | Start Time | End Time |\n';
              markdown += '|------------|---------|------|------------|----------|\n';
              
              const allFragments = [];
              window.currentTable.forEach(track => {
                if (track.dialogueAnalysis && Array.isArray(track.dialogueAnalysis)) {
                  track.dialogueAnalysis.forEach(fragment => {
                    if (fragment.fragment && fragment.fragment.trim()) {
                      allFragments.push({
                        fragment: fragment.fragment.trim(),
                        start: parseFloat(fragment.start) || 0,
                        end: parseFloat(fragment.end) || parseFloat(fragment.start) || 0,
                        role: track.dialogueType || 'unknown'
                      });
                    }
                  });
                }
              });
              
              // Sort by start time
              allFragments.sort((a, b) => a.start - b.start);
              
              // Generate markdown rows
              allFragments.forEach((fragment, index) => {
                const segmentId = index + 1;
                const speaker = fragment.role === 'agent' ? 'Agent' : fragment.role === 'client' ? 'Client' : fragment.role;
                const text = fragment.fragment;
                const startTime = fragment.start.toFixed(2);
                const endTime = fragment.end.toFixed(2);
                markdown += `| ${segmentId} | ${speaker} | ${text} | ${startTime} | ${endTime} |\n`;
              });
              
              nextLevelMarkdownTable = markdown;
              console.log('‚úÖ [Comparison] Generated NextLevel markdown table from window.currentTable (fallback):', {
                fragmentsCount: allFragments.length,
                markdownLength: markdown.length
              });
            }
            
            // Use the same renderMarkdownTable function to render comparison table
            // Pass data object to enable comparison table rendering with both Standard and NextLevel columns
            // Normalize and match original replicas with diarized segments (async)
            (async () => {
              let originalReplicasMatch = new Map();
              if (uploadedDialogueText) {
                try {
                  console.log('üîÑ [COMPARISON] Normalizing original dialogue format...');
                  const normalizedReplicas = normalizeDialogueFormat(uploadedDialogueText);
                  console.log(`‚úÖ [COMPARISON] Normalized ${normalizedReplicas.length} original replicas`);
                  
                  if (normalizedReplicas.length > 0 && allPrimarySegments.length > 0) {
                    console.log('üîÑ [COMPARISON] Starting LLM matching of original replicas with diarized segments...');
                    originalReplicasMatch = await matchOriginalReplicasWithLLM(normalizedReplicas, allPrimarySegments);
                    console.log(`‚úÖ [COMPARISON] LLM matching completed: ${originalReplicasMatch.size} matches found`);
                  } else {
                    console.log('‚ÑπÔ∏è [COMPARISON] Skipping LLM matching: no original replicas or diarized segments');
                  }
                } catch (error) {
                  console.error('‚ùå [COMPARISON] Error during original replicas matching:', error);
                  // Continue without matches - will show empty cells
                }
              }
              
              renderMarkdownTable(data.markdownTable, comparisonContainer, originalSegments, textAnalysis, {
                isComparison: true,
                standardSegments: standardSegments,
                allPrimarySegments: allPrimarySegments, // All segments, not filtered by speaker
                nextLevelMarkdownTable: nextLevelMarkdownTable,
                originalReplicasMatch: originalReplicasMatch // Pass LLM-matched original replicas
              });
            })();
          };
          
          // Try immediately, then retry after delay if markdownTableContainer not ready
          renderComparisonTableWithNextLevel();
          
          // Retry after delay to ensure markdownTableContainer is rendered
          setTimeout(async () => {
            renderComparisonTableWithNextLevel();
            // –û–±—á–∏—Å–ª—é—î–º–æ –º–µ—Ç—Ä–∏–∫–∏ –ø—ñ—Å–ª—è —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥—É —Ç–∞–±–ª–∏—Ü—ñ
            // –û—á—ñ–∫—É—î–º–æ, –ø–æ–∫–∏ —Ç–∞–±–ª–∏—Ü—è –±—É–¥–µ –≥–æ—Ç–æ–≤–∞
            try {
              await waitForComparisonTable(15, 200);
              calculateGroundTruthMetricsFromTable();
            } catch (error) {
              console.warn('‚ö†Ô∏è [showResults] Could not wait for table, calculating metrics anyway:', error);
              // –°–ø—Ä–æ–±—É—î–º–æ —á–µ—Ä–µ–∑ –∑–∞—Ç—Ä–∏–º–∫—É —è–∫ fallback
              setTimeout(() => {
                calculateGroundTruthMetricsFromTable();
              }, 500);
            }
          }, 1000);
        }
      }
      
      // Store textAnalysis in global variable for debug (if available)
      if (textAnalysis) {
        window.lastTextAnalysis = textAnalysis;
        if (!currentAnalysisData.textAnalysis) {
          currentAnalysisData.textAnalysis = textAnalysis;
        }
      }
      
      // –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –∑–∞–≤–∞–Ω—Ç–∞–∂—É—î–º–æ dialogue –∑ localStorage –ø—Ä–∏ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—ñ —Å—Ç–æ—Ä—ñ–Ω–∫–∏
      try {
        const savedDialogue = localStorage.getItem('uploadedDialogueText');
        if (savedDialogue && !window.uploadedDialogueText) {
          window.uploadedDialogueText = savedDialogue;
          console.log('‚úÖ [showResults] Auto-loaded dialogue from localStorage');
        }
      } catch (e) {
        console.warn('‚ö†Ô∏è [showResults] Failed to load dialogue from localStorage:', e);
      }
      
      // NEW LOGIC: Automatically trigger LLM-based analysis and table generation
      // This replaces the old expensive markdown table generation
      // –ù–ï –≤–∏–∫–ª–∏–∫–∞—î–º–æ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ, —è–∫—â–æ –º–æ–¥–∞–ª—å–Ω–µ –≤—ñ–∫–Ω–æ –∑ ground truth –≤—ñ–¥–∫—Ä–∏—Ç–µ
      const debugModal = document.getElementById('debugModal');
      const isDebugModalOpen = debugModal && debugModal.style.display !== 'none';
      
      if (!isDebugModalOpen) {
      console.log('üîÑ [showResults] Triggering automatic LLM analysis and table generation...');
      
      // Wait a bit for DOM to be ready, then trigger runDebugActionNew()
      setTimeout(async () => {
        try {
          // Check if runDebugActionNew function exists and currentAnalysisData is available
          if (typeof runDebugActionNew === 'function' && currentAnalysisData) {
            console.log('‚úÖ [showResults] Calling runDebugActionNew() automatically...');
            await runDebugActionNew();
            console.log('‚úÖ [showResults] Automatic LLM analysis and table generation completed');
          } else {
            console.warn('‚ö†Ô∏è [showResults] runDebugActionNew not available or currentAnalysisData is null');
          }
        } catch (error) {
          console.error('‚ùå [showResults] Error during automatic LLM analysis:', error);
        }
      }, 500); // Small delay to ensure DOM is ready
      } else {
        console.log('‚ÑπÔ∏è [showResults] Debug modal is open, skipping automatic runDebugActionNew()');
      }
    }
    
    // Handle form submission with SSE
    form.addEventListener('submit', async (e) => {
      e.preventDefault();
      
      // Reset UI
      errorMessage.style.display = 'none';
      resultsContainer.style.display = 'none';
      progressSection.style.display = 'block';
      spinner.style.display = 'inline-block';
      btnText.textContent = 'Processing...';
      submitBtn.disabled = true;
      
      initProgressSteps();
      
      const formData = new FormData();
      const audioFile = document.getElementById('audioFile').files[0];
      const language = document.getElementById('language').value;
      
      if (!audioFile) {
        showError('Please select an audio file');
        progressSection.style.display = 'none';
        return;
      }
      
      formData.append('audio', audioFile);
      formData.append('language', language);
      formData.append('speakerCount', demoConfig.speakerCount);
      formData.append('pipelineMode', demoConfig.pipelineMode);
      formData.append('mode', demoConfig.llmMode);
      formData.append('engine', demoConfig.transcriptionEngine);
      
      // Debug: Log what we're sending
      console.log('üîç [DEMO] Sending request with config:', {
        speakerCount: demoConfig.speakerCount,
        pipelineMode: demoConfig.pipelineMode,
        llmMode: demoConfig.llmMode,
        transcriptionEngine: demoConfig.transcriptionEngine,
        isLocal: demoConfig.isLocal,
        language: language
      });
      
      try {
        // Use XHR for SSE support
        xhr = new XMLHttpRequest();
        xhr.open('POST', '/api/diarize-overlap', true);
        
        let buffer = '';
        let finalResult = null;
        
        xhr.onprogress = () => {
          const text = xhr.responseText;
          const newData = text.substring(buffer.length);
          buffer = text;
          
          const lines = newData.split('\n');
          for (const line of lines) {
            if (line.startsWith('data: ')) {
              try {
                const data = JSON.parse(line.substring(6));
                
                if (data.type === 'step-progress') {
                  // Update progress
                  updateProgressStep(data.step, data.status, data.description);
                } else if (data.type === 'final-result') {
                  finalResult = data;
                  console.log('üìã [SSE] Received final-result:', {
                    hasMarkdownTable: !!data.markdownTable,
                    markdownTableLength: data.markdownTable?.length || 0,
                    hasTextAnalysis: !!data.textAnalysis,
                    dataKeys: Object.keys(data)
                  });
                } else if (data.type === 'pipeline-error') {
                  throw new Error(data.error || 'Pipeline error');
                }
              } catch (parseError) {
                console.warn('Failed to parse SSE data:', parseError);
              }
            }
          }
        };
        
        xhr.onload = () => {
          if (xhr.status === 200) {
            console.log('üîç [xhr.onload] Response received, status:', xhr.status);
            console.log('üîç [xhr.onload] Buffer length:', buffer.length);
            
            // Parse final result from buffer
            const lines = buffer.split('\n');
            console.log('üîç [xhr.onload] Total lines in buffer:', lines.length);
            
            for (let i = lines.length - 1; i >= 0; i--) {
              const line = lines[i];
              if (line && line.startsWith('data: ')) {
                try {
                  const data = JSON.parse(line.substring(6));
                  if (data.type === 'final-result' || data.success) {
                    finalResult = data;
                    if (data.type === 'final-result') {
                      delete data.type;
                    }
                    console.log('üìã [xhr.onload] Found final-result in buffer:', {
                      hasPrimaryDiarization: !!data.primaryDiarization,
                      hasCorrectedDiarization: !!data.correctedDiarization,
                      hasMarkdownTable: !!data.markdownTable,
                      markdownTableLength: data.markdownTable?.length || 0,
                      hasTextAnalysis: !!data.textAnalysis,
                      hasGroundTruthMetrics: !!data.groundTruthMetrics,
                      dataKeys: Object.keys(data)
                    });
                    break;
                  }
                } catch (e) {
                  console.warn('‚ö†Ô∏è [xhr.onload] Failed to parse line:', line.substring(0, 100), e);
                  // Continue searching
                }
              }
            }
            
            if (!finalResult) {
              console.error('‚ùå [xhr.onload] No final result found in buffer');
              console.error('Buffer preview:', buffer.substring(0, 1000));
              showError('No final result received. Check console for details.');
              return;
            }
            
            // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –¥–∞–Ω—ñ –¥–ª—è –º–æ–∂–ª–∏–≤–æ—Å—Ç—ñ –ø–æ–≤—Ç–æ—Ä–Ω–æ–≥–æ –∞–Ω–∞–ª—ñ–∑—É
            currentAnalysisData = finalResult;
            
            // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ —Å—Ç–∞–Ω —É localStorage –¥–ª—è –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è
            savePageState(finalResult);
            
            // –°–∫–∏–¥–∞—î–º–æ –ø—Ä–∞–ø–æ—Ä–µ—Ü—å –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –∑ –∫–µ—à—É, –±–æ —Ü–µ –Ω–æ–≤—ñ –¥–∞–Ω—ñ
            window.dataLoadedFromCache = false;
            
            console.log('‚úÖ [xhr.onload] Calling showResults with finalResult');
            resultsContainer.style.display = 'block';
            showResults(finalResult);
          } else {
            try {
              const error = JSON.parse(xhr.responseText);
              throw new Error(error.error || `Server error: ${xhr.status}`);
            } catch (parseError) {
              throw new Error(`Server error: ${xhr.status}`);
            }
          }
        };
        
        xhr.onerror = () => {
          throw new Error('Network error during processing');
        };
        
        xhr.send(formData);
        
      } catch (error) {
        console.error('Error:', error);
        showError(error.message || 'Failed to process audio');
        progressSection.style.display = 'none';
      } finally {
        spinner.style.display = 'none';
        btnText.textContent = 'Process Audio';
        submitBtn.disabled = false;
      }
    });
    
    function showError(message) {
      errorMessage.textContent = message;
      errorMessage.style.display = 'block';
    }
    
    // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è —Å—Ç–∞–Ω—É —Å—Ç–æ—Ä—ñ–Ω–∫–∏ –≤ localStorage
    function savePageState(data) {
      try {
        // –°–ø—Ä–æ–±—É—î–º–æ –∑–±–µ—Ä–µ–≥—Ç–∏ –∞—É–¥—ñ–æ —Ñ–∞–π–ª —è–∫—â–æ —î (–∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ, –Ω–µ –±–ª–æ–∫—É—î–º–æ –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è —Å—Ç–∞–Ω—É)
        const audioFileInput = document.getElementById('audioFile');
        if (audioFileInput && audioFileInput.files && audioFileInput.files.length > 0) {
          const audioFile = audioFileInput.files[0];
          // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ —Ñ–∞–π–ª –≤–∂–µ –∑–±–µ—Ä–µ–∂–µ–Ω–∏–π
          const existingFile = localStorage.getItem('multimodalAudioFile');
          if (!existingFile) {
            // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ —Ñ–∞–π–ª —Ç—ñ–ª—å–∫–∏ —è–∫—â–æ –π–æ–≥–æ —â–µ –Ω–µ–º–∞—î (–∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ)
            const reader = new FileReader();
            reader.onload = function(e) {
              try {
                const fileData = {
                  name: audioFile.name,
                  type: audioFile.type,
                  size: audioFile.size,
                  data: e.target.result,
                  timestamp: Date.now()
                };
                localStorage.setItem('multimodalAudioFile', JSON.stringify(fileData));
                console.log('üíæ [savePageState] Audio file saved to localStorage');
              } catch (fileError) {
                console.warn('‚ö†Ô∏è [savePageState] Could not save audio file:', fileError);
              }
            };
            reader.onerror = function(error) {
              console.warn('‚ö†Ô∏è [savePageState] FileReader error:', error);
            };
            reader.readAsDataURL(audioFile);
          }
        }
        
        const state = {
          timestamp: Date.now(),
          data: data,
          fileName: data.fileName || 'unknown',
          fileUrl: data.fileUrl || null,
          // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ window.currentTable –¥–ª—è –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è —Ç–∞–±–ª–∏—Ü—ñ
          currentTable: window.currentTable || null,
          // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏ multimodal –¥—ñ–∞—Ä–∏–∑–∞—Ü—ñ—ó —è–∫—â–æ —î
          multimodalResult: document.getElementById('multimodalResult')?.value || null
        };
        
        // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –≤ localStorage
        localStorage.setItem('lastFileState', JSON.stringify(state));
        console.log('üíæ [savePageState] State saved successfully', {
          hasCurrentTable: !!state.currentTable,
          hasMultimodalResult: !!state.multimodalResult
        });
      } catch (error) {
        console.error('‚ùå [savePageState] Error saving state:', error);
        // –Ø–∫—â–æ –ø–æ–º–∏–ª–∫–∞ —á–µ—Ä–µ–∑ –ø–µ—Ä–µ–≤–∏—â–µ–Ω–Ω—è –ª—ñ–º—ñ—Ç—É localStorage, —Å–ø—Ä–æ–±—É—î–º–æ –æ—á–∏—Å—Ç–∏—Ç–∏ —Å—Ç–∞—Ä—ñ –¥–∞–Ω—ñ
        if (error.name === 'QuotaExceededError') {
          console.warn('‚ö†Ô∏è [savePageState] localStorage quota exceeded, clearing old data');
          try {
            // –°–ø—Ä–æ–±—É—î–º–æ –∑–±–µ—Ä–µ–≥—Ç–∏ –±–µ–∑ –≤–µ–ª–∏–∫–∏—Ö –¥–∞–Ω–∏—Ö
            const state = {
              timestamp: Date.now(),
              data: data,
              fileName: data.fileName || 'unknown',
              fileUrl: data.fileUrl || null,
              currentTable: null, // –ù–µ –∑–±–µ—Ä—ñ–≥–∞—î–º–æ currentTable —è–∫—â–æ –Ω–µ –≤–º—ñ—â—É—î—Ç—å—Å—è
              multimodalResult: null
            };
            localStorage.removeItem('lastFileState');
            localStorage.setItem('lastFileState', JSON.stringify(state));
          } catch (retryError) {
            console.error('‚ùå [savePageState] Failed to save even after clearing:', retryError);
          }
        }
      }
    }
    
    // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –æ—Å—Ç–∞–Ω–Ω—å–æ–≥–æ —Ñ–∞–π–ª—É –∑ –∫–µ—à—É
    window.loadLastFile = function loadLastFile() {
      try {
        const savedState = localStorage.getItem('lastFileState');
        if (!savedState) {
          alert('‚ùå No saved file found. Please process an audio file first.');
          return;
        }
        
        const state = JSON.parse(savedState);
        
        // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ –¥–∞–Ω—ñ –Ω–µ –∑–∞—Å—Ç–∞—Ä—ñ–ª—ñ (–±—ñ–ª—å—à–µ 7 –¥–Ω—ñ–≤)
        const daysSinceSave = (Date.now() - state.timestamp) / (1000 * 60 * 60 * 24);
        if (daysSinceSave > 7) {
          const confirmLoad = confirm(
            `‚ö†Ô∏è This file was saved ${Math.round(daysSinceSave)} days ago. ` +
            `Do you want to load it anyway?`
          );
          if (!confirmLoad) {
            return;
          }
        }
        
        // –í—ñ–¥–Ω–æ–≤–ª—é—î–º–æ –¥–∞–Ω—ñ
        currentAnalysisData = state.data;
        
        // –í–ê–ñ–õ–ò–í–û: –í—Å—Ç–∞–Ω–æ–≤–ª—é—î–º–æ –ø—Ä–∞–ø–æ—Ä–µ—Ü—å –ü–ï–†–ï–î –≤–∏–∫–ª–∏–∫–æ–º showResults, —â–æ–± –æ–±—Ä–æ–±–∫–∞ –Ω–µ –∑–∞–ø—É—Å—Ç–∏–ª–∞—Å—è
        window.dataLoadedFromCache = true;
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        console.log('üì¶ [loadLastFile] Data loaded from cache');
        console.log('üì¶ [loadLastFile] Flag set: window.dataLoadedFromCache = true');
        console.log('üì¶ [loadLastFile] Multimodal processing will be skipped');
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        
        // –í—ñ–¥–Ω–æ–≤–ª—é—î–º–æ window.currentTable —è–∫—â–æ –∑–±–µ—Ä–µ–∂–µ–Ω–æ
        if (state.currentTable) {
          window.currentTable = state.currentTable;
          console.log('‚úÖ [loadLastFile] Restored window.currentTable:', {
            tracksCount: Array.isArray(state.currentTable) ? state.currentTable.length : 0
          });
        }
        
        // –í—ñ–¥–Ω–æ–≤–ª—é—î–º–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏ multimodal –¥—ñ–∞—Ä–∏–∑–∞—Ü—ñ—ó —è–∫—â–æ –∑–±–µ—Ä–µ–∂–µ–Ω–æ
        if (state.multimodalResult) {
          const multimodalResultEl = document.getElementById('multimodalResult');
          if (multimodalResultEl) {
            multimodalResultEl.value = state.multimodalResult;
            console.log('‚úÖ [loadLastFile] Restored multimodal result');
          }
        }
        
        // –°–ø—Ä–æ–±—É—î–º–æ –≤—ñ–¥–Ω–æ–≤–∏—Ç–∏ –∞—É–¥—ñ–æ —Ñ–∞–π–ª –∑—ñ –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è
        const savedAudioFile = loadAudioFileFromStorage();
        if (savedAudioFile) {
          const audioFileInput = document.getElementById('audioFile');
          if (audioFileInput) {
            const dataTransfer = new DataTransfer();
            dataTransfer.items.add(savedAudioFile);
            audioFileInput.files = dataTransfer.files;
            console.log('‚úÖ [loadLastFile] Restored audio file from storage');
          }
        }
        
        // –ü–æ–∫–∞–∑—É—î–º–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏ (–ø—Ä–∞–ø–æ—Ä–µ—Ü—å –≤–∂–µ –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ, —Ç–æ–º—É –æ–±—Ä–æ–±–∫–∞ –Ω–µ –∑–∞–ø—É—Å—Ç–∏—Ç—å—Å—è)
        console.log('üìã [loadLastFile] Calling showResults() - multimodal processing will be skipped due to cache flag');
        resultsContainer.style.display = 'block';
        showResults(state.data);
        
        // –Ø–∫—â–æ —î window.currentTable, –æ–Ω–æ–≤–ª—é—î–º–æ —Ç–∞–±–ª–∏—Ü—é –∑ –∞–∫—Ç—É–∞–ª—å–Ω–∏–º–∏ –¥–∞–Ω–∏–º–∏
        if (window.currentTable && Array.isArray(window.currentTable) && window.currentTable.length > 0) {
          console.log('üîÑ [loadLastFile] Updating table with currentTable data...');
          console.log('üì¶ [loadLastFile] Cache flag status before applyDebugMarkup:', window.dataLoadedFromCache);
          
          // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ applyDebugMarkup –¥–ª—è –æ–Ω–æ–≤–ª–µ–Ω–Ω—è —Ç–∞–±–ª–∏—Ü—ñ
          // –ü—Ä–∞–ø–æ—Ä–µ—Ü—å window.dataLoadedFromCache –≤–∂–µ –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –≤–∏—â–µ, —Ç–æ–º—É multimodal –æ–±—Ä–æ–±–∫–∞ –±—É–¥–µ –ø—Ä–æ–ø—É—â–µ–Ω–∞
          setTimeout(() => {
            // –ü–µ—Ä–µ–∫–æ–Ω—É—î–º–æ—Å—è, —â–æ –ø—Ä–∞–ø–æ—Ä–µ—Ü—å –≤—Å–µ —â–µ –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –ø–µ—Ä–µ–¥ –≤–∏–∫–ª–∏–∫–æ–º
            if (!window.dataLoadedFromCache) {
              window.dataLoadedFromCache = true;
              console.log('üì¶ [loadLastFile] Re-setting cache flag before applyDebugMarkup');
            }
            
            applyDebugMarkup(true).then(() => {
              console.log('‚úÖ [loadLastFile] Table updated with currentTable data (from cache)');
              // –°–∫–∏–¥–∞—î–º–æ –ø—Ä–∞–ø–æ—Ä–µ—Ü—å —Ç—ñ–ª—å–∫–∏ –ø—ñ—Å–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è applyDebugMarkup
              window.dataLoadedFromCache = false;
              console.log('üì¶ [loadLastFile] Cache flag cleared after applyDebugMarkup');
            }).catch(err => {
              console.error('‚ùå [loadLastFile] Error updating table:', err);
              // –°–∫–∏–¥–∞—î–º–æ –ø—Ä–∞–ø–æ—Ä–µ—Ü—å –Ω–∞–≤—ñ—Ç—å –ø—Ä–∏ –ø–æ–º–∏–ª—Ü—ñ
              window.dataLoadedFromCache = false;
            });
          }, 500); // –ù–µ–≤–µ–ª–∏–∫–∞ –∑–∞—Ç—Ä–∏–º–∫–∞ –¥–ª—è –∑–∞–±–µ–∑–ø–µ—á–µ–Ω–Ω—è –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç—ñ DOM
        } else {
          // –Ø–∫—â–æ –Ω–µ–º–∞—î currentTable, –≤—Å–µ –æ–¥–Ω–æ —Å–∫–∏–¥–∞—î–º–æ –ø—Ä–∞–ø–æ—Ä–µ—Ü—å
          window.dataLoadedFromCache = false;
        }
        
        // –ü–æ–∫–∞–∑—É—î–º–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –ø—Ä–æ —É—Å–ø—ñ—Ö
        const successMsg = document.createElement('div');
        successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #16a085; color: white; padding: 12px 20px; border-radius: 8px; z-index: 10000; box-shadow: 0 4px 6px rgba(0,0,0,0.1);';
        const savedDate = new Date(state.timestamp).toLocaleString();
        successMsg.innerHTML = `‚úÖ Last file loaded successfully!<br><small>Saved: ${savedDate}</small>`;
        document.body.appendChild(successMsg);
        setTimeout(() => successMsg.remove(), 5000);
        
        console.log('‚úÖ [loadLastFile] Last file loaded successfully');
      } catch (error) {
        console.error('‚ùå [loadLastFile] Error loading last file:', error);
        alert(`‚ùå Failed to load last file: ${error.message}`);
      }
    }
    
    // –ï–∫—Å–ø–æ—Ä—Ç—É—î–º–æ —Ñ—É–Ω–∫—Ü—ñ—é –≥–ª–æ–±–∞–ª—å–Ω–æ –¥–ª—è –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è –≤ onclick
    window.loadLastFile = loadLastFile;
    
    // Tooltip functionality with hover persistence
    document.addEventListener('DOMContentLoaded', function() {
      const tooltipTriggers = document.querySelectorAll('.tooltip-trigger');
      
      tooltipTriggers.forEach(trigger => {
        const tooltip = trigger.querySelector('.tooltip-content');
        if (!tooltip) return;
        
        let hideTimeout = null;
        
        const showTooltip = () => {
          if (hideTimeout) {
            clearTimeout(hideTimeout);
            hideTimeout = null;
          }
          tooltip.style.opacity = '1';
          tooltip.style.visibility = 'visible';
        };
        
        const hideTooltip = () => {
          hideTimeout = setTimeout(() => {
            tooltip.style.opacity = '0';
            tooltip.style.visibility = 'hidden';
          }, 100); // Small delay to allow moving to tooltip
        };
        
        trigger.addEventListener('mouseenter', showTooltip);
        trigger.addEventListener('mouseleave', hideTooltip);
        
        // Allow hovering over tooltip itself
        tooltip.addEventListener('mouseenter', showTooltip);
        tooltip.addEventListener('mouseleave', hideTooltip);
      });
    });
  </script>
</body>
</html>
